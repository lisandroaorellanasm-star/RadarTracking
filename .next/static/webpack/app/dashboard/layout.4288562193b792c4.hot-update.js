"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/layout",{

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    createBrowserSupabaseClient: ()=>createBrowserSupabaseClient,\n    createClientComponentClient: ()=>createClientComponentClient,\n    createMiddlewareClient: ()=>createMiddlewareClient,\n    createMiddlewareSupabaseClient: ()=>createMiddlewareSupabaseClient,\n    createPagesBrowserClient: ()=>createPagesBrowserClient,\n    createPagesServerClient: ()=>createPagesServerClient,\n    createRouteHandlerClient: ()=>createRouteHandlerClient,\n    createServerActionClient: ()=>createServerActionClient,\n    createServerComponentClient: ()=>createServerComponentClient,\n    createServerSupabaseClient: ()=>createServerSupabaseClient\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/clientComponentClient.ts\nvar import_auth_helpers_shared = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar supabase;\nfunction createClientComponentClient() {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions, isSingleton = true } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    const createNewClient = ()=>{\n        var _a;\n        return (0, import_auth_helpers_shared.createSupabaseClient)(supabaseUrl, supabaseKey, {\n            ...options,\n            global: {\n                ...options == null ? void 0 : options.global,\n                headers: {\n                    ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                    \"X-Client-Info\": \"@supabase/auth-helpers-nextjs@0.8.7\"\n                }\n            },\n            auth: {\n                storage: new import_auth_helpers_shared.BrowserCookieAuthStorageAdapter(cookieOptions)\n            }\n        });\n    };\n    if (isSingleton) {\n        const _supabase = supabase !== null && supabase !== void 0 ? supabase : createNewClient();\n        if (false) {}\n        if (!supabase) supabase = _supabase;\n        return supabase;\n    }\n    return createNewClient();\n}\n// src/pagesBrowserClient.ts\nvar createPagesBrowserClient = createClientComponentClient;\n// src/pagesServerClient.ts\nvar import_auth_helpers_shared2 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar NextServerAuthStorageAdapter = class extends import_auth_helpers_shared2.CookieAuthStorageAdapter {\n    getCookie(name) {\n        var _a, _b, _c;\n        var _ref;\n        const setCookie = (0, import_set_cookie_parser.splitCookiesString)((_ref = (_b = (_a = this.context.res) == null ? void 0 : _a.getHeader(\"set-cookie\")) == null ? void 0 : _b.toString()) !== null && _ref !== void 0 ? _ref : \"\").map((c)=>(0, import_auth_helpers_shared2.parseCookies)(c)[name]).find((c)=>!!c);\n        const value = setCookie !== null && setCookie !== void 0 ? setCookie : (_c = this.context.req) == null ? void 0 : _c.cookies[name];\n        return value;\n    }\n    setCookie(name, value) {\n        this._setCookie(name, value);\n    }\n    deleteCookie(name) {\n        this._setCookie(name, \"\", {\n            maxAge: 0\n        });\n    }\n    _setCookie(name, value, options) {\n        var _a;\n        var _ref;\n        const setCookies = (0, import_set_cookie_parser.splitCookiesString)((_ref = (_a = this.context.res.getHeader(\"set-cookie\")) == null ? void 0 : _a.toString()) !== null && _ref !== void 0 ? _ref : \"\").filter((c)=>!(name in (0, import_auth_helpers_shared2.parseCookies)(c)));\n        const cookieStr = (0, import_auth_helpers_shared2.serializeCookie)(name, value, {\n            ...this.cookieOptions,\n            ...options,\n            // Allow supabase-js on the client to read the cookie as well\n            httpOnly: false\n        });\n        this.context.res.setHeader(\"set-cookie\", [\n            ...setCookies,\n            cookieStr\n        ]);\n    }\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n};\nfunction createPagesServerClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared2.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": \"@supabase/auth-helpers-nextjs@0.8.7\"\n            }\n        },\n        auth: {\n            storage: new NextServerAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/middlewareClient.ts\nvar import_auth_helpers_shared3 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar import_set_cookie_parser2 = __webpack_require__(/*! set-cookie-parser */ \"(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar NextMiddlewareAuthStorageAdapter = class extends import_auth_helpers_shared3.CookieAuthStorageAdapter {\n    getCookie(name) {\n        var _a;\n        var _ref;\n        const setCookie = (0, import_set_cookie_parser2.splitCookiesString)((_ref = (_a = this.context.res.headers.get(\"set-cookie\")) == null ? void 0 : _a.toString()) !== null && _ref !== void 0 ? _ref : \"\").map((c)=>(0, import_auth_helpers_shared3.parseCookies)(c)[name]).find((c)=>!!c);\n        if (setCookie) {\n            return setCookie;\n        }\n        var _this_context_req_headers_get;\n        const cookies = (0, import_auth_helpers_shared3.parseCookies)((_this_context_req_headers_get = this.context.req.headers.get(\"cookie\")) !== null && _this_context_req_headers_get !== void 0 ? _this_context_req_headers_get : \"\");\n        return cookies[name];\n    }\n    setCookie(name, value) {\n        this._setCookie(name, value);\n    }\n    deleteCookie(name) {\n        this._setCookie(name, \"\", {\n            maxAge: 0\n        });\n    }\n    _setCookie(name, value, options) {\n        const newSessionStr = (0, import_auth_helpers_shared3.serializeCookie)(name, value, {\n            ...this.cookieOptions,\n            ...options,\n            // Allow supabase-js on the client to read the cookie as well\n            httpOnly: false\n        });\n        if (this.context.res.headers) {\n            this.context.res.headers.append(\"set-cookie\", newSessionStr);\n        }\n    }\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n};\nfunction createMiddlewareClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared3.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": \"@supabase/auth-helpers-nextjs@0.8.7\"\n            }\n        },\n        auth: {\n            storage: new NextMiddlewareAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/serverComponentClient.ts\nvar import_auth_helpers_shared4 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar NextServerComponentAuthStorageAdapter = class extends import_auth_helpers_shared4.CookieAuthStorageAdapter {\n    getCookie(name) {\n        var _a;\n        const nextCookies = this.context.cookies();\n        return (_a = nextCookies.get(name)) == null ? void 0 : _a.value;\n    }\n    setCookie(name, value) {}\n    deleteCookie(name) {}\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n};\nfunction createServerComponentClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared4.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": \"@supabase/auth-helpers-nextjs@0.8.7\"\n            }\n        },\n        auth: {\n            storage: new NextServerComponentAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/routeHandlerClient.ts\nvar import_auth_helpers_shared5 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar NextRouteHandlerAuthStorageAdapter = class extends import_auth_helpers_shared5.CookieAuthStorageAdapter {\n    getCookie(name) {\n        var _a;\n        const nextCookies = this.context.cookies();\n        return (_a = nextCookies.get(name)) == null ? void 0 : _a.value;\n    }\n    setCookie(name, value) {\n        const nextCookies = this.context.cookies();\n        nextCookies.set(name, value, this.cookieOptions);\n    }\n    deleteCookie(name) {\n        const nextCookies = this.context.cookies();\n        nextCookies.set(name, \"\", {\n            ...this.cookieOptions,\n            maxAge: 0\n        });\n    }\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n};\nfunction createRouteHandlerClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared5.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": \"@supabase/auth-helpers-nextjs@0.8.7\"\n            }\n        },\n        auth: {\n            storage: new NextRouteHandlerAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/serverActionClient.ts\nvar createServerActionClient = createRouteHandlerClient;\n// src/deprecated.ts\nfunction createBrowserSupabaseClient() {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    console.warn(\"Please utilize the `createPagesBrowserClient` function instead of the deprecated `createBrowserSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages\");\n    return createPagesBrowserClient({\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\nfunction createServerSupabaseClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    console.warn(\"Please utilize the `createPagesServerClient` function instead of the deprecated `createServerSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages\");\n    return createPagesServerClient(context, {\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\nfunction createMiddlewareSupabaseClient(context) {\n    let { supabaseUrl = \"https://yxdbyfpphruqycdcefys.supabase.co\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4ZGJ5ZnBwaHJ1cXljZGNlZnlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0ODY4MjksImV4cCI6MjA4NjA2MjgyOX0.XiKD_lYIDVr7KO5knR1G_8Zpqk8L_hOXHR8O-J8YXH0\", options, cookieOptions } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    console.warn(\"Please utilize the `createMiddlewareClient` function instead of the deprecated `createMiddlewareSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs#middleware\");\n    return createMiddlewareClient(context, {\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJGLE9BQU9HLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JKLE9BQU9LLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlTixPQUFPTyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZaLFVBQVVXLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUNBLElBQUlDLGNBQWMsQ0FBQ0MsSUFBSUMsTUFBTUMsUUFBUUM7SUFDbkMsSUFBSUYsUUFBUSxPQUFPQSxTQUFTLFlBQVksT0FBT0EsU0FBUyxZQUFZO1FBQ2xFLEtBQUssSUFBSUcsT0FBT2hCLGtCQUFrQmEsTUFDaEMsSUFBSSxDQUFDWCxhQUFhZSxJQUFJLENBQUNMLElBQUlJLFFBQVFBLFFBQVFGLFFBQ3pDbkIsVUFBVWlCLElBQUlJLEtBQUs7WUFBRVAsS0FBSyxJQUFNSSxJQUFJLENBQUNHLElBQUk7WUFBRU4sWUFBWSxDQUFFSyxDQUFBQSxPQUFPakIsaUJBQWlCZSxNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxlQUFlLENBQUNDLE1BQVFSLFlBQVloQixVQUFVLENBQUMsR0FBRyxjQUFjO1FBQUV5QixPQUFPO0lBQUssSUFBSUQ7QUFFdEYsZUFBZTtBQUNmLElBQUlFLGNBQWMsQ0FBQztBQUNuQmhCLFNBQVNnQixhQUFhO0lBQ3BCQyw2QkFBNkIsSUFBTUE7SUFDbkNDLDZCQUE2QixJQUFNQTtJQUNuQ0Msd0JBQXdCLElBQU1BO0lBQzlCQyxn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Q0FBQztJQUNIb0QsUUFBUUMsSUFBSSxDQUNWO0lBRUYsT0FBT3pFLHVCQUF1QnlDLFNBQVM7UUFDckM1QjtRQUNBSTtRQUNBRTtRQUNBQztJQUNGO0FBQ0Y7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTVosQ0FBQUEsQ0FXTixHQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9pbmRleC5qcz9jZjkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudDogKCkgPT4gY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50LFxuICBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQ6ICgpID0+IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCxcbiAgY3JlYXRlTWlkZGxld2FyZUNsaWVudDogKCkgPT4gY3JlYXRlTWlkZGxld2FyZUNsaWVudCxcbiAgY3JlYXRlTWlkZGxld2FyZVN1cGFiYXNlQ2xpZW50OiAoKSA9PiBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQsXG4gIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudDogKCkgPT4gY3JlYXRlUGFnZXNCcm93c2VyQ2xpZW50LFxuICBjcmVhdGVQYWdlc1NlcnZlckNsaWVudDogKCkgPT4gY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQsXG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudDogKCkgPT4gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50LFxuICBjcmVhdGVTZXJ2ZXJBY3Rpb25DbGllbnQ6ICgpID0+IGNyZWF0ZVNlcnZlckFjdGlvbkNsaWVudCxcbiAgY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50OiAoKSA9PiBjcmVhdGVTZXJ2ZXJDb21wb25lbnRDbGllbnQsXG4gIGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50OiAoKSA9PiBjcmVhdGVTZXJ2ZXJTdXBhYmFzZUNsaWVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9jbGllbnRDb21wb25lbnRDbGllbnQudHNcbnZhciBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZCA9IHJlcXVpcmUoXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXNoYXJlZFwiKTtcbnZhciBzdXBhYmFzZTtcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCh7XG4gIHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMLFxuICBzdXBhYmFzZUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZLFxuICBvcHRpb25zLFxuICBjb29raWVPcHRpb25zLFxuICBpc1NpbmdsZXRvbiA9IHRydWVcbn0gPSB7fSkge1xuICBpZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiZWl0aGVyIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBhbmQgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52IHZhcmlhYmxlcyBvciBzdXBhYmFzZVVybCBhbmQgc3VwYWJhc2VLZXkgYXJlIHJlcXVpcmVkIVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBjcmVhdGVOZXdDbGllbnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQuY3JlYXRlU3VwYWJhc2VDbGllbnQpKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdsb2JhbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgICBcIlgtQ2xpZW50LUluZm9cIjogYCR7XCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wifUAke1wiMC44LjdcIn1gXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhdXRoOiB7XG4gICAgICAgIHN0b3JhZ2U6IG5ldyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZC5Ccm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyKGNvb2tpZU9wdGlvbnMpXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGlmIChpc1NpbmdsZXRvbikge1xuICAgIGNvbnN0IF9zdXBhYmFzZSA9IHN1cGFiYXNlID8/IGNyZWF0ZU5ld0NsaWVudCgpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuIF9zdXBhYmFzZTtcbiAgICBpZiAoIXN1cGFiYXNlKVxuICAgICAgc3VwYWJhc2UgPSBfc3VwYWJhc2U7XG4gICAgcmV0dXJuIHN1cGFiYXNlO1xuICB9XG4gIHJldHVybiBjcmVhdGVOZXdDbGllbnQoKTtcbn1cblxuLy8gc3JjL3BhZ2VzQnJvd3NlckNsaWVudC50c1xudmFyIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCA9IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudDtcblxuLy8gc3JjL3BhZ2VzU2VydmVyQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlciA9IHJlcXVpcmUoXCJzZXQtY29va2llLXBhcnNlclwiKTtcbnZhciBOZXh0U2VydmVyQXV0aFN0b3JhZ2VBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIuQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgY29va2llT3B0aW9ucykge1xuICAgIHN1cGVyKGNvb2tpZU9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbiAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZXRDb29raWUgPSAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZykoXG4gICAgICAoKF9iID0gKF9hID0gdGhpcy5jb250ZXh0LnJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEhlYWRlcihcInNldC1jb29raWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKSA/PyBcIlwiXG4gICAgKS5tYXAoKGMpID0+ICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIucGFyc2VDb29raWVzKShjKVtuYW1lXSkuZmluZCgoYykgPT4gISFjKTtcbiAgICBjb25zdCB2YWx1ZSA9IHNldENvb2tpZSA/PyAoKF9jID0gdGhpcy5jb250ZXh0LnJlcSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNvb2tpZXNbbmFtZV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zZXRDb29raWUobmFtZSwgdmFsdWUpO1xuICB9XG4gIGRlbGV0ZUNvb2tpZShuYW1lKSB7XG4gICAgdGhpcy5fc2V0Q29va2llKG5hbWUsIFwiXCIsIHtcbiAgICAgIG1heEFnZTogMFxuICAgIH0pO1xuICB9XG4gIF9zZXRDb29raWUobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2V0Q29va2llcyA9ICgwLCBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKShcbiAgICAgICgoX2EgPSB0aGlzLmNvbnRleHQucmVzLmdldEhlYWRlcihcInNldC1jb29raWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSA/PyBcIlwiXG4gICAgKS5maWx0ZXIoKGMpID0+ICEobmFtZSBpbiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyLnBhcnNlQ29va2llcykoYykpKTtcbiAgICBjb25zdCBjb29raWVTdHIgPSAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyLnNlcmlhbGl6ZUNvb2tpZSkobmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBBbGxvdyBzdXBhYmFzZS1qcyBvbiB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGNvb2tpZSBhcyB3ZWxsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRleHQucmVzLnNldEhlYWRlcihcInNldC1jb29raWVcIiwgWy4uLnNldENvb2tpZXMsIGNvb2tpZVN0cl0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImVpdGhlciBORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgYW5kIE5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIGVudiB2YXJpYWJsZXMgb3Igc3VwYWJhc2VVcmwgYW5kIHN1cGFiYXNlS2V5IGFyZSByZXF1aXJlZCFcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIuY3JlYXRlU3VwYWJhc2VDbGllbnQpKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZ2xvYmFsOiB7XG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdsb2JhbCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oZWFkZXJzLFxuICAgICAgICBcIlgtQ2xpZW50LUluZm9cIjogYCR7XCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wifUAke1wiMC44LjdcIn1gXG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRoOiB7XG4gICAgICBzdG9yYWdlOiBuZXcgTmV4dFNlcnZlckF1dGhTdG9yYWdlQWRhcHRlcihjb250ZXh0LCBjb29raWVPcHRpb25zKVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlcjIgPSByZXF1aXJlKFwic2V0LWNvb2tpZS1wYXJzZXJcIik7XG52YXIgTmV4dE1pZGRsZXdhcmVBdXRoU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkMy5Db29raWVBdXRoU3RvcmFnZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb29raWVPcHRpb25zKSB7XG4gICAgc3VwZXIoY29va2llT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBnZXRDb29raWUobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZXRDb29raWUgPSAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyMi5zcGxpdENvb2tpZXNTdHJpbmcpKFxuICAgICAgKChfYSA9IHRoaXMuY29udGV4dC5yZXMuaGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgPz8gXCJcIlxuICAgICkubWFwKChjKSA9PiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLnBhcnNlQ29va2llcykoYylbbmFtZV0pLmZpbmQoKGMpID0+ICEhYyk7XG4gICAgaWYgKHNldENvb2tpZSkge1xuICAgICAgcmV0dXJuIHNldENvb2tpZTtcbiAgICB9XG4gICAgY29uc3QgY29va2llcyA9ICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDMucGFyc2VDb29raWVzKSh0aGlzLmNvbnRleHQucmVxLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpID8/IFwiXCIpO1xuICAgIHJldHVybiBjb29raWVzW25hbWVdO1xuICB9XG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX3NldENvb2tpZShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZGVsZXRlQ29va2llKG5hbWUpIHtcbiAgICB0aGlzLl9zZXRDb29raWUobmFtZSwgXCJcIiwge1xuICAgICAgbWF4QWdlOiAwXG4gICAgfSk7XG4gIH1cbiAgX3NldENvb2tpZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5ld1Nlc3Npb25TdHIgPSAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLnNlcmlhbGl6ZUNvb2tpZSkobmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBBbGxvdyBzdXBhYmFzZS1qcyBvbiB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGNvb2tpZSBhcyB3ZWxsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jb250ZXh0LnJlcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzLmhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBuZXdTZXNzaW9uU3RyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlQ2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRNaWRkbGV3YXJlQXV0aFN0b3JhZ2VBZGFwdGVyKGNvbnRleHQsIGNvb2tpZU9wdGlvbnMpXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3NlcnZlckNvbXBvbmVudENsaWVudC50c1xudmFyIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkNCA9IHJlcXVpcmUoXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXNoYXJlZFwiKTtcbnZhciBOZXh0U2VydmVyQ29tcG9uZW50QXV0aFN0b3JhZ2VBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDQuQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgY29va2llT3B0aW9ucykge1xuICAgIHN1cGVyKGNvb2tpZU9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbiAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbmV4dENvb2tpZXMgPSB0aGlzLmNvbnRleHQuY29va2llcygpO1xuICAgIHJldHVybiAoX2EgPSBuZXh0Q29va2llcy5nZXQobmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgfVxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgfVxuICBkZWxldGVDb29raWUobmFtZSkge1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ0LmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRTZXJ2ZXJDb21wb25lbnRBdXRoU3RvcmFnZUFkYXB0ZXIoY29udGV4dCwgY29va2llT3B0aW9ucylcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcm91dGVIYW5kbGVyQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1ID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIE5leHRSb3V0ZUhhbmRsZXJBdXRoU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkNS5Db29raWVBdXRoU3RvcmFnZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb29raWVPcHRpb25zKSB7XG4gICAgc3VwZXIoY29va2llT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBnZXRDb29raWUobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuZXh0Q29va2llcyA9IHRoaXMuY29udGV4dC5jb29raWVzKCk7XG4gICAgcmV0dXJuIChfYSA9IG5leHRDb29raWVzLmdldChuYW1lKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICB9XG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG5leHRDb29raWVzID0gdGhpcy5jb250ZXh0LmNvb2tpZXMoKTtcbiAgICBuZXh0Q29va2llcy5zZXQobmFtZSwgdmFsdWUsIHRoaXMuY29va2llT3B0aW9ucyk7XG4gIH1cbiAgZGVsZXRlQ29va2llKG5hbWUpIHtcbiAgICBjb25zdCBuZXh0Q29va2llcyA9IHRoaXMuY29udGV4dC5jb29raWVzKCk7XG4gICAgbmV4dENvb2tpZXMuc2V0KG5hbWUsIFwiXCIsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIG1heEFnZTogMFxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1LmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRSb3V0ZUhhbmRsZXJBdXRoU3RvcmFnZUFkYXB0ZXIoY29udGV4dCwgY29va2llT3B0aW9ucylcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvc2VydmVyQWN0aW9uQ2xpZW50LnRzXG52YXIgY3JlYXRlU2VydmVyQWN0aW9uQ2xpZW50ID0gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50O1xuXG4vLyBzcmMvZGVwcmVjYXRlZC50c1xuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50KHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJQbGVhc2UgdXRpbGl6ZSB0aGUgYGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudGAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVwcmVjYXRlZCBgY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzLXBhZ2VzXCJcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCh7XG4gICAgc3VwYWJhc2VVcmwsXG4gICAgc3VwYWJhc2VLZXksXG4gICAgb3B0aW9ucyxcbiAgICBjb29raWVPcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmVyU3VwYWJhc2VDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIGNvbnNvbGUud2FybihcbiAgICBcIlBsZWFzZSB1dGlsaXplIHRoZSBgY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnRgIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGRlcHJlY2F0ZWQgYGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzLXBhZ2VzXCJcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZVBhZ2VzU2VydmVyQ2xpZW50KGNvbnRleHQsIHtcbiAgICBzdXBhYmFzZVVybCxcbiAgICBzdXBhYmFzZUtleSxcbiAgICBvcHRpb25zLFxuICAgIGNvb2tpZU9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIGNvbnNvbGUud2FybihcbiAgICBcIlBsZWFzZSB1dGlsaXplIHRoZSBgY3JlYXRlTWlkZGxld2FyZUNsaWVudGAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVwcmVjYXRlZCBgY3JlYXRlTWlkZGxld2FyZVN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzI21pZGRsZXdhcmVcIlxuICApO1xuICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZUNsaWVudChjb250ZXh0LCB7XG4gICAgc3VwYWJhc2VVcmwsXG4gICAgc3VwYWJhc2VLZXksXG4gICAgb3B0aW9ucyxcbiAgICBjb29raWVPcHRpb25zXG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudCxcbiAgY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50LFxuICBjcmVhdGVNaWRkbGV3YXJlQ2xpZW50LFxuICBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQsXG4gIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCxcbiAgY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQsXG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCxcbiAgY3JlYXRlU2VydmVyQWN0aW9uQ2xpZW50LFxuICBjcmVhdGVTZXJ2ZXJDb21wb25lbnRDbGllbnQsXG4gIGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX190b0NvbW1vbkpTIiwibW9kIiwidmFsdWUiLCJzcmNfZXhwb3J0cyIsImNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudCIsImNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCIsImNyZWF0ZU1pZGRsZXdhcmVDbGllbnQiLCJjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQiLCJjcmVhdGVQYWdlc0Jyb3dzZXJDbGllbnQiLCJjcmVhdGVQYWdlc1NlcnZlckNsaWVudCIsImNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCIsImNyZWF0ZVNlcnZlckFjdGlvbkNsaWVudCIsImNyZWF0ZVNlcnZlckNvbXBvbmVudENsaWVudCIsImNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsImltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkIiwicmVxdWlyZSIsInN1cGFiYXNlIiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VLZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIm9wdGlvbnMiLCJjb29raWVPcHRpb25zIiwiaXNTaW5nbGV0b24iLCJFcnJvciIsImNyZWF0ZU5ld0NsaWVudCIsIl9hIiwiY3JlYXRlU3VwYWJhc2VDbGllbnQiLCJnbG9iYWwiLCJoZWFkZXJzIiwiYXV0aCIsInN0b3JhZ2UiLCJCcm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIiwiX3N1cGFiYXNlIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyIiwiaW1wb3J0X3NldF9jb29raWVfcGFyc2VyIiwiTmV4dFNlcnZlckF1dGhTdG9yYWdlQWRhcHRlciIsIkNvb2tpZUF1dGhTdG9yYWdlQWRhcHRlciIsImdldENvb2tpZSIsIl9iIiwiX2MiLCJzZXRDb29raWUiLCJzcGxpdENvb2tpZXNTdHJpbmciLCJjb250ZXh0IiwicmVzIiwiZ2V0SGVhZGVyIiwidG9TdHJpbmciLCJtYXAiLCJjIiwicGFyc2VDb29raWVzIiwiZmluZCIsInJlcSIsImNvb2tpZXMiLCJfc2V0Q29va2llIiwiZGVsZXRlQ29va2llIiwibWF4QWdlIiwic2V0Q29va2llcyIsImZpbHRlciIsImNvb2tpZVN0ciIsInNlcmlhbGl6ZUNvb2tpZSIsImh0dHBPbmx5Iiwic2V0SGVhZGVyIiwiY29uc3RydWN0b3IiLCJpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDMiLCJpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIyIiwiTmV4dE1pZGRsZXdhcmVBdXRoU3RvcmFnZUFkYXB0ZXIiLCJuZXdTZXNzaW9uU3RyIiwiYXBwZW5kIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ0IiwiTmV4dFNlcnZlckNvbXBvbmVudEF1dGhTdG9yYWdlQWRhcHRlciIsIm5leHRDb29raWVzIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1IiwiTmV4dFJvdXRlSGFuZGxlckF1dGhTdG9yYWdlQWRhcHRlciIsInNldCIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7QUFBOEM7QUFDOUMsTUFBTUMsZUFBZUQsdURBQWNBO0FBQ25DLCtEQUFlQyxZQUFZQSxFQUFDLENBQzVCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzPzIwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuY29uc3QgQXV0aEFkbWluQXBpID0gR29UcnVlQWRtaW5BcGk7XG5leHBvcnQgZGVmYXVsdCBBdXRoQWRtaW5BcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiQXV0aEFkbWluQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQTBDO0FBQzFDLE1BQU1DLGFBQWFELHFEQUFZQTtBQUMvQiwrREFBZUMsVUFBVUEsRUFBQyxDQUMxQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0F1dGhDbGllbnQuanM/NGY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmNvbnN0IEF1dGhDbGllbnQgPSBHb1RydWVDbGllbnQ7XG5leHBvcnQgZGVmYXVsdCBBdXRoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aENsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQ2xpZW50IiwiQXV0aENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GoTrueAdminApi; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/types */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\n\nclass GoTrueAdminApi {\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt) {\n        let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES[0];\n        if (_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(\"@supabase/auth-js: Parameter scope must be one of \".concat(_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.join(\", \")));\n        }\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/logout?scope=\").concat(scope), {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/invite\"), {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/admin/generate_link\"), {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/admin/users\"), {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/admin/users\"), {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[\"\".concat(rel, \"Page\")] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/admin/users/\").concat(uid), {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data. Changes are applied directly without confirmation flows.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", \"\".concat(this.url, \"/admin/users/\").concat(uid), {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id) {\n        let shouldSoftDelete = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(id);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/admin/users/\").concat(id), {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/admin/users/\").concat(params.userId, \"/factors\"), {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.id);\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/admin/users/\").concat(params.userId, \"/factors/\").concat(params.id), {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/admin/oauth/clients\"), {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[\"\".concat(rel, \"Page\")] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, clients), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        clients: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _createOAuthClient(params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/admin/oauth/clients\"), {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _getOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/admin/oauth/clients/\").concat(clientId), {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates an existing OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _updateOAuthClient(clientId, params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", \"\".concat(this.url, \"/admin/oauth/clients/\").concat(clientId), {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _deleteOAuthClient(clientId) {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/admin/oauth/clients/\").concat(clientId), {\n                headers: this.headers,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/admin/oauth/clients/\").concat(clientId, \"/regenerate_secret\"), {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates an admin API client that can be used to manage users and OAuth clients.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueAdminApi } from '@supabase/auth-js'\n     *\n     * const admin = new GoTrueAdminApi({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },\n     * })\n     * ```\n     */ constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            updateClient: this._updateOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n        };\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDdUU7QUFDM0M7QUFDWjtBQUNKO0FBQzVCLE1BQU1TO0lBK0JqQjs7OztLQUlDLEdBQ0QsTUFBTUMsUUFBUUMsR0FBRyxFQUE4QjtZQUE1QkMsUUFBQUEsaUVBQVFMLHVEQUFlLENBQUMsRUFBRTtRQUN6QyxJQUFJQSx1REFBZUEsQ0FBQ00sT0FBTyxDQUFDRCxTQUFTLEdBQUc7WUFDcEMsTUFBTSxJQUFJRSxNQUFNLHFEQUFnRixPQUEzQlAsdURBQWVBLENBQUNRLElBQUksQ0FBQztRQUM5RjtRQUNBLElBQUk7WUFDQSxNQUFNWixvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxRQUFRLEdBQTRCSixPQUF6QixJQUFJLENBQUNLLEdBQUcsRUFBQyxrQkFBc0IsT0FBTkwsUUFBUztnQkFDcEVNLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlA7Z0JBQ0FRLGVBQWU7WUFDbkI7WUFDQSxPQUFPO2dCQUFFQyxNQUFNO2dCQUFNQyxPQUFPO1lBQUs7UUFDckMsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1DLGtCQUFrQkMsS0FBSyxFQUFnQjtZQUFkQyxVQUFBQSxpRUFBVSxDQUFDO1FBQ3RDLElBQUk7WUFDQSxPQUFPLE1BQU1yQixvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxRQUFRLEdBQVksT0FBVCxJQUFJLENBQUNDLEdBQUcsRUFBQyxZQUFVO2dCQUM1RFEsTUFBTTtvQkFBRUY7b0JBQU9ILE1BQU1JLFFBQVFKLElBQUk7Z0JBQUM7Z0JBQ2xDRixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJRLFlBQVlGLFFBQVFFLFVBQVU7Z0JBQzlCQyxPQUFPdkIscURBQWFBO1lBQ3hCO1FBQ0osRUFDQSxPQUFPaUIsT0FBTztZQUNWLElBQUliLHdEQUFXQSxDQUFDYSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO3dCQUFFUSxNQUFNO29CQUFLO29CQUFHUDtnQkFBTTtZQUN6QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1RLGFBQWFDLE1BQU0sRUFBRTtRQUN2QixJQUFJO1lBQ0EsTUFBTSxFQUFFTixPQUFPLEVBQUUsR0FBR00sUUFBUUMsT0FBTy9CLDZDQUFNQSxDQUFDOEIsUUFBUTtnQkFBQzthQUFVO1lBQzdELE1BQU1MLE9BQU9PLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0YsT0FBT1A7WUFDcEQsSUFBSSxjQUFjTyxNQUFNO2dCQUNwQixrREFBa0Q7Z0JBQ2xETixLQUFLUyxTQUFTLEdBQUdILFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLSSxRQUFRO2dCQUMxRSxPQUFPVixJQUFJLENBQUMsV0FBVztZQUMzQjtZQUNBLE9BQU8sTUFBTXRCLG9EQUFRQSxDQUFDLElBQUksQ0FBQ2EsS0FBSyxFQUFFLFFBQVEsR0FBWSxPQUFULElBQUksQ0FBQ0MsR0FBRyxFQUFDLHlCQUF1QjtnQkFDekVRLE1BQU1BO2dCQUNOUCxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJTLE9BQU8xQiw2REFBcUJBO2dCQUM1QnlCLFlBQVlGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRSxVQUFVO1lBQ3BGO1FBQ0osRUFDQSxPQUFPTCxPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQ0hELE1BQU07d0JBQ0ZnQixZQUFZO3dCQUNaUixNQUFNO29CQUNWO29CQUNBUDtnQkFDSjtZQUNKO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0EsaUJBQWlCO0lBQ2pCOzs7S0FHQyxHQUNELE1BQU1nQixXQUFXQyxVQUFVLEVBQUU7UUFDekIsSUFBSTtZQUNBLE9BQU8sTUFBTW5DLG9EQUFRQSxDQUFDLElBQUksQ0FBQ2EsS0FBSyxFQUFFLFFBQVEsR0FBWSxPQUFULElBQUksQ0FBQ0MsR0FBRyxFQUFDLGlCQUFlO2dCQUNqRVEsTUFBTWE7Z0JBQ05wQixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJTLE9BQU92QixxREFBYUE7WUFDeEI7UUFDSixFQUNBLE9BQU9pQixPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUVRLE1BQU07b0JBQUs7b0JBQUdQO2dCQUFNO1lBQ3pDO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNa0IsVUFBVVQsTUFBTSxFQUFFO1FBQ3BCLElBQUlVLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQzVCLElBQUk7WUFDQSxNQUFNQyxhQUFhO2dCQUFFQyxVQUFVO2dCQUFNQyxVQUFVO2dCQUFHQyxPQUFPO1lBQUU7WUFDM0QsTUFBTUMsV0FBVyxNQUFNaEQsb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsT0FBTyxHQUFZLE9BQVQsSUFBSSxDQUFDQyxHQUFHLEVBQUMsaUJBQWU7Z0JBQzFFQyxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJDLGVBQWU7Z0JBQ2ZpQyxPQUFPO29CQUNIQyxNQUFNLENBQUNaLEtBQUssQ0FBQ0QsS0FBS1YsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU91QixJQUFJLE1BQU0sUUFBUWIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYyxRQUFRLEVBQUMsTUFBTyxRQUFRYixPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDcEtjLFVBQVUsQ0FBQ1osS0FBSyxDQUFDRCxLQUFLWixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzBCLE9BQU8sTUFBTSxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdZLFFBQVEsRUFBQyxNQUFPLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dCQUMvSztnQkFDQWhCLE9BQU96Qiw4REFBc0JBO1lBQ2pDO1lBQ0EsSUFBSWlELFNBQVM5QixLQUFLLEVBQ2QsTUFBTThCLFNBQVM5QixLQUFLO1lBQ3hCLE1BQU1vQyxRQUFRLE1BQU1OLFNBQVNPLElBQUk7WUFDakMsTUFBTVIsUUFBUSxDQUFDTixLQUFLTyxTQUFTakMsT0FBTyxDQUFDeUMsR0FBRyxDQUFDLGdCQUFlLE1BQU8sUUFBUWYsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDNUYsTUFBTWdCLFFBQVEsQ0FBQ2QsS0FBSyxDQUFDRCxLQUFLTSxTQUFTakMsT0FBTyxDQUFDeUMsR0FBRyxDQUFDLE9BQU0sTUFBTyxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnQixLQUFLLENBQUMsSUFBRyxNQUFPLFFBQVFmLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDL0ksSUFBSWMsTUFBTUUsTUFBTSxHQUFHLEdBQUc7Z0JBQ2xCRixNQUFNRyxPQUFPLENBQUMsQ0FBQ0M7b0JBQ1gsTUFBTVgsT0FBT1ksU0FBU0QsS0FBS0gsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNBLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDSyxTQUFTLENBQUMsR0FBRztvQkFDcEUsTUFBTUMsTUFBTUMsS0FBS0MsS0FBSyxDQUFDTCxLQUFLSCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUN2RGQsVUFBVSxDQUFDLEdBQU8sT0FBSm9CLEtBQUksUUFBTSxHQUFHZDtnQkFDL0I7Z0JBQ0FOLFdBQVdHLEtBQUssR0FBR2UsU0FBU2Y7WUFDaEM7WUFDQSxPQUFPO2dCQUFFOUIsTUFBTVksT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHd0IsUUFBUVY7Z0JBQWExQixPQUFPO1lBQUs7UUFDcEYsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUVxQyxPQUFPLEVBQUU7b0JBQUM7b0JBQUdwQztnQkFBTTtZQUN4QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1pRCxZQUFZQyxHQUFHLEVBQUU7UUFDbkJqRSwwREFBWUEsQ0FBQ2lFO1FBQ2IsSUFBSTtZQUNBLE9BQU8sTUFBTXBFLG9EQUFRQSxDQUFDLElBQUksQ0FBQ2EsS0FBSyxFQUFFLE9BQU8sR0FBMkJ1RCxPQUF4QixJQUFJLENBQUN0RCxHQUFHLEVBQUMsaUJBQW1CLE9BQUpzRCxNQUFPO2dCQUN2RXJELFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlMsT0FBT3ZCLHFEQUFhQTtZQUN4QjtRQUNKLEVBQ0EsT0FBT2lCLE9BQU87WUFDVixJQUFJYix3REFBV0EsQ0FBQ2EsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVEsTUFBTTtvQkFBSztvQkFBR1A7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRCxNQUFNbUQsZUFBZUQsR0FBRyxFQUFFakMsVUFBVSxFQUFFO1FBQ2xDaEMsMERBQVlBLENBQUNpRTtRQUNiLElBQUk7WUFDQSxPQUFPLE1BQU1wRSxvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxPQUFPLEdBQTJCdUQsT0FBeEIsSUFBSSxDQUFDdEQsR0FBRyxFQUFDLGlCQUFtQixPQUFKc0QsTUFBTztnQkFDdkU5QyxNQUFNYTtnQkFDTnBCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlMsT0FBT3ZCLHFEQUFhQTtZQUN4QjtRQUNKLEVBQ0EsT0FBT2lCLE9BQU87WUFDVixJQUFJYix3REFBV0EsQ0FBQ2EsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVEsTUFBTTtvQkFBSztvQkFBR1A7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1vRCxXQUFXQyxFQUFFLEVBQTRCO1lBQTFCQyxtQkFBQUEsaUVBQW1CO1FBQ3BDckUsMERBQVlBLENBQUNvRTtRQUNiLElBQUk7WUFDQSxPQUFPLE1BQU12RSxvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxVQUFVLEdBQTJCMEQsT0FBeEIsSUFBSSxDQUFDekQsR0FBRyxFQUFDLGlCQUFrQixPQUFIeUQsS0FBTTtnQkFDekV4RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJPLE1BQU07b0JBQ0ZtRCxvQkFBb0JEO2dCQUN4QjtnQkFDQWhELE9BQU92QixxREFBYUE7WUFDeEI7UUFDSixFQUNBLE9BQU9pQixPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUVRLE1BQU07b0JBQUs7b0JBQUdQO2dCQUFNO1lBQ3pDO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0EsTUFBTXdELGFBQWEvQyxNQUFNLEVBQUU7UUFDdkJ4QiwwREFBWUEsQ0FBQ3dCLE9BQU9nRCxNQUFNO1FBQzFCLElBQUk7WUFDQSxNQUFNLEVBQUUxRCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1sQixvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxPQUFPLEdBQTJCYyxPQUF4QixJQUFJLENBQUNiLEdBQUcsRUFBQyxpQkFBNkIsT0FBZGEsT0FBT2dELE1BQU0sRUFBQyxhQUFXO2dCQUMxRzVELFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlMsT0FBTyxDQUFDb0Q7b0JBQ0osT0FBTzt3QkFBRTNELE1BQU07NEJBQUUyRDt3QkFBUTt3QkFBRzFELE9BQU87b0JBQUs7Z0JBQzVDO1lBQ0o7WUFDQSxPQUFPO2dCQUFFRDtnQkFBTUM7WUFBTTtRQUN6QixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJYix3REFBV0EsQ0FBQ2EsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNMkQsY0FBY2xELE1BQU0sRUFBRTtRQUN4QnhCLDBEQUFZQSxDQUFDd0IsT0FBT2dELE1BQU07UUFDMUJ4RSwwREFBWUEsQ0FBQ3dCLE9BQU80QyxFQUFFO1FBQ3RCLElBQUk7WUFDQSxNQUFNdEQsT0FBTyxNQUFNakIsb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsVUFBVSxHQUEyQmMsT0FBeEIsSUFBSSxDQUFDYixHQUFHLEVBQUMsaUJBQXdDYSxPQUF6QkEsT0FBT2dELE1BQU0sRUFBQyxhQUFxQixPQUFWaEQsT0FBTzRDLEVBQUUsR0FBSTtnQkFDL0d4RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN6QjtZQUNBLE9BQU87Z0JBQUVFO2dCQUFNQyxPQUFPO1lBQUs7UUFDL0IsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNNEQsa0JBQWtCbkQsTUFBTSxFQUFFO1FBQzVCLElBQUlVLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQzVCLElBQUk7WUFDQSxNQUFNQyxhQUFhO2dCQUFFQyxVQUFVO2dCQUFNQyxVQUFVO2dCQUFHQyxPQUFPO1lBQUU7WUFDM0QsTUFBTUMsV0FBVyxNQUFNaEQsb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsT0FBTyxHQUFZLE9BQVQsSUFBSSxDQUFDQyxHQUFHLEVBQUMseUJBQXVCO2dCQUNsRkMsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCQyxlQUFlO2dCQUNmaUMsT0FBTztvQkFDSEMsTUFBTSxDQUFDWixLQUFLLENBQUNELEtBQUtWLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPdUIsSUFBSSxNQUFNLFFBQVFiLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2MsUUFBUSxFQUFDLE1BQU8sUUFBUWIsT0FBTyxLQUFLLElBQUlBLEtBQUs7b0JBQ3BLYyxVQUFVLENBQUNaLEtBQUssQ0FBQ0QsS0FBS1osV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU8wQixPQUFPLE1BQU0sUUFBUWQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHWSxRQUFRLEVBQUMsTUFBTyxRQUFRWCxPQUFPLEtBQUssSUFBSUEsS0FBSztnQkFDL0s7Z0JBQ0FoQixPQUFPekIsOERBQXNCQTtZQUNqQztZQUNBLElBQUlpRCxTQUFTOUIsS0FBSyxFQUNkLE1BQU04QixTQUFTOUIsS0FBSztZQUN4QixNQUFNNkQsVUFBVSxNQUFNL0IsU0FBU08sSUFBSTtZQUNuQyxNQUFNUixRQUFRLENBQUNOLEtBQUtPLFNBQVNqQyxPQUFPLENBQUN5QyxHQUFHLENBQUMsZ0JBQWUsTUFBTyxRQUFRZixPQUFPLEtBQUssSUFBSUEsS0FBSztZQUM1RixNQUFNZ0IsUUFBUSxDQUFDZCxLQUFLLENBQUNELEtBQUtNLFNBQVNqQyxPQUFPLENBQUN5QyxHQUFHLENBQUMsT0FBTSxNQUFPLFFBQVFkLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dCLEtBQUssQ0FBQyxJQUFHLE1BQU8sUUFBUWYsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUMvSSxJQUFJYyxNQUFNRSxNQUFNLEdBQUcsR0FBRztnQkFDbEJGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDQztvQkFDWCxNQUFNWCxPQUFPWSxTQUFTRCxLQUFLSCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNLLFNBQVMsQ0FBQyxHQUFHO29CQUNwRSxNQUFNQyxNQUFNQyxLQUFLQyxLQUFLLENBQUNMLEtBQUtILEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3ZEZCxVQUFVLENBQUMsR0FBTyxPQUFKb0IsS0FBSSxRQUFNLEdBQUdkO2dCQUMvQjtnQkFDQU4sV0FBV0csS0FBSyxHQUFHZSxTQUFTZjtZQUNoQztZQUNBLE9BQU87Z0JBQUU5QixNQUFNWSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdpRCxVQUFVbkM7Z0JBQWExQixPQUFPO1lBQUs7UUFDdEYsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWIsd0RBQVdBLENBQUNhLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUU4RCxTQUFTLEVBQUU7b0JBQUM7b0JBQUc3RDtnQkFBTTtZQUMxQztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTThELG1CQUFtQnJELE1BQU0sRUFBRTtRQUM3QixJQUFJO1lBQ0EsT0FBTyxNQUFNM0Isb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsUUFBUSxHQUFZLE9BQVQsSUFBSSxDQUFDQyxHQUFHLEVBQUMseUJBQXVCO2dCQUN6RVEsTUFBTUs7Z0JBQ05aLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQlMsT0FBTyxDQUFDeUQ7b0JBQ0osT0FBTzt3QkFBRWhFLE1BQU1nRTt3QkFBUS9ELE9BQU87b0JBQUs7Z0JBQ3ZDO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJYix3REFBV0EsQ0FBQ2EsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1nRSxnQkFBZ0JDLFFBQVEsRUFBRTtRQUM1QixJQUFJO1lBQ0EsT0FBTyxNQUFNbkYsb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsT0FBTyxHQUFtQ3NFLE9BQWhDLElBQUksQ0FBQ3JFLEdBQUcsRUFBQyx5QkFBZ0MsT0FBVHFFLFdBQVk7Z0JBQ3BGcEUsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCUyxPQUFPLENBQUN5RDtvQkFDSixPQUFPO3dCQUFFaEUsTUFBTWdFO3dCQUFRL0QsT0FBTztvQkFBSztnQkFDdkM7WUFDSjtRQUNKLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUliLHdEQUFXQSxDQUFDYSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWtFLG1CQUFtQkQsUUFBUSxFQUFFeEQsTUFBTSxFQUFFO1FBQ3ZDLElBQUk7WUFDQSxPQUFPLE1BQU0zQixvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxPQUFPLEdBQW1Dc0UsT0FBaEMsSUFBSSxDQUFDckUsR0FBRyxFQUFDLHlCQUFnQyxPQUFUcUUsV0FBWTtnQkFDcEY3RCxNQUFNSztnQkFDTlosU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCUyxPQUFPLENBQUN5RDtvQkFDSixPQUFPO3dCQUFFaEUsTUFBTWdFO3dCQUFRL0QsT0FBTztvQkFBSztnQkFDdkM7WUFDSjtRQUNKLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUliLHdEQUFXQSxDQUFDYSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTW1FLG1CQUFtQkYsUUFBUSxFQUFFO1FBQy9CLElBQUk7WUFDQSxNQUFNbkYsb0RBQVFBLENBQUMsSUFBSSxDQUFDYSxLQUFLLEVBQUUsVUFBVSxHQUFtQ3NFLE9BQWhDLElBQUksQ0FBQ3JFLEdBQUcsRUFBQyx5QkFBZ0MsT0FBVHFFLFdBQVk7Z0JBQ2hGcEUsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCQyxlQUFlO1lBQ25CO1lBQ0EsT0FBTztnQkFBRUMsTUFBTTtnQkFBTUMsT0FBTztZQUFLO1FBQ3JDLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUliLHdEQUFXQSxDQUFDYSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTW9FLDZCQUE2QkgsUUFBUSxFQUFFO1FBQ3pDLElBQUk7WUFDQSxPQUFPLE1BQU1uRixvREFBUUEsQ0FBQyxJQUFJLENBQUNhLEtBQUssRUFBRSxRQUFRLEdBQW1Dc0UsT0FBaEMsSUFBSSxDQUFDckUsR0FBRyxFQUFDLHlCQUFnQyxPQUFUcUUsVUFBUyx1QkFBcUI7Z0JBQ3ZHcEUsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCUyxPQUFPLENBQUN5RDtvQkFDSixPQUFPO3dCQUFFaEUsTUFBTWdFO3dCQUFRL0QsT0FBTztvQkFBSztnQkFDdkM7WUFDSjtRQUNKLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUliLHdEQUFXQSxDQUFDYSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQTdhQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRHFFLFlBQVksRUFBRXpFLE1BQU0sRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFRixLQUFLLEVBQUcsQ0FBRTtRQUM1QyxJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNGLEtBQUssR0FBR1gsMERBQVlBLENBQUNXO1FBQzFCLElBQUksQ0FBQzJFLEdBQUcsR0FBRztZQUNQQyxhQUFhLElBQUksQ0FBQ2YsWUFBWSxDQUFDZ0IsSUFBSSxDQUFDLElBQUk7WUFDeENDLGNBQWMsSUFBSSxDQUFDZCxhQUFhLENBQUNhLElBQUksQ0FBQyxJQUFJO1FBQzlDO1FBQ0EsSUFBSSxDQUFDRSxLQUFLLEdBQUc7WUFDVEMsYUFBYSxJQUFJLENBQUNmLGlCQUFpQixDQUFDWSxJQUFJLENBQUMsSUFBSTtZQUM3Q0ksY0FBYyxJQUFJLENBQUNkLGtCQUFrQixDQUFDVSxJQUFJLENBQUMsSUFBSTtZQUMvQ0ssV0FBVyxJQUFJLENBQUNiLGVBQWUsQ0FBQ1EsSUFBSSxDQUFDLElBQUk7WUFDekNNLGNBQWMsSUFBSSxDQUFDWixrQkFBa0IsQ0FBQ00sSUFBSSxDQUFDLElBQUk7WUFDL0NPLGNBQWMsSUFBSSxDQUFDWixrQkFBa0IsQ0FBQ0ssSUFBSSxDQUFDLElBQUk7WUFDL0NRLHdCQUF3QixJQUFJLENBQUNaLDRCQUE0QixDQUFDSSxJQUFJLENBQUMsSUFBSTtRQUN2RTtJQUNKO0FBaVpKLEVBQ0EsMENBQTBDO0FBRHpDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcz80YTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgX2dlbmVyYXRlTGlua1Jlc3BvbnNlLCBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLCBfcmVxdWVzdCwgX3VzZXJSZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyByZXNvbHZlRmV0Y2gsIHZhbGlkYXRlVVVJRCB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgU0lHTl9PVVRfU0NPUEVTLCB9IGZyb20gJy4vbGliL3R5cGVzJztcbmltcG9ydCB7IGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUFkbWluQXBpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFkbWluIEFQSSBjbGllbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgdXNlcnMgYW5kIE9BdXRoIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgR29UcnVlQWRtaW5BcGkgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgKiAgIHVybDogJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9hdXRoL3YxJyxcbiAgICAgKiAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Byb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVl9YCB9LFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB1cmwgPSAnJywgaGVhZGVycyA9IHt9LCBmZXRjaCwgfSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9hdXRoID0ge1xuICAgICAgICAgICAgbGlzdENsaWVudHM6IHRoaXMuX2xpc3RPQXV0aENsaWVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudDogdGhpcy5fY3JlYXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldENsaWVudDogdGhpcy5fZ2V0T0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVwZGF0ZUNsaWVudDogdGhpcy5fdXBkYXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZUNsaWVudDogdGhpcy5fZGVsZXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlZ2VuZXJhdGVDbGllbnRTZWNyZXQ6IHRoaXMuX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChqd3QsIHNjb3BlID0gU0lHTl9PVVRfU0NPUEVTWzBdKSB7XG4gICAgICAgIGlmIChTSUdOX09VVF9TQ09QRVMuaW5kZXhPZihzY29wZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBQYXJhbWV0ZXIgc2NvcGUgbXVzdCBiZSBvbmUgb2YgJHtTSUdOX09VVF9TQ09QRVMuam9pbignLCAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vbG9nb3V0P3Njb3BlPSR7c2NvcGV9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3QsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW52aXRlIGxpbmsgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIGluY2x1ZGVkIHdoZW4gaW52aXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ludml0ZWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiB7IGVtYWlsLCBkYXRhOiBvcHRpb25zLmRhdGEgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBwYXJhbXMsIHJlc3QgPSBfX3Jlc3QocGFyYW1zLCBbXCJvcHRpb25zXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0Lm5ld0VtYWlsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlciBBZG1pbiBBUElcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVVc2VyKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RVc2VycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiAoX2QgPSAoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGVyUGFnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyczogW10gfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJCeUlkKHVpZCkge1xuICAgICAgICB2YWxpZGF0ZVVVSUQodWlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS4gQ2hhbmdlcyBhcmUgYXBwbGllZCBkaXJlY3RseSB3aXRob3V0IGNvbmZpcm1hdGlvbiBmbG93cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRCh1aWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHNob3VsZFNvZnREZWxldGUgSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHNvZnQtZGVsZXRlZCBmcm9tIHRoZSBhdXRoIHNjaGVtYS4gU29mdCBkZWxldGlvbiBhbGxvd3MgdXNlciBpZGVudGlmaWNhdGlvbiBmcm9tIHRoZSBoYXNoZWQgdXNlciBJRCBidXQgaXMgbm90IHJldmVyc2libGUuXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVVzZXIoaWQsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZVVVSUQoaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkX3NvZnRfZGVsZXRlOiBzaG91bGRTb2Z0RGVsZXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9saXN0RmFjdG9ycyhwYXJhbXMpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHBhcmFtcy51c2VySWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlRmFjdG9yKHBhcmFtcykge1xuICAgICAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZCk7XG4gICAgICAgIHZhbGlkYXRlVVVJRChwYXJhbXMuaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBPQXV0aCBjbGllbnRzIHdpdGggb3B0aW9uYWwgcGFnaW5hdGlvbi5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdE9BdXRoQ2xpZW50cyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IChfZCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wZXJQYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbGllbnRzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjbGllbnRzOiBbXSB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2NyZWF0ZU9BdXRoQ2xpZW50KHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGRldGFpbHMgb2YgYSBzcGVjaWZpYyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2dldE9BdXRoQ2xpZW50KGNsaWVudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfdXBkYXRlT0F1dGhDbGllbnQoY2xpZW50SWQsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZWxldGVPQXV0aENsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlcyB0aGUgc2VjcmV0IGZvciBhbiBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH0vcmVnZW5lcmF0ZV9zZWNyZXRgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsIl9nZW5lcmF0ZUxpbmtSZXNwb25zZSIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJfcmVxdWVzdCIsIl91c2VyUmVzcG9uc2UiLCJyZXNvbHZlRmV0Y2giLCJ2YWxpZGF0ZVVVSUQiLCJTSUdOX09VVF9TQ09QRVMiLCJpc0F1dGhFcnJvciIsIkdvVHJ1ZUFkbWluQXBpIiwic2lnbk91dCIsImp3dCIsInNjb3BlIiwiaW5kZXhPZiIsIkVycm9yIiwiam9pbiIsImZldGNoIiwidXJsIiwiaGVhZGVycyIsIm5vUmVzb2x2ZUpzb24iLCJkYXRhIiwiZXJyb3IiLCJpbnZpdGVVc2VyQnlFbWFpbCIsImVtYWlsIiwib3B0aW9ucyIsImJvZHkiLCJyZWRpcmVjdFRvIiwieGZvcm0iLCJ1c2VyIiwiZ2VuZXJhdGVMaW5rIiwicGFyYW1zIiwicmVzdCIsIk9iamVjdCIsImFzc2lnbiIsIm5ld19lbWFpbCIsIm5ld0VtYWlsIiwicHJvcGVydGllcyIsImNyZWF0ZVVzZXIiLCJhdHRyaWJ1dGVzIiwibGlzdFVzZXJzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJwYWdpbmF0aW9uIiwibmV4dFBhZ2UiLCJsYXN0UGFnZSIsInRvdGFsIiwicmVzcG9uc2UiLCJxdWVyeSIsInBhZ2UiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwicGVyUGFnZSIsInVzZXJzIiwianNvbiIsImdldCIsImxpbmtzIiwic3BsaXQiLCJsZW5ndGgiLCJmb3JFYWNoIiwibGluayIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwicmVsIiwiSlNPTiIsInBhcnNlIiwiZ2V0VXNlckJ5SWQiLCJ1aWQiLCJ1cGRhdGVVc2VyQnlJZCIsImRlbGV0ZVVzZXIiLCJpZCIsInNob3VsZFNvZnREZWxldGUiLCJzaG91bGRfc29mdF9kZWxldGUiLCJfbGlzdEZhY3RvcnMiLCJ1c2VySWQiLCJmYWN0b3JzIiwiX2RlbGV0ZUZhY3RvciIsIl9saXN0T0F1dGhDbGllbnRzIiwiY2xpZW50cyIsIl9jcmVhdGVPQXV0aENsaWVudCIsImNsaWVudCIsIl9nZXRPQXV0aENsaWVudCIsImNsaWVudElkIiwiX3VwZGF0ZU9BdXRoQ2xpZW50IiwiX2RlbGV0ZU9BdXRoQ2xpZW50IiwiX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldCIsImNvbnN0cnVjdG9yIiwibWZhIiwibGlzdEZhY3RvcnMiLCJiaW5kIiwiZGVsZXRlRmFjdG9yIiwib2F1dGgiLCJsaXN0Q2xpZW50cyIsImNyZWF0ZUNsaWVudCIsImdldENsaWVudCIsInVwZGF0ZUNsaWVudCIsImRlbGV0ZUNsaWVudCIsInJlZ2VuZXJhdGVDbGllbnRTZWNyZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/polyfills */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/web3/ethereum */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\");\n/* harmony import */ var _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/webauthn */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_7__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n    throwOnError: false,\n    lockAcquireTimeout: 10000\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */ const GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */ get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {\n            keys: []\n        };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            jwks: value\n        });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            cachedAt: value\n        });\n    }\n    /**\n     * Returns whether error throwing mode is enabled for this client.\n     */ isThrowOnErrorEnabled() {\n        return this.throwOnError;\n    }\n    /**\n     * Centralizes return handling with optional error throwing. When `throwOnError` is enabled\n     * and the provided result contains a non-nullish error, the error is thrown instead of\n     * being returned. This ensures consistent behavior across all public API methods.\n     */ _returnResult(result) {\n        if (this.throwOnError && result && result.error) {\n            throw result.error;\n        }\n        return result;\n    }\n    _logPrefix() {\n        return \"GoTrueClient@\" + \"\".concat(this.storageKey, \":\").concat(this.instanceID, \" (\").concat(_lib_version__WEBPACK_IMPORTED_MODULE_8__.version, \") \").concat(new Date().toISOString());\n    }\n    _debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.logDebugMessages) {\n            this.logger(this._logPrefix(), ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            let params = {};\n            let callbackUrlType = \"none\";\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n                if (this._isImplicitGrantCallback(params)) {\n                    callbackUrlType = \"implicit\";\n                } else if (await this._isPKCECallback(params)) {\n                    callbackUrlType = \"pkce\";\n                }\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // Don't remove existing session on URL login failure.\n                    // A failed attempt (e.g. reused magic link) shouldn't invalidate a valid session.\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    error\n                });\n            }\n            return this._returnResult({\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            });\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/signup\"), {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/signup\"), {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/signup\"), {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=password\"), {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=password\"), {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */ async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch(chain){\n            case \"ethereum\":\n                return await this.signInWithEthereum(credentials);\n            case \"solana\":\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error('@supabase/auth-js: Unsupported chain \"'.concat(chain, '\"'));\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"ethereum\" in windowAny && typeof windowAny.ethereum === \"object\" && \"request\" in windowAny.ethereum && typeof windowAny.ethereum.request === \"function\") {\n                    resolvedWallet = windowAny.ethereum;\n                } else {\n                    throw new Error(\"@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.\");\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet.request({\n                method: \"eth_requestAccounts\"\n            }).then((accs)=>accs).catch(()=>{\n                throw new Error(\"@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid\");\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(\"@supabase/auth-js: No accounts available. Please ensure the wallet is connected.\");\n            }\n            const address = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: \"eth_chainId\"\n                });\n                chainId = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: \"1\",\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources\n            };\n            message = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = await resolvedWallet.request({\n                method: \"personal_sign\",\n                params: [\n                    (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.toHex)(message),\n                    address\n                ]\n            });\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=web3\"), {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"ethereum\",\n                    message,\n                    signature\n                }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"solana\" in windowAny && typeof windowAny.solana === \"object\" && (\"signIn\" in windowAny.solana && typeof windowAny.solana.signIn === \"function\" || \"signMessage\" in windowAny.solana && typeof windowAny.solana.signMessage === \"function\")) {\n                    resolvedWallet = windowAny.solana;\n                } else {\n                    throw new Error(\"@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.\");\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if (\"signIn\" in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({\n                    issuedAt: new Date().toISOString()\n                }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {\n                    // non-overridable properties\n                    version: \"1\",\n                    domain: url.host,\n                    uri: url.href\n                }), statement ? {\n                    statement\n                } : null));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === \"object\") {\n                    outputToProcess = output[0];\n                } else if (output && typeof output === \"object\" && \"signedMessage\" in output && \"signature\" in output) {\n                    outputToProcess = output;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() returned unrecognized value\");\n                }\n                if (\"signedMessage\" in outputToProcess && \"signature\" in outputToProcess && (typeof outputToProcess.signedMessage === \"string\" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {\n                    message = typeof outputToProcess.signedMessage === \"string\" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields\");\n                }\n            } else {\n                if (!(\"signMessage\" in resolvedWallet) || typeof resolvedWallet.signMessage !== \"function\" || !(\"publicKey\" in resolvedWallet) || typeof resolvedWallet !== \"object\" || !resolvedWallet.publicKey || !(\"toBase58\" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== \"function\") {\n                    throw new Error(\"@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API\");\n                }\n                message = [\n                    \"\".concat(url.host, \" wants you to sign in with your Solana account:\"),\n                    resolvedWallet.publicKey.toBase58(),\n                    ...statement ? [\n                        \"\",\n                        statement,\n                        \"\"\n                    ] : [\n                        \"\"\n                    ],\n                    \"Version: 1\",\n                    \"URI: \".concat(url.href),\n                    \"Issued At: \".concat((_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()),\n                    ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [\n                        \"Not Before: \".concat(options.signInWithSolana.notBefore)\n                    ] : [],\n                    ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [\n                        \"Expiration Time: \".concat(options.signInWithSolana.expirationTime)\n                    ] : [],\n                    ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [\n                        \"Chain ID: \".concat(options.signInWithSolana.chainId)\n                    ] : [],\n                    ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [\n                        \"Nonce: \".concat(options.signInWithSolana.nonce)\n                    ] : [],\n                    ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [\n                        \"Request ID: \".concat(options.signInWithSolana.requestId)\n                    ] : [],\n                    ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [\n                        \"Resources\",\n                        ...options.signInWithSolana.resources.map((resource)=>\"- \".concat(resource))\n                    ] : []\n                ].join(\"\\n\");\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), \"utf8\");\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error(\"@supabase/auth-js: Wallet signMessage() API returned an recognized value\");\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=web3\"), {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"solana\",\n                    message,\n                    signature: (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.bytesToBase64URL)(signature)\n                }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            if (!codeVerifier && this.flowType === \"pkce\") {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError();\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=pkce\"), {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data,\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/otp\"), {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/otp\"), {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/verify\"), {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                const tokenVerificationError = new Error(\"An error occurred on token verification.\");\n                throw tokenVerificationError;\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c, _d, _e;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            const result = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/sso\"), {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n            // Automatically redirect in browser unless skipBrowserRedirect is true\n            if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {\n                window.location.assign(result.data.url);\n            }\n            return this._returnResult(result);\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/reauthenticate\"), {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = \"\".concat(this.url, \"/resend\");\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(\"lock:\".concat(this.storageKey), acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", \"session has\".concat(hasExpired ? \"\" : \" not\", \" expired\"), \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n                // Wrap the user object with a warning proxy on the server\n                // This warns when properties of the user are accessed, not when session.user itself is accessed\n                if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {\n                    const suppressWarningRef = {\n                        value: this.suppressGetSessionWarning\n                    };\n                    currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);\n                    // Update the client-level suppression flag when the proxy suppresses the warning\n                    if (suppressWarningRef.value) {\n                        this.suppressGetSessionWarning = true;\n                    }\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        session: null\n                    },\n                    error\n                });\n            }\n            return this._returnResult({\n                data: {\n                    session\n                },\n                error: null\n            });\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._getUser();\n        });\n        if (result.data.user) {\n            this.suppressGetSessionWarning = true;\n        }\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/user\"), {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/user\"), {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n                }\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", \"\".concat(this.url, \"/user\"), {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) {\n                    throw userError;\n                }\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return this._returnResult({\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    });\n                }\n                return this._returnResult({\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL expires in \".concat(actuallyExpiresIn, \"s, should have been closer to \").concat(expiresIn, \"s\"));\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return this._returnResult({\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     *\n     * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine\n     * if the URL should be processed as a Supabase auth callback. This allows users to exclude\n     * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.\n     */ _isImplicitGrantCallback(params) {\n        if (typeof this.detectSessionInUrl === \"function\") {\n            return this.detectSessionInUrl(new URL(window.location.href), params);\n        }\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            scope: \"global\"\n        };\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut() {\n        let { scope } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            scope: \"global\"\n        };\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError && !(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(sessionError)) {\n                return this._returnResult({\n                    error: sessionError\n                });\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403) || (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error))) {\n                        return this._returnResult({\n                            error\n                        });\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            }\n            return this._returnResult({\n                error: null\n            });\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.generateCallbackId)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/recover\"), {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return this._returnResult({\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if (\"token\" in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(\"\".concat(this.url, \"/user/identities/authorize\"), credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return this._returnResult({\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            try {\n                const { error: sessionError, data: { session } } = result;\n                if (sessionError) throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n                const { data, error } = res;\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                } else if (!data || !data.session || !data.user) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                    });\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers(\"USER_UPDATED\", data.session);\n                }\n                return this._returnResult({\n                    data,\n                    error\n                });\n            } catch (error) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/user/identities/\").concat(identity.identity_id), {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = \"#_refreshAccessToken(\".concat(refreshToken.substring(0, 5), \"...)\");\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(\"\".concat(this.url, \"/authorize\"), provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            if (currentSession && this.userStorage) {\n                let maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = {\n                        user: currentSession.user\n                    };\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n            } else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey + \"-user\");\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, \"session has\".concat(expiresWithMargin ? \"\" : \" not\", \" expired with margin of \").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS, \"s\"));\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n                    } else {\n                        this._debug(debugName, \"could not get user data, skipping SIGNED_IN notification\");\n                    }\n                } catch (getUserError) {\n                    console.error(\"Error getting user data:\", getUserError);\n                    this._debug(debugName, \"error getting user data, skipping SIGNED_IN notification\", getUserError);\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = \"#_callRefreshToken(\".concat(refreshToken.substring(0, 5), \"...)\");\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                data: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    data: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session) {\n        let broadcast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        const debugName = \"#_notifyAllSubscribers(\".concat(event, \")\");\n        this._debug(debugName, \"begin\", session, \"broadcast = \".concat(broadcast));\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", {\n                    user: sessionToProcess.user\n                });\n            } else if (userIsProxy) {\n            // If it's the proxy, it means user was not found in userStorage.\n            // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n            // or simply not save the proxy. For now, we don't save the proxy here.\n            // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(mainSessionData);\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        } else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        this.suppressGetSessionWarning = false;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-code-verifier\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n        if (this.userStorage) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.userStorage, this.storageKey + \"-user\");\n        }\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        const timeout = setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n        this.autoRefreshTickTimeout = timeout;\n        if (timeout && typeof timeout === \"object\" && typeof timeout.unref === \"function\") {\n            timeout.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(timeout);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n        const timeout = this.autoRefreshTickTimeout;\n        this.autoRefreshTickTimeout = null;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", \"access token expires in \".concat(expiresInTicks, \" ticks, a tick lasts \").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS, \"ms, refresh threshold is \").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD, \" ticks\"));\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_6__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>{\n                try {\n                    await this._onVisibilityChanged(false);\n                } catch (error) {\n                    this._debug(\"#visibilityChangedCallback\", \"error\", error);\n                }\n            };\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = \"#_onVisibilityChanged(\".concat(calledFromInitialize, \")\");\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            \"provider=\".concat(encodeURIComponent(provider))\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: \"\".concat(encodeURIComponent(codeChallenge)),\n                code_challenge_method: \"\".concat(encodeURIComponent(codeChallengeMethod))\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(\"skip_http_redirect=\".concat(options.skipBrowserRedirect));\n        }\n        return \"\".concat(url, \"?\").concat(urlParams.join(\"&\"));\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : params.factorType === \"totp\" ? {\n                    issuer: params.issuer\n                } : {});\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/factors\"), {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                if (params.factorType === \"totp\" && data.type === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n                }\n                return this._returnResult({\n                    data,\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const body = Object.assign({\n                        challenge_id: params.challengeId\n                    }, \"webauthn\" in params ? {\n                        webauthn: Object.assign(Object.assign({}, params.webauthn), {\n                            credential_response: params.webauthn.type === \"create\" ? (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialRequestResponse)(params.webauthn.credential_response)\n                        })\n                    } : {\n                        code: params.code\n                    });\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return this._returnResult({\n                            data: null,\n                            error\n                        });\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return this._returnResult({\n                        data,\n                        error\n                    });\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== \"webauthn\") {\n                        return {\n                            data,\n                            error: null\n                        };\n                    }\n                    switch(data.webauthn.type){\n                        case \"create\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                        case \"request\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                    }\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return this._returnResult({\n                data: null,\n                error: challengeError\n            });\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: []\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []){\n            data.all.push(factor);\n            if (factor.status === \"verified\") {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel(jwt) {\n        var _a, _b, _c, _d;\n        if (jwt) {\n            try {\n                const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(jwt);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const { data: { user }, error: userError } = await this.getUser(jwt);\n                if (userError) {\n                    return this._returnResult({\n                        data: null,\n                        error: userError\n                    });\n                }\n                const verifiedFactors = (_b = (_a = user === null || user === void 0 ? void 0 : user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = \"aal2\";\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return {\n                    data: {\n                        currentLevel,\n                        nextLevel,\n                        currentAuthenticationMethods\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        }\n        const { data: { session }, error: sessionError } = await this.getSession();\n        if (sessionError) {\n            return this._returnResult({\n                data: null,\n                error: sessionError\n            });\n        }\n        if (!session) {\n            return {\n                data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                },\n                error: null\n            };\n        }\n        const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n        let currentLevel = null;\n        if (payload.aal) {\n            currentLevel = payload.aal;\n        }\n        let nextLevel = currentLevel;\n        const verifiedFactors = (_d = (_c = session.user.factors) === null || _c === void 0 ? void 0 : _c.filter((factor)=>factor.status === \"verified\")) !== null && _d !== void 0 ? _d : [];\n        if (verifiedFactors.length > 0) {\n            nextLevel = \"aal2\";\n        }\n        const currentAuthenticationMethods = payload.amr || [];\n        return {\n            data: {\n                currentLevel,\n                nextLevel,\n                currentAuthenticationMethods\n            },\n            error: null\n        };\n    }\n    /**\n     * Retrieves details about an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * Returns authorization details including client info, scopes, and user information.\n     * If the response includes only a redirect_url field, it means consent was already given - the caller\n     * should handle the redirect manually if needed.\n     */ async _getAuthorizationDetails(authorizationId) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/oauth/authorizations/\").concat(authorizationId), {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Approves an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _approveAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/oauth/authorizations/\").concat(authorizationId, \"/consent\"), {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"approve\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Denies an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _denyAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", \"\".concat(this.url, \"/oauth/authorizations/\").concat(authorizationId, \"/consent\"), {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"deny\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth grants that the authenticated user has authorized.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _listOAuthGrants() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/user/oauth/grants\"), {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Revokes a user's OAuth grant for a specific client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _revokeOAuthGrant(options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", \"\".concat(this.url, \"/user/oauth/grants\"), {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    query: {\n                        client_id: options.clientId\n                    },\n                    noResolveJson: true\n                });\n                return {\n                    data: {},\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchJwk(kid) {\n        let jwks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            keys: []\n        };\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", \"\".concat(this.url, \"/.well-known/jwks.json\"), {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */ async getClaims(jwt) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg || header.alg.startsWith(\"HS\") || !header.kid || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {\n                keys: options.keys\n            } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(\"\".concat(rawHeader, \".\").concat(rawPayload)));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Create a new client for use in the browser.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueClient } from '@supabase/auth-js'\n     *\n     * const auth = new GoTrueClient({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { apikey: 'public-anon-key' },\n     *   storageKey: 'supabase-auth',\n     * })\n     * ```\n     */ constructor(options){\n        var _a, _b, _c;\n        /**\n         * @experimental\n         */ this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.autoRefreshTickTimeout = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.storageKey = settings.storageKey;\n        this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;\n        GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            const message = \"\".concat(this._logPrefix(), \" Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.\");\n            console.warn(message);\n            if (this.logDebugMessages) {\n                console.trace(message);\n            }\n        }\n        this.persistSession = settings.persistSession;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        this.throwOnError = settings.throwOnError;\n        this.lockAcquireTimeout = settings.lockAcquireTimeout;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if (this.persistSession && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = {\n                keys: []\n            };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.WebAuthnApi(this)\n        };\n        this.oauth = {\n            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),\n            approveAuthorization: this._approveAuthorization.bind(this),\n            denyAuthorization: this._denyAuthorization.bind(this),\n            listGrants: this._listOAuthGrants.bind(this),\n            revokeGrant: this._revokeOAuthGrant.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                try {\n                    await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n                } catch (error) {\n                    this._debug(\"#broadcastChannel\", \"error\", error);\n                }\n            });\n        }\n        this.initialize().catch((error)=>{\n            this._debug(\"#initialize()\", \"error\", error);\n        });\n    }\n}\nGoTrueClient.nextInstanceID = {};\n/* harmony default export */ __webpack_exports__[\"default\"] = (GoTrueClient); //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNzSDtBQUM4TTtBQUNqUTtBQUNnTjtBQUNqUTtBQUNLO0FBQ2hCO0FBQ2I7QUFDK0I7QUFDYztBQUM2RztBQUNsTStDLGtFQUFrQkEsSUFBSSw4QkFBOEI7QUFDcEQsTUFBTWEsa0JBQWtCO0lBQ3BCQyxLQUFLeEQsc0RBQVVBO0lBQ2Z5RCxZQUFZdkQsdURBQVdBO0lBQ3ZCd0Qsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsU0FBUy9ELDJEQUFlQTtJQUN4QmdFLFVBQVU7SUFDVkMsT0FBTztJQUNQQyw4QkFBOEI7SUFDOUJDLGNBQWM7SUFDZEMsb0JBQW9CO0FBQ3hCO0FBQ0EsZUFBZUMsU0FBU0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDNUMsT0FBTyxNQUFNQTtBQUNqQjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQyxjQUFjLENBQUM7QUFDckIsTUFBTUM7SUFDRjs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxJQUFJQyxJQUFJQztRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDRCxLQUFLSCxXQUFXLENBQUMsSUFBSSxDQUFDZCxVQUFVLENBQUMsTUFBTSxRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRCxJQUFJLE1BQU0sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFBRUMsTUFBTSxFQUFFO1FBQUM7SUFDL0k7SUFDQSxJQUFJSCxLQUFLSSxLQUFLLEVBQUU7UUFDWk4sV0FBVyxDQUFDLElBQUksQ0FBQ2QsVUFBVSxDQUFDLEdBQUdxQixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdSLFdBQVcsQ0FBQyxJQUFJLENBQUNkLFVBQVUsQ0FBQyxHQUFH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LE9BQU96QixPQUFPO29CQUNWLElBQUksQ0FBQ0ssTUFBTSxDQUFDLHFCQUFxQixTQUFTTDtnQkFDOUM7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDUyxVQUFVLEdBQUdzRixLQUFLLENBQUMsQ0FBQy9GO1lBQ3JCLElBQUksQ0FBQ0ssTUFBTSxDQUFDLGlCQUFpQixTQUFTTDtRQUMxQztJQUNKO0FBd2xGSjtBQUNBZixhQUFhbVosY0FBYyxHQUFHLENBQUM7QUFDL0IsK0RBQWVuWixZQUFZQSxFQUFDLENBQzVCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzP2Y2NzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IHsgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMsIEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCwgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOX01TLCBHT1RSVUVfVVJMLCBKV0tTX1RUTCwgU1RPUkFHRV9LRVksIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLCBBdXRoSW52YWxpZEp3dEVycm9yLCBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciwgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IsIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciwgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEFwaUVycm9yLCBpc0F1dGhFcnJvciwgaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmltcG9ydCB7IF9yZXF1ZXN0LCBfc2Vzc2lvblJlc3BvbnNlLCBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsIF9zc29SZXNwb25zZSwgX3VzZXJSZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyBkZWNvZGVKV1QsIGRlZXBDbG9uZSwgRGVmZXJyZWQsIGdlbmVyYXRlQ2FsbGJhY2tJZCwgZ2V0QWxnb3JpdGhtLCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kLCBnZXRJdGVtQXN5bmMsIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSwgaXNCcm93c2VyLCBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLCByZW1vdmVJdGVtQXN5bmMsIHJlc29sdmVGZXRjaCwgcmV0cnlhYmxlLCBzZXRJdGVtQXN5bmMsIHNsZWVwLCBzdXBwb3J0c0xvY2FsU3RvcmFnZSwgdXNlck5vdEF2YWlsYWJsZVByb3h5LCB2YWxpZGF0ZUV4cCwgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yLCBuYXZpZ2F0b3JMb2NrIH0gZnJvbSAnLi9saWIvbG9ja3MnO1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJztcbmltcG9ydCB7IGJ5dGVzVG9CYXNlNjRVUkwsIHN0cmluZ1RvVWludDhBcnJheSB9IGZyb20gJy4vbGliL2Jhc2U2NHVybCc7XG5pbXBvcnQgeyBjcmVhdGVTaXdlTWVzc2FnZSwgZnJvbUhleCwgZ2V0QWRkcmVzcywgdG9IZXgsIH0gZnJvbSAnLi9saWIvd2ViMy9ldGhlcmV1bSc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMsIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zLCBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSwgc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSwgV2ViQXV0aG5BcGksIH0gZnJvbSAnLi9saWIvd2ViYXV0aG4nO1xucG9seWZpbGxHbG9iYWxUaGlzKCk7IC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdXJsOiBHT1RSVUVfVVJMLFxuICAgIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgICBmbG93VHlwZTogJ2ltcGxpY2l0JyxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG4gICAgdGhyb3dPbkVycm9yOiBmYWxzZSxcbiAgICBsb2NrQWNxdWlyZVRpbWVvdXQ6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXG59O1xuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3AobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgcmV0dXJuIGF3YWl0IGZuKCk7XG59XG4vKipcbiAqIENhY2hlcyBKV0tTIHZhbHVlcyBmb3IgYWxsIGNsaWVudHMgY3JlYXRlZCBpbiB0aGUgc2FtZSBlbnZpcm9ubWVudC4gVGhpcyBpc1xuICogZXNwZWNpYWxseSB1c2VmdWwgZm9yIHNoYXJlZC1tZW1vcnkgZXhlY3V0aW9uIGVudmlyb25tZW50cyBzdWNoIGFzIFZlcmNlbCdzXG4gKiBGbHVpZCBDb21wdXRlLCBBV1MgTGFtYmRhIG9yIFN1cGFiYXNlJ3MgRWRnZSBGdW5jdGlvbnMuIFJlZ2FyZGxlc3Mgb2YgaG93XG4gKiBtYW55IGNsaWVudHMgYXJlIGNyZWF0ZWQsIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgc3RvcmFnZSBrZXkgdGhleSB3aWxsIHVzZVxuICogdGhlIHNhbWUgSldLUyBjYWNoZSwgc2lnbmlmaWNhbnRseSBzcGVlZGluZyB1cCBnZXRDbGFpbXMoKSB3aXRoIGFzeW1tZXRyaWNcbiAqIEpXVHMuXG4gKi9cbmNvbnN0IEdMT0JBTF9KV0tTID0ge307XG5jbGFzcyBHb1RydWVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBKV0tTIHVzZWQgZm9yIHZlcmlmeWluZyBhc3ltbWV0cmljIEpXVHNcbiAgICAgKi9cbiAgICBnZXQgandrcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qd2tzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7IGtleXM6IFtdIH07XG4gICAgfVxuICAgIHNldCBqd2tzKHZhbHVlKSB7XG4gICAgICAgIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pLCB7IGp3a3M6IHZhbHVlIH0pO1xuICAgIH1cbiAgICBnZXQgandrc19jYWNoZWRfYXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FjaGVkQXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICBzZXQgandrc19jYWNoZWRfYXQodmFsdWUpIHtcbiAgICAgICAgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSksIHsgY2FjaGVkQXQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgR29UcnVlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBhdXRoID0gbmV3IEdvVHJ1ZUNsaWVudCh7XG4gICAgICogICB1cmw6ICdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vYXV0aC92MScsXG4gICAgICogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICAgKiAgIHN0b3JhZ2VLZXk6ICdzdXBhYmFzZS1hdXRoJyxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICAgICAqIE9uY2UgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMga25vd24gYW5kIGl0J3Mgc2FmZSB0byBjYWxsIGFueSBmdXJ0aGVyIGNsaWVudCBtZXRob2RzLlxuICAgICAgICAgKiBLZWVwIGV4dHJhIGNhcmUgdG8gbmV2ZXIgcmVqZWN0IG9yIHRocm93IHVuY2F1Z2h0IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsaXplUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gYnJvYWRjYXN0IHN0YXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgdGFicyBsaXN0ZW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNvbnNvbGUubG9nO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VJRCA9IChfYSA9IEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRFt0aGlzLnN0b3JhZ2VLZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSURbdGhpcy5zdG9yYWdlS2V5XSA9IHRoaXMuaW5zdGFuY2VJRCArIDE7XG4gICAgICAgIHRoaXMubG9nRGVidWdNZXNzYWdlcyA9ICEhc2V0dGluZ3MuZGVidWc7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gc2V0dGluZ3MuZGVidWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHt0aGlzLl9sb2dQcmVmaXgoKX0gTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuYDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ0RlYnVnTWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvbjtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICAgICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaCk7XG4gICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3A7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsO1xuICAgICAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICAgIHRoaXMudGhyb3dPbkVycm9yID0gc2V0dGluZ3MudGhyb3dPbkVycm9yO1xuICAgICAgICB0aGlzLmxvY2tBY3F1aXJlVGltZW91dCA9IHNldHRpbmdzLmxvY2tBY3F1aXJlVGltZW91dDtcbiAgICAgICAgaWYgKHNldHRpbmdzLmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbiAmJiBpc0Jyb3dzZXIoKSAmJiAoKF9iID0gZ2xvYmFsVGhpcyA9PT0gbnVsbCB8fCBnbG9iYWxUaGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxvY2tzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbmF2aWdhdG9yTG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IGxvY2tOb09wO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5qd2tzKSB7XG4gICAgICAgICAgICB0aGlzLmp3a3MgPSB7IGtleXM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLmp3a3NfY2FjaGVkX2F0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZW5yb2xsOiB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVuZW5yb2xsOiB0aGlzLl91bmVucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlOiB0aGlzLl9jaGFsbGVuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlQW5kVmVyaWZ5OiB0aGlzLl9jaGFsbGVuZ2VBbmRWZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbDogdGhpcy5fZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3ZWJhdXRobjogbmV3IFdlYkF1dGhuQXBpKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9hdXRoID0ge1xuICAgICAgICAgICAgZ2V0QXV0aG9yaXphdGlvbkRldGFpbHM6IHRoaXMuX2dldEF1dGhvcml6YXRpb25EZXRhaWxzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhcHByb3ZlQXV0aG9yaXphdGlvbjogdGhpcy5fYXBwcm92ZUF1dGhvcml6YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbnlBdXRob3JpemF0aW9uOiB0aGlzLl9kZW55QXV0aG9yaXphdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbGlzdEdyYW50czogdGhpcy5fbGlzdE9BdXRoR3JhbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZXZva2VHcmFudDogdGhpcy5fcmV2b2tlT0F1dGhHcmFudC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcih0aGlzLm1lbW9yeVN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlclN0b3JhZ2UgPSBzZXR0aW5ncy51c2VyU3RvcmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcih0aGlzLm1lbW9yeVN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwgJiYgdGhpcy5wZXJzaXN0U2Vzc2lvbiAmJiB0aGlzLnN0b3JhZ2VLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IEJyb2FkY2FzdENoYW5uZWwsIG11bHRpLXRhYiBzdGF0ZSBjaGFuZ2VzIHdpbGwgbm90IGJlIGF2YWlsYWJsZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9jID0gdGhpcy5icm9hZGNhc3RDaGFubmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdyZWNlaXZlZCBicm9hZGNhc3Qgbm90aWZpY2F0aW9uIGZyb20gb3RoZXIgdGFiIG9yIGNsaWVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudC5kYXRhLmV2ZW50LCBldmVudC5kYXRhLnNlc3Npb24sIGZhbHNlKTsgLy8gYnJvYWRjYXN0ID0gZmFsc2Ugc28gd2UgZG9uJ3QgZ2V0IGFuIGVuZGxlc3MgbG9vcCBvZiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNicm9hZGNhc3RDaGFubmVsJywgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNpbml0aWFsaXplKCknLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgZXJyb3IgdGhyb3dpbmcgbW9kZSBpcyBlbmFibGVkIGZvciB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBpc1Rocm93T25FcnJvckVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93T25FcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VudHJhbGl6ZXMgcmV0dXJuIGhhbmRsaW5nIHdpdGggb3B0aW9uYWwgZXJyb3IgdGhyb3dpbmcuIFdoZW4gYHRocm93T25FcnJvcmAgaXMgZW5hYmxlZFxuICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgcmVzdWx0IGNvbnRhaW5zIGEgbm9uLW51bGxpc2ggZXJyb3IsIHRoZSBlcnJvciBpcyB0aHJvd24gaW5zdGVhZCBvZlxuICAgICAqIGJlaW5nIHJldHVybmVkLiBUaGlzIGVuc3VyZXMgY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYWxsIHB1YmxpYyBBUEkgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBfcmV0dXJuUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgcmVzdWx0ICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9sb2dQcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiAoJ0dvVHJ1ZUNsaWVudEAnICtcbiAgICAgICAgICAgIGAke3RoaXMuc3RvcmFnZUtleX06JHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIodGhpcy5fbG9nUHJlZml4KCksIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrVXJsVHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF3YWl0IHRoaXMuX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlbW92ZSBleGlzdGluZyBzZXNzaW9uIG9uIFVSTCBsb2dpbiBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZhaWxlZCBhdHRlbXB0IChlLmcuIHJldXNlZCBtYWdpYyBsaW5rKSBzaG91bGRuJ3QgaW52YWxpZGF0ZSBhIHZhbGlkIHNlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gYSB1c2VyIGJ5IHZlcmlmeWluZyBhIG1lc3NhZ2Ugc2lnbmVkIGJ5IHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXkuXG4gICAgICogU3VwcG9ydHMgRXRoZXJldW0gKHZpYSBTaWduLUluLVdpdGgtRXRoZXJldW0pICYgU29sYW5hIChTaWduLUluLVdpdGgtU29sYW5hKSBzdGFuZGFyZHMsXG4gICAgICogYm90aCBvZiB3aGljaCBkZXJpdmUgZnJvbSB0aGUgRUlQLTQzNjEgc3RhbmRhcmRcbiAgICAgKiBXaXRoIHNsaWdodCB2YXJpYXRpb24gb24gU29sYW5hJ3Mgc2lkZS5cbiAgICAgKiBAcmVmZXJlbmNlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhXZWIzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW4gfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGNhc2UgJ3NvbGFuYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aFNvbGFuYShjcmVkZW50aWFscyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFVuc3VwcG9ydGVkIGNoYWluIFwiJHtjaGFpbn1cImApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhFdGhlcmV1bShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgICAgICAvLyBUT0RPOiBmbGF0dGVuIHR5cGVcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVkZW50aWFscy5tZXNzYWdlO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gY3JlZGVudGlhbHMuc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbiwgd2FsbGV0LCBzdGF0ZW1lbnQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkV2FsbGV0O1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEJvdGggd2FsbGV0IGFuZCB1cmwgbXVzdCBiZSBzcGVjaWZpZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3YWxsZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dBbnkgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKCdldGhlcmV1bScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuZXRoZXJldW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0JyBpbiB3aW5kb3dBbnkuZXRoZXJldW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5ldGhlcmV1bS5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2luZG93QW55LmV0aGVyZXVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBFdGhlcmV1bSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuZXRoZXJldW0pIGRldGVjdGVkLiBNYWtlIHN1cmUgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSB3YWxsZXQgaW5zdGFsbGVkIGFuZCBjb25uZWN0ZWQgZm9yIHRoaXMgYXBwLiBQcmVmZXIgcGFzc2luZyB0aGUgd2FsbGV0IGludGVyZmFjZSBvYmplY3QgZGlyZWN0bHkgdG8gc2lnbkluV2l0aFdlYjMoeyBjaGFpbjogJ2V0aGVyZXVtJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChhY2NzKSA9PiBhY2NzKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBldGhfcmVxdWVzdEFjY291bnRzIGlzIG1pc3Npbmcgb3IgaW52YWxpZGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGFjY291bnRzIGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gZnJvbUhleChjaGFpbklkSGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpd2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdXJsLmhvc3QsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mubm9uY2UsXG4gICAgICAgICAgICAgICAgaXNzdWVkQXQ6IChfZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pc3N1ZWRBdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIG5vdEJlZm9yZTogKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vdEJlZm9yZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzOiAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucmVzb3VyY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZShzaXdlTWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBTaWduIG1lc3NhZ2VcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IChhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0b0hleChtZXNzYWdlKSwgYWRkcmVzc10sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnZXRoZXJldW0nLCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgfSwgKCgoX2sgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZTtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFdhbGxldDtcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCAhPT0gJ29iamVjdCcgfHwgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93QW55ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmICgnc29sYW5hJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICgoJ3NpZ25JbicgaW4gd2luZG93QW55LnNvbGFuYSAmJiB0eXBlb2Ygd2luZG93QW55LnNvbGFuYS5zaWduSW4gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoJ3NpZ25NZXNzYWdlJyBpbiB3aW5kb3dBbnkuc29sYW5hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbk1lc3NhZ2UgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5zb2xhbmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBjb21wYXRpYmxlIFNvbGFuYSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuc29sYW5hKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdzb2xhbmEnLCB3YWxsZXQ6IHJlc29sdmVkVXNlcldhbGxldCB9KSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgaWYgKCdzaWduSW4nIGluIHJlc29sdmVkV2FsbGV0ICYmIHJlc29sdmVkV2FsbGV0LnNpZ25Jbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc29sdmVkV2FsbGV0LnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGlzc3VlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpLCB7IFxuICAgICAgICAgICAgICAgICAgICAvLyBub24tb3ZlcnJpZGFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMScsIGRvbWFpbjogdXJsLmhvc3QsIHVyaTogdXJsLmhyZWYgfSksIChzdGF0ZW1lbnQgPyB7IHN0YXRlbWVudCB9IDogbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0VG9Qcm9jZXNzO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkgJiYgb3V0cHV0WzBdICYmIHR5cGVvZiBvdXRwdXRbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduZWRNZXNzYWdlJyBpbiBvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZScgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0VG9Qcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBzaWduSW4oKSBBUEkgcmV0dXJuZWQgb2JqZWN0IHdpdGhvdXQgc2lnbmVkTWVzc2FnZSBhbmQgc2lnbmF0dXJlIGZpZWxkcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCdzaWduTWVzc2FnZScgaW4gcmVzb2x2ZWRXYWxsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAhKCdwdWJsaWNLZXknIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICFyZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgISgndG9CYXNlNTgnIGluIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBhdGlibGUgc2lnbk1lc3NhZ2UoKSBhbmQgcHVibGljS2V5LnRvQmFzZTU4KCkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGAke3VybC5ob3N0fSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6YCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdGF0ZW1lbnQgPyBbJycsIHN0YXRlbWVudCwgJyddIDogWycnXSksXG4gICAgICAgICAgICAgICAgICAgICdWZXJzaW9uOiAxJyxcbiAgICAgICAgICAgICAgICAgICAgYFVSSTogJHt1cmwuaHJlZn1gLFxuICAgICAgICAgICAgICAgICAgICBgSXNzdWVkIEF0OiAkeyhfYyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNzdWVkQXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qubm90QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYE5vdCBCZWZvcmU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vdEJlZm9yZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5leHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BFeHBpcmF0aW9uIFRpbWU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmV4cGlyYXRpb25UaW1lfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgQ2hhaW4gSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmNoYWluSWR9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubm9uY2UpID8gW2BOb25jZTogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEubm9uY2V9YF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgUmVxdWVzdCBJRDogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVxdWVzdElkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2sgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnJlc291cmNlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5yZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4gYC0gJHtyZXNvdXJjZX1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTaWduYXR1cmUgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXliZVNpZ25hdHVyZSB8fCAhKG1heWJlU2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IHNpZ25NZXNzYWdlKCkgQVBJIHJldHVybmVkIGFuIHJlY29nbml6ZWQgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gbWF5YmVTaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnc29sYW5hJywgbWVzc2FnZSwgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKHNpZ25hdHVyZSkgfSwgKCgoX2wgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9tID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoc3RvcmFnZUl0ZW0gIT09IG51bGwgJiYgc3RvcmFnZUl0ZW0gIT09IHZvaWQgMCA/IHN0b3JhZ2VJdGVtIDogJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNvZGVWZXJpZmllciAmJiB0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2lnbmluZyBpbiB3aXRoIGFuIE9JREMgSUQgdG9rZW4uIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB1c2VkXG4gICAgICogc2hvdWxkIGJlIGVuYWJsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aElkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGludmFsaWRUb2tlbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqXG4gICAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgKiBhdCB0aGlzIHRpbWUuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeU90cChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZWRpcmVjdFRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhcHRjaGFUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnb3B0aW9ucycgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyA9IChfYSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbztcbiAgICAgICAgICAgICAgICBjYXB0Y2hhVG9rZW4gPSAoX2IgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9IH0pLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5WZXJpZmljYXRpb25FcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpO1xuICAgICAgICAgICAgICAgIHRocm93IHRva2VuVmVyaWZpY2F0aW9uRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMocGFyYW1zLnR5cGUgPT0gJ3JlY292ZXJ5JyA/ICdQQVNTV09SRF9SRUNPVkVSWScgOiAnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICAgIGlmICgoKF9kID0gcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmwpICYmIGlzQnJvd3NlcigpICYmICEoKF9lID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzdWx0LmRhdGEudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBtYXliZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSB1c2VyIG9iamVjdCB3aXRoIGEgd2FybmluZyBwcm94eSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXJucyB3aGVuIHByb3BlcnRpZXMgb2YgdGhlIHVzZXIgYXJlIGFjY2Vzc2VkLCBub3Qgd2hlbiBzZXNzaW9uLnVzZXIgaXRzZWxmIGlzIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyICYmXG4gICAgICAgICAgICAgICAgICAgICFjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3NXYXJuaW5nUmVmID0geyB2YWx1ZTogdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkoY3VycmVudFNlc3Npb24udXNlciwgc3VwcHJlc3NXYXJuaW5nUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjbGllbnQtbGV2ZWwgc3VwcHJlc3Npb24gZmxhZyB3aGVuIHRoZSBwcm94eSBzdXBwcmVzc2VzIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwcmVzc1dhcm5pbmdSZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIG5ldHdvcmsgcmVxdWVzdCB0byB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIsIHNvIHRoZSByZXR1cm5lZFxuICAgICAqIHZhbHVlIGlzIGF1dGhlbnRpYyBhbmQgY2FuIGJlIHVzZWQgdG8gYmFzZSBhdXRob3JpemF0aW9uIHJ1bGVzIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBUYWtlcyBpbiBhbiBvcHRpb25hbCBhY2Nlc3MgdG9rZW4gSldULiBJZiBubyBKV1QgaXMgcHJvdmlkZWQsIHRoZSBKV1QgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uIGlzIHVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoand0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YS51c2VyKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRVc2VyKGp3dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBqd3QsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYWNjZXNzX3Rva2VuIG9yIGN1c3RvbSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgJiYgIXRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2MgPSAoX2IgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSldUIGNvbnRhaW5zIGEgYHNlc3Npb25faWRgIHdoaWNoIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW4gYWN0aXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gaW4gdGhlIGRhdGFiYXNlLCBpbmRpY2F0aW5nIHRoZSB1c2VyIGlzIHNpZ25lZCBvdXQuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgeyBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbiB8fCAhY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3c7XG4gICAgICAgICAgICBsZXQgaGFzRXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGF5bG9hZC5leHA7XG4gICAgICAgICAgICAgICAgaGFzRXhwaXJlZCA9IGV4cGlyZXNBdCA8PSB0aW1lTm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlZnJlc2hlZFNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsIGlzc3VlZEF0LCBleHBpcmVzQXQsIHRpbWVOb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogdG9rZW5fdHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAgICpcbiAgICAgKiBJZiBgZGV0ZWN0U2Vzc2lvbkluVXJsYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBVUkwgYW5kIHBhcmFtcyB0byBkZXRlcm1pbmVcbiAgICAgKiBpZiB0aGUgVVJMIHNob3VsZCBiZSBwcm9jZXNzZWQgYXMgYSBTdXBhYmFzZSBhdXRoIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1c2VycyB0byBleGNsdWRlXG4gICAgICogVVJMcyBmcm9tIG90aGVyIE9BdXRoIHByb3ZpZGVycyAoZS5nLiwgRmFjZWJvb2sgTG9naW4pIHRoYXQgYWxzbyByZXR1cm4gYWNjZXNzX3Rva2VuIGluIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdFNlc3Npb25JblVybChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICAgKi9cbiAgICBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChvcHRpb25zID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25PdXQoeyBzY29wZSB9ID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IgJiYgIWlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3Ioc2Vzc2lvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwNHMgc2luY2UgdXNlciBtaWdodCBub3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghKChpc0F1dGhBcGlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkF1dGhTdGF0ZUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlQ2FsbGJhY2tJZCgpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI3Vuc3Vic2NyaWJlKCknLCAnc3RhdGUgY2hhbmdlIGNhbGxiYWNrIHdpdGggaWQgcmVtb3ZlZCcsIGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjb25BdXRoU3RhdGVDaGFuZ2UoKScsICdyZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggaWQnLCBpZCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRJbml0aWFsU2Vzc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FwdGNoYVRva2VuIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgaWRlbnRpdGllcyBsaW5rZWQgdG8gYSB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJJZGVudGl0aWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCd0b2tlbicgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsIGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfZSA9IChfZCA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgISgoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHlJZFRva2VuKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogc2Vzc2lvbkVycm9yLCBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2lkZW50aXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVVNFUl9VUERBVEVEJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvJHtpZGVudGl0eS5pZGVudGl0eV9pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2IgPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSk7IC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikge1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L2F1dGhvcml6ZWAsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IG9wdGlvbnMuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybCk7XG4gICAgICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlciwgdXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9ICcjX3JlY292ZXJBbmRSZWZyZXNoKCknO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNlc3Npb24gPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gJiYgdGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGxldCBtYXliZVVzZXIgPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJiBPYmplY3QuaXModGhpcy5zdG9yYWdlLCB0aGlzLnVzZXJTdG9yYWdlKSAmJiAhbWF5YmVVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgYW5kIHVzZXJTdG9yYWdlIGFyZSB0aGUgc2FtZSBzdG9yYWdlIG1lZGl1bSwgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93LmxvY2FsU3RvcmFnZSBpZiB1c2VyU3RvcmFnZSBkb2VzIG5vdCBoYXZlIHRoZSB1c2VyIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSBzdG9yZWQsIHN0b3JlIGl0IGZpcnN0IHRoZXJlYnkgbWlncmF0aW5nIHRoZSB1c2VyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHN0b3JhZ2UgLT4gdXNlclN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVVc2VyID0geyB1c2VyOiBjdXJyZW50U2Vzc2lvbi51c2VyIH07XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInLCBtYXliZVVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gKF9hID0gbWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVzZXJOb3RBdmFpbGFibGVQcm94eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFNlc3Npb24gJiYgIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHN0b3JhZ2UgaXMgbm90IHNldCwgbGV0J3MgY2hlY2sgaWYgaXQgd2FzIHByZXZpb3VzbHkgZW5hYmxlZCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIGJyaW5nIGJhY2sgdGhlIHN0b3JhZ2UgYXMgaXQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgdXNlclN0b3JhZ2Ugd2FzIHByZXZpb3VzbHkgZW5hYmxlZCBhbmQgdGhlIHN0b3JhZ2UgbWVkaXVtIHdhcyB0aGUgc2FtZSwgdG8gbW92ZSB0aGUgdXNlciBiYWNrIHVuZGVyIHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0ZVVzZXIgPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGVVc2VyICYmIChzZXBhcmF0ZVVzZXIgPT09IG51bGwgfHwgc2VwYXJhdGVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBhcmF0ZVVzZXIudXNlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBzZXBhcmF0ZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gdXNlck5vdEF2YWlsYWJsZVByb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9ICgoX2IgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBJbmZpbml0eSkgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IEVYUElSWV9NQVJHSU5fTVM7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsIGBzZXNzaW9uIGhhcyR7ZXhwaXJlc1dpdGhNYXJnaW4gPyAnJyA6ICcgbm90J30gZXhwaXJlZCB3aXRoIG1hcmdpbiBvZiAke0VYUElSWV9NQVJHSU5fTVN9c2ApO1xuICAgICAgICAgICAgaWYgKGV4cGlyZXNXaXRoTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbiAmJiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTZXNzaW9uLnVzZXIgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJveHkgdXNlciwgdHJ5IHRvIGdldCB0aGUgcmVhbCB1c2VyIGRhdGFcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IgJiYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdjb3VsZCBub3QgZ2V0IHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChnZXRVc2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGRhdGE6JywgZ2V0VXNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3IgZ2V0dGluZyB1c2VyIGRhdGEsIHNraXBwaW5nIFNJR05FRF9JTiBub3RpZmljYXRpb24nLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHN0b3JhZ2U7IHBlcnNpc3RpbmcgaXQgYWdhaW4gbWF5IG92ZXJ3cml0ZSBhIHZhbHVlIHNhdmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19jYWxsUmVmcmVzaFRva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmICghZGF0YS5zZXNzaW9uKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdUT0tFTl9SRUZSRVNIRUQnLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQsIHNlc3Npb24sIGJyb2FkY2FzdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfbm90aWZ5QWxsU3Vic2NyaWJlcnMoJHtldmVudH0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7IGV2ZW50LCBzZXNzaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnZhbHVlcygpKS5tYXAoYXN5bmMgKHgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB4LmNhbGxiYWNrKGV2ZW50LCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICAgKiBwcm9jZXNzIHRvIF9zdGFydEF1dG9SZWZyZXNoVG9rZW4gaWYgcG9zc2libGVcbiAgICAgKi9cbiAgICBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zYXZlU2Vzc2lvbigpJywgc2Vzc2lvbik7XG4gICAgICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAgICAgLy8gc28gd2UgY2FuIHNhZmVseSBzdXBwcmVzcyB0aGUgd2FybmluZyByZXR1cm5lZCBieSBmdXR1cmUgZ2V0U2Vzc2lvbiBjYWxsc1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IHRvIHdvcmsgd2l0aCwgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHNlc3Npb24gb2JqZWN0IGlmIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgY29uc3Qgc2Vzc2lvblRvUHJvY2VzcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb24pO1xuICAgICAgICBjb25zdCB1c2VySXNQcm94eSA9IHNlc3Npb25Ub1Byb2Nlc3MudXNlciAmJiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGlmICghdXNlcklzUHJveHkgJiYgc2Vzc2lvblRvUHJvY2Vzcy51c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIHJlYWwgdXNlciBvYmplY3QsIHNhdmUgaXQgdG8gdXNlclN0b3JhZ2UuXG4gICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogc2Vzc2lvblRvUHJvY2Vzcy51c2VyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXNlcklzUHJveHkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBwcm94eSwgaXQgbWVhbnMgdXNlciB3YXMgbm90IGZvdW5kIGluIHVzZXJTdG9yYWdlLlxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBlbnN1cmUgbm8gc3RhbGUgdXNlciBkYXRhIGZvciB0aGlzIGtleSBleGlzdHMgaW4gdXNlclN0b3JhZ2UgaWYgd2Ugd2VyZSB0byBzYXZlIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gb3Igc2ltcGx5IG5vdCBzYXZlIHRoZSBwcm94eS4gRm9yIG5vdywgd2UgZG9uJ3Qgc2F2ZSB0aGUgcHJveHkgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgbmVlZCB0byBjbGVhciB1c2VyU3RvcmFnZSBpZiB1c2VyIGJlY29tZXMgcHJveHksIHRoYXQgbG9naWMgd291bGQgZ28gaGVyZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gc2Vzc2lvbiBkYXRhIGZvciBwcmltYXJ5IHN0b3JhZ2U6IHJlbW92ZSB0aGUgdXNlciBwcm9wZXJ0eSBiZWZvcmUgY2xvbmluZ1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgb3JpZ2luYWwgc2Vzc2lvbi51c2VyIG1pZ2h0IGJlIHRoZSBwcm94eVxuICAgICAgICAgICAgY29uc3QgbWFpblNlc3Npb25EYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvblRvUHJvY2Vzcyk7XG4gICAgICAgICAgICBkZWxldGUgbWFpblNlc3Npb25EYXRhLnVzZXI7IC8vIFJlbW92ZSB1c2VyIChyZWFsIG9yIHByb3h5KSBiZWZvcmUgY2xvbmluZyBmb3IgbWFpbiBzdG9yYWdlXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEgPSBkZWVwQ2xvbmUobWFpblNlc3Npb25EYXRhKTtcbiAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY2xvbmVkTWFpblNlc3Npb25EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHVzZXJTdG9yYWdlIGlzIGNvbmZpZ3VyZWQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHNlc3Npb24udXNlciBzaG91bGQgaWRlYWxseSBub3QgYmUgYSBwcm94eS5cbiAgICAgICAgICAgIC8vIElmIGl0IHdlcmUsIHN0cnVjdHVyZWRDbG9uZSB3b3VsZCBmYWlsLiBUaGlzIGltcGxpZXMgYW4gaXNzdWUgZWxzZXdoZXJlIGlmIHVzZXIgaXMgYSBwcm94eSBoZXJlXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRTZXNzaW9uID0gZGVlcENsb25lKHNlc3Npb25Ub1Byb2Nlc3MpOyAvLyBzZXNzaW9uVG9Qcm9jZXNzIHN0aWxsIGhhcyBpdHMgb3JpZ2luYWwgdXNlciBwcm9wZXJ0eVxuICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjbG9uZWRTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlU2Vzc2lvbigpJyk7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLWNvZGUtdmVyaWZpZXInKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAgICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgICAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgICAgIC8vIGl0c2VsZlxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0ICYmIHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGltZW91dC51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGltZW91dC51bnJlZigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdG9wQXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdG9wQXV0b1JlZnJlc2goKScpO1xuICAgICAgICBjb25zdCB0aWNrZXIgPSB0aGlzLmF1dG9SZWZyZXNoVGlja2VyO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHRpY2tlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmF1dG9SZWZyZXNoVGlja1RpbWVvdXQ7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgICAqXG4gICAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NU31tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJyk7XG4gICAgICAgIGlmICghaXNCcm93c2VyKCkgfHwgISh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaycsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKTsgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgICAqL1xuICAgIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIodXJsLCBwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICBhc3luYyBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Vucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSB9LCAocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZSdcbiAgICAgICAgICAgICAgICAgICAgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfVxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmIGRhdGEudHlwZSA9PT0gJ3RvdHAnICYmICgoX2IgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudG90cCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnFyX2NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudG90cC5xcl9jb2RlID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCwke2RhdGEudG90cC5xcl9jb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF92ZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGNoYWxsZW5nZV9pZDogcGFyYW1zLmNoYWxsZW5nZUlkIH0sICgnd2ViYXV0aG4nIGluIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX3Jlc3BvbnNlOiBwYXJhbXMud2ViYXV0aG4udHlwZSA9PT0gJ2NyZWF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2UocGFyYW1zLndlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UocGFyYW1zLndlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UpIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvZGU6IHBhcmFtcy5jb2RlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihPYmplY3QuYXNzaWduKHsgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4gfSwgZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCcsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfY2hhbGxlbmdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vY2hhbGxlbmdlYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlICE9PSAnd2ViYXV0aG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS53ZWJhdXRobi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHsgd2ViYXV0aG46IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobiksIHsgY3JlZGVudGlhbF9vcHRpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zKSwgeyBwdWJsaWNLZXk6IGRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXkpIH0pIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX29wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5KSB9KSB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KHBhcmFtcykge1xuICAgICAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICAgICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gdXNlICNnZXRVc2VyIGluc3RlYWQgb2YgI19nZXRVc2VyIGFzIHRoZSBmb3JtZXIgYWNxdWlyZXMgYSBsb2NrXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IsIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBhbGw6IFtdLFxuICAgICAgICAgICAgcGhvbmU6IFtdLFxuICAgICAgICAgICAgdG90cDogW10sXG4gICAgICAgICAgICB3ZWJhdXRobjogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZmFjdG9ycyBPTkNFXG4gICAgICAgIGZvciAoY29uc3QgZmFjdG9yIG9mIChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5mYWN0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkge1xuICAgICAgICAgICAgZGF0YS5hbGwucHVzaChmYWN0b3IpO1xuICAgICAgICAgICAgaWYgKGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZGF0YVtmYWN0b3IuZmFjdG9yX3R5cGVdLnB1c2goZmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsfVxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoand0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChqd3QpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKGp3dCk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRGYWN0b3JzID0gKF9iID0gKF9hID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmZhY3RvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGN1cnJlbnRMZXZlbCwgbmV4dExldmVsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2QgPSAoX2MgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgb25seSBhIHJlZGlyZWN0X3VybCBmaWVsZCwgaXQgbWVhbnMgY29uc2VudCB3YXMgYWxyZWFkeSBnaXZlbiAtIHRoZSBjYWxsZXJcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSByZWRpcmVjdCBtYW51YWxseSBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF1dGhvcml6YXRpb25EZXRhaWxzKGF1dGhvcml6YXRpb25JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYW4gT0F1dGggYXV0aG9yaXphdGlvbiByZXF1ZXN0LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX2FwcHJvdmVBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb2F1dGgvYXV0aG9yaXphdGlvbnMvJHthdXRob3JpemF0aW9uSWR9L2NvbnNlbnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyBhY3Rpb246ICdhcHByb3ZlJyB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVuaWVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZW55QXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfS9jb25zZW50YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgYWN0aW9uOiAnZGVueScgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGluIGJyb3dzZXIgdW5sZXNzIHNraXBCcm93c2VyUmVkaXJlY3QgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBPQXV0aCBncmFudHMgdGhhdCB0aGUgYXV0aGVudGljYXRlZCB1c2VyIGhhcyBhdXRob3JpemVkLlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RPQXV0aEdyYW50cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyL29hdXRoL2dyYW50c2AsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyBhIHVzZXIncyBPQXV0aCBncmFudCBmb3IgYSBzcGVjaWZpYyBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBfcmV2b2tlT0F1dGhHcmFudChvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL29hdXRoL2dyYW50c2AsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogeyBjbGllbnRfaWQ6IG9wdGlvbnMuY2xpZW50SWQgfSxcbiAgICAgICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7fSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoSndrKGtpZCwgandrcyA9IHsga2V5czogW10gfSkge1xuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSB0aGUgc3VwcGxpZWQgandrc1xuICAgICAgICBsZXQgandrID0gandrcy5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKGp3aykge1xuICAgICAgICAgICAgcmV0dXJuIGp3aztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSBjYWNoZVxuICAgICAgICBqd2sgPSB0aGlzLmp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIC8vIGp3ayBleGlzdHMgYW5kIGp3a3MgaXNuJ3Qgc3RhbGVcbiAgICAgICAgaWYgKGp3ayAmJiB0aGlzLmp3a3NfY2FjaGVkX2F0ICsgSldLU19UVEwgPiBub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gandrIGlzbid0IGNhY2hlZCBpbiBtZW1vcnkgc28gd2UgbmVlZCB0byBmZXRjaCBpdCBmcm9tIHRoZSB3ZWxsLWtub3duIGVuZHBvaW50XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vLndlbGwta25vd24vandrcy5qc29uYCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEua2V5cyB8fCBkYXRhLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmp3a3MgPSBkYXRhO1xuICAgICAgICB0aGlzLmp3a3NfY2FjaGVkX2F0ID0gbm93O1xuICAgICAgICAvLyBGaW5kIHRoZSBzaWduaW5nIGtleVxuICAgICAgICBqd2sgPSBkYXRhLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICBpZiAoIWp3aykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIEpXVCBjbGFpbXMgcHJlc2VudCBpbiB0aGUgYWNjZXNzIHRva2VuIGJ5IGZpcnN0IHZlcmlmeWluZyB0aGVcbiAgICAgKiBKV1QgYWdhaW5zdCB0aGUgc2VydmVyJ3MgSlNPTiBXZWIgS2V5IFNldCBlbmRwb2ludFxuICAgICAqIGAvLndlbGwta25vd24vandrcy5qc29uYCB3aGljaCBpcyBvZnRlbiBjYWNoZWQsIHJlc3VsdGluZyBpbiBzaWduaWZpY2FudGx5XG4gICAgICogZmFzdGVyIHJlc3BvbnNlcy4gUHJlZmVyIHRoaXMgbWV0aG9kIG92ZXIge0BsaW5rICNnZXRVc2VyfSB3aGljaCBhbHdheXNcbiAgICAgKiBzZW5kcyBhIHJlcXVlc3QgdG8gdGhlIEF1dGggc2VydmVyIGZvciBlYWNoIEpXVC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBwcm9qZWN0IGlzIG5vdCB1c2luZyBhbiBhc3ltbWV0cmljIEpXVCBzaWduaW5nIGtleSAobGlrZSBFQ0Mgb3JcbiAgICAgKiBSU0EpIGl0IGFsd2F5cyBzZW5kcyBhIHJlcXVlc3QgdG8gdGhlIEF1dGggc2VydmVyIChzaW1pbGFyIHRvIHtAbGlua1xuICAgICAqICNnZXRVc2VyfSkgdG8gdmVyaWZ5IHRoZSBKV1QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gand0IEFuIG9wdGlvbmFsIHNwZWNpZmljIEpXVCB5b3Ugd2lzaCB0byB2ZXJpZnksIG5vdCB0aGUgb25lIHlvdVxuICAgICAqICAgICAgICAgICAgY2FuIG9idGFpbiBmcm9tIHtAbGluayAjZ2V0U2Vzc2lvbn0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVmFyaW91cyBhZGRpdGlvbmFsIG9wdGlvbnMgdGhhdCBhbGxvdyB5b3UgdG8gY3VzdG9taXplIHRoZVxuICAgICAqICAgICAgICAgICAgICAgIGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENsYWltcyhqd3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gand0O1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBoZWFkZXIsIHBheWxvYWQsIHNpZ25hdHVyZSwgcmF3OiB7IGhlYWRlcjogcmF3SGVhZGVyLCBwYXlsb2FkOiByYXdQYXlsb2FkIH0sIH0gPSBkZWNvZGVKV1QodG9rZW4pO1xuICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93RXhwaXJlZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgZXhwaXJlZCBKV1RzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBqd3QgYXJndW1lbnQgd2FzIHBhc3NlZFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwKHBheWxvYWQuZXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSAhaGVhZGVyLmFsZyB8fFxuICAgICAgICAgICAgICAgIGhlYWRlci5hbGcuc3RhcnRzV2l0aCgnSFMnKSB8fFxuICAgICAgICAgICAgICAgICFoZWFkZXIua2lkIHx8XG4gICAgICAgICAgICAgICAgISgnY3J5cHRvJyBpbiBnbG9iYWxUaGlzICYmICdzdWJ0bGUnIGluIGdsb2JhbFRoaXMuY3J5cHRvKVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaEp3ayhoZWFkZXIua2lkLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmtleXMpID8geyBrZXlzOiBvcHRpb25zLmtleXMgfSA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qd2tzKTtcbiAgICAgICAgICAgIC8vIElmIHN5bW1ldHJpYyBhbGdvcml0aG0gb3IgV2ViQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZ2V0VXNlcigpXG4gICAgICAgICAgICBpZiAoIXNpZ25pbmdLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIodG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ2V0VXNlciBzdWNjZWVkcyBzbyB0aGUgY2xhaW1zIGluIHRoZSBKV1QgY2FuIGJlIHRydXN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFpbXM6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBnZXRBbGdvcml0aG0oaGVhZGVyLmFsZyk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IEpXSyB0byBDcnlwdG9LZXlcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBzaWduaW5nS2V5LCBhbGdvcml0aG0sIHRydWUsIFtcbiAgICAgICAgICAgICAgICAndmVyaWZ5JyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIHB1YmxpY0tleSwgc2lnbmF0dXJlLCBzdHJpbmdUb1VpbnQ4QXJyYXkoYCR7cmF3SGVhZGVyfS4ke3Jhd1BheWxvYWR9YCkpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0ludmFsaWQgSldUIHNpZ25hdHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzLCBkZWNvZGUgYW5kIHJldHVybiBjbGFpbXNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjbGFpbXM6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0ge307XG5leHBvcnQgZGVmYXVsdCBHb1RydWVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMiLCJBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQiLCJERUZBVUxUX0hFQURFUlMiLCJFWFBJUllfTUFSR0lOX01TIiwiR09UUlVFX1VSTCIsIkpXS1NfVFRMIiwiU1RPUkFHRV9LRVkiLCJBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IiLCJBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IiLCJBdXRoSW52YWxpZEp3dEVycm9yIiwiQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IiLCJBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiQXV0aFVua25vd25FcnJvciIsImlzQXV0aEFwaUVycm9yIiwiaXNBdXRoRXJyb3IiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiX3JlcXVlc3QiLCJfc2Vzc2lvblJlc3BvbnNlIiwiX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkIiwiX3Nzb1Jlc3BvbnNlIiwiX3VzZXJSZXNwb25zZSIsImRlY29kZUpXVCIsImRlZXBDbG9uZSIsIkRlZmVycmVkIiwiZ2VuZXJhdGVDYWxsYmFja0lkIiwiZ2V0QWxnb3JpdGhtIiwiZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCIsImdldEl0ZW1Bc3luYyIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsImlzQnJvd3NlciIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJyZW1vdmVJdGVtQXN5bmMiLCJyZXNvbHZlRmV0Y2giLCJyZXRyeWFibGUiLCJzZXRJdGVtQXN5bmMiLCJzbGVlcCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwidXNlck5vdEF2YWlsYWJsZVByb3h5IiwidmFsaWRhdGVFeHAiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJuYXZpZ2F0b3JMb2NrIiwicG9seWZpbGxHbG9iYWxUaGlzIiwidmVyc2lvbiIsImJ5dGVzVG9CYXNlNjRVUkwiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJjcmVhdGVTaXdlTWVzc2FnZSIsImZyb21IZXgiLCJnZXRBZGRyZXNzIiwidG9IZXgiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsInNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlIiwic2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSIsIldlYkF1dGhuQXBpIiwiREVGQVVMVF9PUFRJT05TIiwidXJsIiwic3RvcmFnZUtleSIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImhlYWRlcnMiLCJmbG93VHlwZSIsImRlYnVnIiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsInRocm93T25FcnJvciIsImxvY2tBY3F1aXJlVGltZW91dCIsImxvY2tOb09wIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJHTE9CQUxfSldLUyIsIkdvVHJ1ZUNsaWVudCIsImp3a3MiLCJfYSIsIl9iIiwia2V5cyIsInZhbHVlIiwiT2JqZWN0IiwiYXNzaWduIiwiandrc19jYWNoZWRfYXQiLCJjYWNoZWRBdCIsIk51bWJlciIsIk1JTl9TQUZFX0lOVEVHRVIiLCJpc1Rocm93T25FcnJvckVuYWJsZWQiLCJfcmV0dXJuUmVzdWx0IiwicmVzdWx0IiwiZXJyb3IiLCJfbG9nUHJlZml4IiwiaW5zdGFuY2VJRCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIl9kZWJ1ZyIsImFyZ3MiLCJsb2dEZWJ1Z01lc3NhZ2VzIiwibG9nZ2VyIiwiaW5pdGlhbGl6ZSIsImluaXRpYWxpemVQcm9taXNlIiwiX2FjcXVpcmVMb2NrIiwiX2luaXRpYWxpemUiLCJwYXJhbXMiLCJjYWxsYmFja1VybFR5cGUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2siLCJfaXNQS0NFQ2FsbGJhY2siLCJkYXRhIiwiX2dldFNlc3Npb25Gcm9tVVJMIiwiZXJyb3JDb2RlIiwiZGV0YWlscyIsImNvZGUiLCJzZXNzaW9uIiwicmVkaXJlY3RUeXBlIiwiX3NhdmVTZXNzaW9uIiwic2V0VGltZW91dCIsIl9ub3RpZnlBbGxTdWJzY3JpYmVycyIsIl9yZWNvdmVyQW5kUmVmcmVzaCIsIl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwic2lnbkluQW5vbnltb3VzbHkiLCJjcmVkZW50aWFscyIsIl9jIiwicmVzIiwiZmV0Y2giLCJib2R5Iiwib3B0aW9ucyIsImdvdHJ1ZV9tZXRhX3NlY3VyaXR5IiwiY2FwdGNoYV90b2tlbiIsImNhcHRjaGFUb2tlbiIsInhmb3JtIiwidXNlciIsInNpZ25VcCIsImVtYWlsIiwicGFzc3dvcmQiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsInN0b3JhZ2UiLCJyZWRpcmVjdFRvIiwiZW1haWxSZWRpcmVjdFRvIiwiY29kZV9jaGFsbGVuZ2UiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2QiLCJwaG9uZSIsImNoYW5uZWwiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJpbnZhbGlkVG9rZW5FcnJvciIsIndlYWtfcGFzc3dvcmQiLCJ3ZWFrUGFzc3dvcmQiLCJzaWduSW5XaXRoT0F1dGgiLCJfZCIsIl9oYW5kbGVQcm92aWRlclNpZ25JbiIsInByb3ZpZGVyIiwic2NvcGVzIiwicXVlcnlQYXJhbXMiLCJza2lwQnJvd3NlclJlZGlyZWN0IiwiZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbiIsImF1dGhDb2RlIiwiX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJzaWduSW5XaXRoV2ViMyIsImNoYWluIiwic2lnbkluV2l0aEV0aGVyZXVtIiwic2lnbkluV2l0aFNvbGFuYSIsIkVycm9yIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJtZXNzYWdlIiwic2lnbmF0dXJlIiwid2FsbGV0Iiwic3RhdGVtZW50IiwicmVzb2x2ZWRXYWxsZXQiLCJ3aW5kb3dBbnkiLCJldGhlcmV1bSIsInJlcXVlc3QiLCJVUkwiLCJhY2NvdW50cyIsIm1ldGhvZCIsInRoZW4iLCJhY2NzIiwiY2F0Y2giLCJsZW5ndGgiLCJhZGRyZXNzIiwiY2hhaW5JZCIsImNoYWluSWRIZXgiLCJzaXdlTWVzc2FnZSIsImRvbWFpbiIsImhvc3QiLCJ1cmkiLCJub25jZSIsImlzc3VlZEF0IiwiZXhwaXJhdGlvblRpbWUiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJfbSIsInNvbGFuYSIsInNpZ25JbiIsInNpZ25NZXNzYWdlIiwib3V0cHV0Iiwib3V0cHV0VG9Qcm9jZXNzIiwiQXJyYXkiLCJpc0FycmF5Iiwic2lnbmVkTWVzc2FnZSIsIlVpbnQ4QXJyYXkiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInB1YmxpY0tleSIsInRvQmFzZTU4IiwibWFwIiwicmVzb3VyY2UiLCJqb2luIiwibWF5YmVTaWduYXR1cmUiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInN0b3JhZ2VJdGVtIiwiY29kZVZlcmlmaWVyIiwic3BsaXQiLCJhdXRoX2NvZGUiLCJjb2RlX3ZlcmlmaWVyIiwic2lnbkluV2l0aElkVG9rZW4iLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsImlkX3Rva2VuIiwic2lnbkluV2l0aE90cCIsImNyZWF0ZV91c2VyIiwic2hvdWxkQ3JlYXRlVXNlciIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJ2ZXJpZnlPdHAiLCJ1bmRlZmluZWQiLCJ0b2tlblZlcmlmaWNhdGlvbkVycm9yIiwidHlwZSIsInNpZ25JbldpdGhTU08iLCJwcm92aWRlcl9pZCIsInByb3ZpZGVySWQiLCJyZWRpcmVjdF90byIsInNraXBfaHR0cF9yZWRpcmVjdCIsInJlYXV0aGVudGljYXRlIiwiX3JlYXV0aGVudGljYXRlIiwiX3VzZVNlc3Npb24iLCJzZXNzaW9uRXJyb3IiLCJqd3QiLCJyZXNlbmQiLCJlbmRwb2ludCIsImdldFNlc3Npb24iLCJsb2NrQWNxdWlyZWQiLCJsYXN0IiwicGVuZGluZ0luTG9jayIsIlByb21pc2UiLCJyZXNvbHZlIiwicHVzaCIsImUiLCJsb2NrIiwid2FpdE9uIiwiYWxsIiwic3BsaWNlIiwiX19sb2FkU2Vzc2lvbiIsInN0YWNrIiwiY3VycmVudFNlc3Npb24iLCJtYXliZVNlc3Npb24iLCJfaXNWYWxpZFNlc3Npb24iLCJfcmVtb3ZlU2Vzc2lvbiIsImhhc0V4cGlyZWQiLCJleHBpcmVzX2F0Iiwibm93IiwidXNlclN0b3JhZ2UiLCJtYXliZVVzZXIiLCJpc1NlcnZlciIsIl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkiLCJzdXBwcmVzc1dhcm5pbmdSZWYiLCJzdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nIiwiX2NhbGxSZWZyZXNoVG9rZW4iLCJyZWZyZXNoX3Rva2VuIiwiZ2V0VXNlciIsIl9nZXRVc2VyIiwidXBkYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJfdXBkYXRlVXNlciIsInNlc3Npb25EYXRhIiwidXNlckVycm9yIiwic2V0U2Vzc2lvbiIsIl9zZXRTZXNzaW9uIiwidGltZU5vdyIsImV4cGlyZXNBdCIsInBheWxvYWQiLCJleHAiLCJyZWZyZXNoZWRTZXNzaW9uIiwidG9rZW5fdHlwZSIsImV4cGlyZXNfaW4iLCJyZWZyZXNoU2Vzc2lvbiIsIl9yZWZyZXNoU2Vzc2lvbiIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JfY29kZSIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJzdGF0ZSIsInRvU3RyaW5nIiwicHJvdmlkZXJfdG9rZW4iLCJwcm92aWRlcl9yZWZyZXNoX3Rva2VuIiwiTWF0aCIsInJvdW5kIiwiZXhwaXJlc0luIiwicGFyc2VJbnQiLCJhY3R1YWxseUV4cGlyZXNJbiIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzaCIsIkJvb2xlYW4iLCJjdXJyZW50U3RvcmFnZUNvbnRlbnQiLCJzaWduT3V0Iiwic2NvcGUiLCJfc2lnbk91dCIsImFjY2Vzc1Rva2VuIiwiYWRtaW4iLCJzdGF0dXMiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImNhbGxiYWNrIiwiaWQiLCJzdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsInN0YXRlQ2hhbmdlRW1pdHRlcnMiLCJzZXQiLCJfZW1pdEluaXRpYWxTZXNzaW9uIiwiZ2V0IiwiZXJyIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwiZ2V0VXNlcklkZW50aXRpZXMiLCJpZGVudGl0aWVzIiwibGlua0lkZW50aXR5IiwibGlua0lkZW50aXR5SWRUb2tlbiIsImxpbmtJZGVudGl0eU9BdXRoIiwiX2dldFVybEZvclByb3ZpZGVyIiwibGlua19pZGVudGl0eSIsInVubGlua0lkZW50aXR5IiwiaWRlbnRpdHkiLCJpZGVudGl0eV9pZCIsIl9yZWZyZXNoQWNjZXNzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJkZWJ1Z05hbWUiLCJzdWJzdHJpbmciLCJzdGFydGVkQXQiLCJhdHRlbXB0IiwicG93IiwibmV4dEJhY2tPZmZJbnRlcnZhbCIsImlzVmFsaWRTZXNzaW9uIiwiaXMiLCJzZXBhcmF0ZVVzZXIiLCJleHBpcmVzV2l0aE1hcmdpbiIsIkluZmluaXR5IiwiZ2V0VXNlckVycm9yIiwicmVmcmVzaGluZ0RlZmVycmVkIiwicHJvbWlzZSIsInJlamVjdCIsImV2ZW50IiwiYnJvYWRjYXN0IiwiYnJvYWRjYXN0Q2hhbm5lbCIsInBvc3RNZXNzYWdlIiwiZXJyb3JzIiwicHJvbWlzZXMiLCJmcm9tIiwidmFsdWVzIiwieCIsImkiLCJzZXNzaW9uVG9Qcm9jZXNzIiwidXNlcklzUHJveHkiLCJtYWluU2Vzc2lvbkRhdGEiLCJjbG9uZWRNYWluU2Vzc2lvbkRhdGEiLCJjbG9uZWRTZXNzaW9uIiwiX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2siLCJ2aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9zdGFydEF1dG9SZWZyZXNoIiwiX3N0b3BBdXRvUmVmcmVzaCIsInRpY2tlciIsInNldEludGVydmFsIiwiX2F1dG9SZWZyZXNoVG9rZW5UaWNrIiwiYXV0b1JlZnJlc2hUaWNrZXIiLCJ1bnJlZiIsIkRlbm8iLCJ1bnJlZlRpbWVyIiwidGltZW91dCIsImF1dG9SZWZyZXNoVGlja1RpbWVvdXQiLCJjbGVhckludGVydmFsIiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRBdXRvUmVmcmVzaCIsInN0b3BBdXRvUmVmcmVzaCIsImV4cGlyZXNJblRpY2tzIiwiZmxvb3IiLCJpc0FjcXVpcmVUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vblZpc2liaWxpdHlDaGFuZ2VkIiwiY2FsbGVkRnJvbUluaXRpYWxpemUiLCJtZXRob2ROYW1lIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJ1cmxQYXJhbXMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmbG93UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJfdW5lbnJvbGwiLCJmYWN0b3JJZCIsIl9lbnJvbGwiLCJmcmllbmRseV9uYW1lIiwiZnJpZW5kbHlOYW1lIiwiZmFjdG9yX3R5cGUiLCJmYWN0b3JUeXBlIiwiaXNzdWVyIiwidG90cCIsInFyX2NvZGUiLCJfdmVyaWZ5IiwiY2hhbGxlbmdlX2lkIiwiY2hhbGxlbmdlSWQiLCJ3ZWJhdXRobiIsImNyZWRlbnRpYWxfcmVzcG9uc2UiLCJfY2hhbGxlbmdlIiwicmVzcG9uc2UiLCJjcmVkZW50aWFsX29wdGlvbnMiLCJfY2hhbGxlbmdlQW5kVmVyaWZ5IiwiY2hhbGxlbmdlRGF0YSIsImNoYWxsZW5nZUVycm9yIiwiX2xpc3RGYWN0b3JzIiwiZmFjdG9yIiwiZmFjdG9ycyIsIl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJjdXJyZW50TGV2ZWwiLCJhYWwiLCJuZXh0TGV2ZWwiLCJ2ZXJpZmllZEZhY3RvcnMiLCJmaWx0ZXIiLCJjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIiwiYW1yIiwiX2dldEF1dGhvcml6YXRpb25EZXRhaWxzIiwiYXV0aG9yaXphdGlvbklkIiwiX2FwcHJvdmVBdXRob3JpemF0aW9uIiwiYWN0aW9uIiwicmVkaXJlY3RfdXJsIiwiX2RlbnlBdXRob3JpemF0aW9uIiwiX2xpc3RPQXV0aEdyYW50cyIsIl9yZXZva2VPQXV0aEdyYW50IiwiY2xpZW50X2lkIiwiY2xpZW50SWQiLCJub1Jlc29sdmVKc29uIiwiZmV0Y2hKd2siLCJraWQiLCJqd2siLCJmaW5kIiwia2V5IiwiZ2V0Q2xhaW1zIiwiaGVhZGVyIiwicmF3IiwicmF3SGVhZGVyIiwicmF3UGF5bG9hZCIsImFsbG93RXhwaXJlZCIsInNpZ25pbmdLZXkiLCJhbGciLCJzdGFydHNXaXRoIiwiZ2xvYmFsVGhpcyIsImNyeXB0byIsImNsYWltcyIsImFsZ29yaXRobSIsInN1YnRsZSIsImltcG9ydEtleSIsImlzVmFsaWQiLCJ2ZXJpZnkiLCJjb25zdHJ1Y3RvciIsIm1lbW9yeVN0b3JhZ2UiLCJNYXAiLCJsb2ciLCJzZXR0aW5ncyIsIm5leHRJbnN0YW5jZUlEIiwidHJhY2UiLCJuYXZpZ2F0b3IiLCJsb2NrcyIsIm1mYSIsImJpbmQiLCJlbnJvbGwiLCJ1bmVucm9sbCIsImNoYWxsZW5nZSIsImxpc3RGYWN0b3JzIiwiY2hhbGxlbmdlQW5kVmVyaWZ5IiwiZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsIiwib2F1dGgiLCJnZXRBdXRob3JpemF0aW9uRGV0YWlscyIsImFwcHJvdmVBdXRob3JpemF0aW9uIiwiZGVueUF1dGhvcml6YXRpb24iLCJsaXN0R3JhbnRzIiwicmV2b2tlR3JhbnQiLCJsb2NhbFN0b3JhZ2UiLCJCcm9hZGNhc3RDaGFubmVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: function() { return /* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   AuthApiError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError; },\n/* harmony export */   AuthClient: function() { return /* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   AuthError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError; },\n/* harmony export */   AuthImplicitGrantRedirectError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError; },\n/* harmony export */   AuthInvalidCredentialsError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError; },\n/* harmony export */   AuthInvalidJwtError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError; },\n/* harmony export */   AuthInvalidTokenResponseError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError; },\n/* harmony export */   AuthPKCECodeVerifierMissingError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCECodeVerifierMissingError; },\n/* harmony export */   AuthPKCEGrantCodeExchangeError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError; },\n/* harmony export */   AuthRetryableFetchError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError; },\n/* harmony export */   AuthSessionMissingError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError; },\n/* harmony export */   AuthUnknownError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError; },\n/* harmony export */   AuthWeakPasswordError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError; },\n/* harmony export */   CustomAuthError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError; },\n/* harmony export */   GoTrueAdminApi: function() { return /* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   GoTrueClient: function() { return /* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   NavigatorLockAcquireTimeoutError: function() { return /* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError; },\n/* harmony export */   SIGN_OUT_SCOPES: function() { return /* reexport safe */ _lib_types__WEBPACK_IMPORTED_MODULE_4__.SIGN_OUT_SCOPES; },\n/* harmony export */   isAuthApiError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError; },\n/* harmony export */   isAuthError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError; },\n/* harmony export */   isAuthImplicitGrantRedirectError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError; },\n/* harmony export */   isAuthPKCECodeVerifierMissingError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthPKCECodeVerifierMissingError; },\n/* harmony export */   isAuthRetryableFetchError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError; },\n/* harmony export */   isAuthSessionMissingError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError; },\n/* harmony export */   isAuthWeakPasswordError: function() { return /* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError; },\n/* harmony export */   lockInternals: function() { return /* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals; },\n/* harmony export */   navigatorLock: function() { return /* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock; },\n/* harmony export */   processLock: function() { return /* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.processLock; }\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDSjtBQUNBO0FBQ0o7QUFDNEI7QUFDdEM7QUFDQztBQUMyRixDQUN4SCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzPzU1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCc7XG5pbXBvcnQgQXV0aEFkbWluQXBpIGZyb20gJy4vQXV0aEFkbWluQXBpJztcbmltcG9ydCBBdXRoQ2xpZW50IGZyb20gJy4vQXV0aENsaWVudCc7XG5leHBvcnQgeyBHb1RydWVBZG1pbkFwaSwgR29UcnVlQ2xpZW50LCBBdXRoQWRtaW5BcGksIEF1dGhDbGllbnQgfTtcbmV4cG9ydCAqIGZyb20gJy4vbGliL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgeyBuYXZpZ2F0b3JMb2NrLCBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgaW50ZXJuYWxzIGFzIGxvY2tJbnRlcm5hbHMsIHByb2Nlc3NMb2NrLCB9IGZyb20gJy4vbGliL2xvY2tzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkdvVHJ1ZUNsaWVudCIsIkF1dGhBZG1pbkFwaSIsIkF1dGhDbGllbnQiLCJuYXZpZ2F0b3JMb2NrIiwiTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJpbnRlcm5hbHMiLCJsb2NrSW50ZXJuYWxzIiwicHJvY2Vzc0xvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: function() { return /* binding */ base64UrlToUint8Array; },\n/* harmony export */   byteFromBase64URL: function() { return /* binding */ byteFromBase64URL; },\n/* harmony export */   byteToBase64URL: function() { return /* binding */ byteToBase64URL; },\n/* harmony export */   bytesToBase64URL: function() { return /* binding */ bytesToBase64URL; },\n/* harmony export */   codepointToUTF8: function() { return /* binding */ codepointToUTF8; },\n/* harmony export */   stringFromBase64URL: function() { return /* binding */ stringFromBase64URL; },\n/* harmony export */   stringFromUTF8: function() { return /* binding */ stringFromUTF8; },\n/* harmony export */   stringToBase64URL: function() { return /* binding */ stringToBase64URL; },\n/* harmony export */   stringToUTF8: function() { return /* binding */ stringToUTF8; },\n/* harmony export */   stringToUint8Array: function() { return /* binding */ stringToUint8Array; }\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error('Invalid Base64-URL character \"'.concat(String.fromCharCode(charCode), '\"'));\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(\"Unrecognized Unicode codepoint: \".concat(codepoint.toString(16)));\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onChar = (char)=>{\n        result.push(char);\n    };\n    bytes.forEach((byte)=>byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Q7OztDQUdDLEdBQ0QsTUFBTUEsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUIsVUFBV0QsS0FBSyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQixDQUFDO0lBQ3BCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTTtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeENGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHLENBQUM7SUFDbEI7SUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUosaUJBQWlCSyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNqREYsT0FBTyxDQUFDRixnQkFBZ0IsQ0FBQ0ksRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbEQ7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sYUFBYU8sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDN0NGLE9BQU8sQ0FBQ0osWUFBWSxDQUFDTSxFQUFFLENBQUNFLFVBQVUsQ0FBQyxHQUFHLEdBQUdGO0lBQzdDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNLLGdCQUFnQkMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDN0MsSUFBSUYsU0FBUyxNQUFNO1FBQ2ZDLE1BQU1FLEtBQUssR0FBRyxNQUFPQSxLQUFLLElBQUksSUFBS0g7UUFDbkNDLE1BQU1HLFVBQVUsSUFBSTtRQUNwQixNQUFPSCxNQUFNRyxVQUFVLElBQUksRUFBRztZQUMxQixNQUFNQyxNQUFNLE1BQU9GLEtBQUssSUFBS0YsTUFBTUcs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QVNJLGlCQUFpQkMsS0FBSztJQUNsQyxNQUFNTCxTQUFTLEVBQUU7SUFDakIsTUFBTW5DLFFBQVE7UUFBRUUsT0FBTztRQUFHQyxZQUFZO0lBQUU7SUFDeEMsTUFBTXNDLFNBQVMsQ0FBQzFCO1FBQ1pvQixPQUFPbkIsSUFBSSxDQUFDRDtJQUNoQjtJQUNBeUIsTUFBTUUsT0FBTyxDQUFDLENBQUMzQyxPQUFTRCxnQkFBZ0JDLE1BQU1DLE9BQU95QztJQUNyRCxxREFBcUQ7SUFDckQzQyxnQkFBZ0IsTUFBTUUsT0FBT3lDO0lBQzdCLE9BQU9OLE9BQU9qQixJQUFJLENBQUM7QUFDdkIsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9iYXNlNjR1cmwuanM/MTVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBieXRlIHRvIGEgQmFzZTY0LVVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGUgVGhlIGJ5dGUgdG8gY29udmVydCwgb3IgbnVsbCB0byBmbHVzaCBhdCB0aGUgZW5kIG9mIHRoZSBieXRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgY29udmVyc2lvbiBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBCYXNlNjQgY2hhcmFjdGVyIHdoZW4gcmVhZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoYnl0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA4KSB8IGJ5dGU7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjM7XG4gICAgICAgICAgICBlbWl0KFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5xdWV1ZWRCaXRzID4gMCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IHN0YXRlLnF1ZXVlIDw8ICg2IC0gc3RhdGUucXVldWVkQml0cyk7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFN0cmluZyBjaGFyIGNvZGUgKGV4dHJhY3RlZCB1c2luZyBgc3RyaW5nLmNoYXJDb2RlQXQocG9zaXRpb24pYCkgdG8gYSBzZXF1ZW5jZSBvZiBCYXNlNjQtVVJMIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGNoYXJDb2RlIFRoZSBjaGFyIGNvZGUgb2YgdGhlIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgc3RhdGUuIFBhc3MgYW4gaW5pdGlhbCB2YWx1ZSBvZiBgeyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9YC5cbiAqIEBwYXJhbSBlbWl0IEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVGcm9tQmFzZTY0VVJMKGNoYXJDb2RlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjaGFyQ29kZV07XG4gICAgaWYgKGJpdHMgPiAtMSkge1xuICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA2KSB8IGJpdHM7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gNjtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgZW1pdCgoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA4KSkgJiAweGZmKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaXRzID09PSAtMikge1xuICAgICAgICAvLyBpZ25vcmUgc3BhY2VzLCB0YWJzLCBuZXdsaW5lcywgPVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgXCIke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfVwiYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBjb25zdCBlbWl0dGVyID0gKGNoYXIpID0+IHtcbiAgICAgICAgYmFzZTY0LnB1c2goY2hhcik7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4ge1xuICAgICAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpO1xuICAgIH0pO1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUJhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBjb252ID0gW107XG4gICAgY29uc3QgdXRmOEVtaXQgPSAoY29kZXBvaW50KSA9PiB7XG4gICAgICAgIGNvbnYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlcG9pbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHV0ZjhTdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgY29uc3QgYjY0U3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3QgYnl0ZUVtaXQgPSAoYnl0ZSkgPT4ge1xuICAgICAgICBzdHJpbmdGcm9tVVRGOChieXRlLCB1dGY4U3RhdGUsIHV0ZjhFbWl0KTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBiNjRTdGF0ZSwgYnl0ZUVtaXQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGNvZGVwb2ludCB0byBhIG11bHRpLWJ5dGUgVVRGLTggc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIGNvZGVwb2ludCBUaGUgVW5pY29kZSBjb2RlcG9pbnQuXG4gKiBAcGFyYW0gZW1pdCAgICAgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2RlcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KSB7XG4gICAgaWYgKGNvZGVwb2ludCA8PSAweDdmKSB7XG4gICAgICAgIGVtaXQoY29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgZW1pdCgweGMwIHwgKGNvZGVwb2ludCA+PiA2KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBlbWl0KDB4ZTAgfCAoY29kZXBvaW50ID4+IDEyKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDEwZmZmZikge1xuICAgICAgICBlbWl0KDB4ZjAgfCAoY29kZXBvaW50ID4+IDE4KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgVW5pY29kZSBjb2RlcG9pbnQ6ICR7Y29kZXBvaW50LnRvU3RyaW5nKDE2KX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW1pdChieXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgICAgIGZvciAobGV0IGxlYWRpbmdCaXQgPSAxOyBsZWFkaW5nQml0IDwgNjsgbGVhZGluZ0JpdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKChieXRlID4+ICg3IC0gbGVhZGluZ0JpdCkpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDMxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID09PSA0KSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBzZXF1ZW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA+IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdG8gY29udmVydCBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyaW5ncyB0byBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3Qgb25CeXRlID0gKGJ5dGUpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlRnJvbUJhc2U2NFVSTChzdHIuY2hhckNvZGVBdChpKSwgc3RhdGUsIG9uQnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4gcmVzdWx0LnB1c2goYnl0ZSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjRVUkwoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkNoYXIgPSAoY2hhcikgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGJ5dGVzLmZvckVhY2goKGJ5dGUpID0+IGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgb25DaGFyKSk7XG4gICAgLy8gYWx3YXlzIGNhbGwgd2l0aCBgbnVsbGAgYWZ0ZXIgcHJvY2Vzc2luZyBhbGwgYnl0ZXNcbiAgICBieXRlVG9CYXNlNjRVUkwobnVsbCwgc3RhdGUsIG9uQ2hhcik7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NHVybC5qcy5tYXAiXSwibmFtZXMiOlsiVE9fQkFTRTY0VVJMIiwic3BsaXQiLCJJR05PUkVfQkFTRTY0VVJMIiwiRlJPTV9CQVNFNjRVUkwiLCJjaGFyTWFwIiwiQXJyYXkiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ5dGVUb0Jhc2U2NFVSTCIsImJ5dGUiLCJzdGF0ZSIsImVtaXQiLCJxdWV1ZSIsInF1ZXVlZEJpdHMiLCJwb3MiLCJieXRlRnJvbUJhc2U2NFVSTCIsImNoYXJDb2RlIiwiYml0cyIsIkVycm9yIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHIiLCJiYXNlNjQiLCJlbWl0dGVyIiwiY2hhciIsInB1c2giLCJzdHJpbmdUb1VURjgiLCJqb2luIiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsImNvbnYiLCJ1dGY4RW1pdCIsImNvZGVwb2ludCIsImZyb21Db2RlUG9pbnQiLCJ1dGY4U3RhdGUiLCJ1dGY4c2VxIiwiYjY0U3RhdGUiLCJieXRlRW1pdCIsInN0cmluZ0Zyb21VVEY4IiwiY29kZXBvaW50VG9VVEY4IiwidG9TdHJpbmciLCJoaWdoU3Vycm9nYXRlIiwibG93U3Vycm9nYXRlIiwibGVhZGluZ0JpdCIsImJhc2U2NFVybFRvVWludDhBcnJheSIsInJlc3VsdCIsIm9uQnl0ZSIsIlVpbnQ4QXJyYXkiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJieXRlc1RvQmFzZTY0VVJMIiwiYnl0ZXMiLCJvbkNoYXIiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: function() { return /* binding */ API_VERSIONS; },\n/* harmony export */   API_VERSION_HEADER_NAME: function() { return /* binding */ API_VERSION_HEADER_NAME; },\n/* harmony export */   AUDIENCE: function() { return /* binding */ AUDIENCE; },\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: function() { return /* binding */ AUTO_REFRESH_TICK_DURATION_MS; },\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: function() { return /* binding */ AUTO_REFRESH_TICK_THRESHOLD; },\n/* harmony export */   BASE64URL_REGEX: function() { return /* binding */ BASE64URL_REGEX; },\n/* harmony export */   DEFAULT_HEADERS: function() { return /* binding */ DEFAULT_HEADERS; },\n/* harmony export */   EXPIRY_MARGIN_MS: function() { return /* binding */ EXPIRY_MARGIN_MS; },\n/* harmony export */   GOTRUE_URL: function() { return /* binding */ GOTRUE_URL; },\n/* harmony export */   JWKS_TTL: function() { return /* binding */ JWKS_TTL; },\n/* harmony export */   NETWORK_FAILURE: function() { return /* binding */ NETWORK_FAILURE; },\n/* harmony export */   STORAGE_KEY: function() { return /* binding */ STORAGE_KEY; }\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": \"gotrue-js/\".concat(_version__WEBPACK_IMPORTED_MODULE_0__.version)\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDcEMsa0VBQWtFLEdBQzNELE1BQU1DLGdDQUFnQyxLQUFLLEtBQUs7QUFDdkQ7eUZBQ3lGLEdBQ2xGLE1BQU1DLDhCQUE4QixFQUFFO0FBQzdDOztDQUVDLEdBQ00sTUFBTUMsbUJBQW1CRCw4QkFBOEJELDhCQUE4QjtBQUNyRixNQUFNRyxhQUFhLHdCQUF3QjtBQUMzQyxNQUFNQyxjQUFjLHNCQUFzQjtBQUMxQyxNQUFNQyxXQUFXLEdBQUc7QUFDcEIsTUFBTUMsa0JBQWtCO0lBQUUsaUJBQWlCLGFBQXFCLE9BQVJQLDZDQUFPQTtBQUFHLEVBQUU7QUFDcEUsTUFBTVEsa0JBQWtCO0lBQzNCQyxhQUFhO0lBQ2JDLGdCQUFnQjtBQUNwQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCLHlCQUF5QjtBQUN6RCxNQUFNQyxlQUFlO0lBQ3hCLGNBQWM7UUFDVkMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSixFQUFFO0FBQ0ssTUFBTUMsa0JBQWtCLHVEQUF1RDtBQUMvRSxNQUFNQyxXQUFXLEtBQUssS0FBSyxLQUFLLENBQUMsYUFBYTtDQUNyRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanM/ZjA0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbi8qKiBDdXJyZW50IHNlc3Npb24gd2lsbCBiZSBjaGVja2VkIGZvciByZWZyZXNoIGF0IHRoaXMgaW50ZXJ2YWwuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMgPSAzMCAqIDEwMDA7XG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgPSAzO1xuLypcbiAqIEVhcmxpZXN0IHRpbWUgYmVmb3JlIGFuIGFjY2VzcyB0b2tlbiBleHBpcmVzIHRoYXQgdGhlIHNlc3Npb24gc2hvdWxkIGJlIHJlZnJlc2hlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEVYUElSWV9NQVJHSU5fTVMgPSBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgKiBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUztcbmV4cG9ydCBjb25zdCBHT1RSVUVfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OSc7XG5leHBvcnQgY29uc3QgU1RPUkFHRV9LRVkgPSAnc3VwYWJhc2UuYXV0aC50b2tlbic7XG5leHBvcnQgY29uc3QgQVVESUVOQ0UgPSAnJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYGdvdHJ1ZS1qcy8ke3ZlcnNpb259YCB9O1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfRkFJTFVSRSA9IHtcbiAgICBNQVhfUkVUUklFUzogMTAsXG4gICAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59O1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FID0gJ1gtU3VwYWJhc2UtQXBpLVZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgICAnMjAyNC0wMS0wMSc6IHtcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgICAgIG5hbWU6ICcyMDI0LTAxLTAxJyxcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBCQVNFNjRVUkxfUkVHRVggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9JHxbYS16MC05Xy1dezJ9JCkkL2k7XG5leHBvcnQgY29uc3QgSldLU19UVEwgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMiLCJBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQiLCJFWFBJUllfTUFSR0lOX01TIiwiR09UUlVFX1VSTCIsIlNUT1JBR0VfS0VZIiwiQVVESUVOQ0UiLCJERUZBVUxUX0hFQURFUlMiLCJORVRXT1JLX0ZBSUxVUkUiLCJNQVhfUkVUUklFUyIsIlJFVFJZX0lOVEVSVkFMIiwiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJBUElfVkVSU0lPTlMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwicGFyc2UiLCJuYW1lIiwiQkFTRTY0VVJMX1JFR0VYIiwiSldLU19UVEwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: function() { return /* binding */ AuthApiError; },\n/* harmony export */   AuthError: function() { return /* binding */ AuthError; },\n/* harmony export */   AuthImplicitGrantRedirectError: function() { return /* binding */ AuthImplicitGrantRedirectError; },\n/* harmony export */   AuthInvalidCredentialsError: function() { return /* binding */ AuthInvalidCredentialsError; },\n/* harmony export */   AuthInvalidJwtError: function() { return /* binding */ AuthInvalidJwtError; },\n/* harmony export */   AuthInvalidTokenResponseError: function() { return /* binding */ AuthInvalidTokenResponseError; },\n/* harmony export */   AuthPKCECodeVerifierMissingError: function() { return /* binding */ AuthPKCECodeVerifierMissingError; },\n/* harmony export */   AuthPKCEGrantCodeExchangeError: function() { return /* binding */ AuthPKCEGrantCodeExchangeError; },\n/* harmony export */   AuthRetryableFetchError: function() { return /* binding */ AuthRetryableFetchError; },\n/* harmony export */   AuthSessionMissingError: function() { return /* binding */ AuthSessionMissingError; },\n/* harmony export */   AuthUnknownError: function() { return /* binding */ AuthUnknownError; },\n/* harmony export */   AuthWeakPasswordError: function() { return /* binding */ AuthWeakPasswordError; },\n/* harmony export */   CustomAuthError: function() { return /* binding */ CustomAuthError; },\n/* harmony export */   isAuthApiError: function() { return /* binding */ isAuthApiError; },\n/* harmony export */   isAuthError: function() { return /* binding */ isAuthError; },\n/* harmony export */   isAuthImplicitGrantRedirectError: function() { return /* binding */ isAuthImplicitGrantRedirectError; },\n/* harmony export */   isAuthPKCECodeVerifierMissingError: function() { return /* binding */ isAuthPKCECodeVerifierMissingError; },\n/* harmony export */   isAuthRetryableFetchError: function() { return /* binding */ isAuthRetryableFetchError; },\n/* harmony export */   isAuthSessionMissingError: function() { return /* binding */ isAuthSessionMissingError; },\n/* harmony export */   isAuthWeakPasswordError: function() { return /* binding */ isAuthWeakPasswordError; }\n/* harmony export */ });\n/**\n * Base error thrown by Supabase Auth helpers.\n *\n * @example\n * ```ts\n * import { AuthError } from '@supabase/auth-js'\n *\n * throw new AuthError('Unexpected auth error', 500, 'unexpected')\n * ```\n */ class AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\n/**\n * Error returned directly from the GoTrue REST API.\n *\n * @example\n * ```ts\n * import { AuthApiError } from '@supabase/auth-js'\n *\n * throw new AuthApiError('Invalid credentials', 400, 'invalid_credentials')\n * ```\n */ class AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\n/**\n * Wraps non-standard errors so callers can inspect the root cause.\n *\n * @example\n * ```ts\n * import { AuthUnknownError } from '@supabase/auth-js'\n *\n * try {\n *   await someAuthCall()\n * } catch (err) {\n *   throw new AuthUnknownError('Auth failed', err)\n * }\n * ```\n */ class AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Flexible error class used to create named auth errors at runtime.\n *\n * @example\n * ```ts\n * import { CustomAuthError } from '@supabase/auth-js'\n *\n * throw new CustomAuthError('My custom auth error', 'MyAuthError', 400, 'custom_code')\n * ```\n */ class CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\n/**\n * Error thrown when an operation requires a session but none is present.\n *\n * @example\n * ```ts\n * import { AuthSessionMissingError } from '@supabase/auth-js'\n *\n * throw new AuthSessionMissingError()\n * ```\n */ class AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\n/**\n * Error thrown when the token response is malformed.\n *\n * @example\n * ```ts\n * import { AuthInvalidTokenResponseError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidTokenResponseError()\n * ```\n */ class AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\n/**\n * Error thrown when email/password credentials are invalid.\n *\n * @example\n * ```ts\n * import { AuthInvalidCredentialsError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidCredentialsError('Email or password is incorrect')\n * ```\n */ class AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\n/**\n * Error thrown when implicit grant redirects contain an error.\n *\n * @example\n * ```ts\n * import { AuthImplicitGrantRedirectError } from '@supabase/auth-js'\n *\n * throw new AuthImplicitGrantRedirectError('OAuth redirect failed', {\n *   error: 'access_denied',\n *   code: 'oauth_error',\n * })\n * ```\n */ class AuthImplicitGrantRedirectError extends CustomAuthError {\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\n/**\n * Error thrown during PKCE code exchanges.\n *\n * @example\n * ```ts\n * import { AuthPKCEGrantCodeExchangeError } from '@supabase/auth-js'\n *\n * throw new AuthPKCEGrantCodeExchangeError('PKCE exchange failed')\n * ```\n */ class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n}\n/**\n * Error thrown when the PKCE code verifier is not found in storage.\n * This typically happens when the auth flow was initiated in a different\n * browser, device, or the storage was cleared.\n *\n * @example\n * ```ts\n * import { AuthPKCECodeVerifierMissingError } from '@supabase/auth-js'\n *\n * throw new AuthPKCECodeVerifierMissingError()\n * ```\n */ class AuthPKCECodeVerifierMissingError extends CustomAuthError {\n    constructor(){\n        super(\"PKCE code verifier not found in storage. \" + \"This can happen if the auth flow was initiated in a different browser or device, \" + \"or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), \" + \"use @supabase/ssr on both the server and client to store the code verifier in cookies.\", \"AuthPKCECodeVerifierMissingError\", 400, \"pkce_code_verifier_not_found\");\n    }\n}\nfunction isAuthPKCECodeVerifierMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthPKCECodeVerifierMissingError\";\n}\n/**\n * Error thrown when a transient fetch issue occurs.\n *\n * @example\n * ```ts\n * import { AuthRetryableFetchError } from '@supabase/auth-js'\n *\n * throw new AuthRetryableFetchError('Service temporarily unavailable', 503)\n * ```\n */ class AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ /**\n * Error thrown when a supplied password is considered weak.\n *\n * @example\n * ```ts\n * import { AuthWeakPasswordError } from '@supabase/auth-js'\n *\n * throw new AuthWeakPasswordError('Password too short', 400, ['min_length'])\n * ```\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\n/**\n * Error thrown when a JWT cannot be verified or parsed.\n *\n * @example\n * ```ts\n * import { AuthInvalidJwtError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidJwtError('Token signature is invalid')\n * ```\n */ class AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUEsa0JBQWtCQztJQUMzQkMsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUMvQixLQUFLLENBQUNGO1FBQ04sSUFBSSxDQUFDRyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNPLFNBQVNHLFlBQVlDLEtBQUs7SUFDN0IsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxtQkFBbUJBO0FBQzdFO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUMscUJBQXFCVjtJQUM5QkUsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUMvQixLQUFLLENBQUNGLFNBQVNDLFFBQVFDO1FBQ3ZCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTTSxlQUFlRixLQUFLO0lBQ2hDLE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNSyx5QkFBeUJaO0lBQ2xDRSxZQUFZQyxPQUFPLEVBQUVVLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNWO1FBQ04sSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNNLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLHdCQUF3QmQ7SUFDakNFLFlB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SUFDekMsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTXlCLDRCQUE0QmxCO0lBQ3JDWixZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxTQUFTLHVCQUF1QixLQUFLO0lBQy9DO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9lcnJvcnMuanM/ZGRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgZXJyb3IgdGhyb3duIGJ5IFN1cGFiYXNlIEF1dGggaGVscGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoRXJyb3IoJ1VuZXhwZWN0ZWQgYXV0aCBlcnJvcicsIDUwMCwgJ3VuZXhwZWN0ZWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yO1xufVxuLyoqXG4gKiBFcnJvciByZXR1cm5lZCBkaXJlY3RseSBmcm9tIHRoZSBHb1RydWUgUkVTVCBBUEkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoQXBpRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJywgNDAwLCAnaW52YWxpZF9jcmVkZW50aWFscycpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuLyoqXG4gKiBXcmFwcyBub24tc3RhbmRhcmQgZXJyb3JzIHNvIGNhbGxlcnMgY2FuIGluc3BlY3QgdGhlIHJvb3QgY2F1c2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoVW5rbm93bkVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdHJ5IHtcbiAqICAgYXdhaXQgc29tZUF1dGhDYWxsKClcbiAqIH0gY2F0Y2ggKGVycikge1xuICogICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcignQXV0aCBmYWlsZWQnLCBlcnIpXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIEZsZXhpYmxlIGVycm9yIGNsYXNzIHVzZWQgdG8gY3JlYXRlIG5hbWVkIGF1dGggZXJyb3JzIGF0IHJ1bnRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDdXN0b21BdXRoRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQ3VzdG9tQXV0aEVycm9yKCdNeSBjdXN0b20gYXV0aCBlcnJvcicsICdNeUF1dGhFcnJvcicsIDQwMCwgJ2N1c3RvbV9jb2RlJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyZXMgYSBzZXNzaW9uIGJ1dCBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJztcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHRva2VuIHJlc3BvbnNlIGlzIG1hbGZvcm1lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGVtYWlsL3Bhc3N3b3JkIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignRW1haWwgb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBpbXBsaWNpdCBncmFudCByZWRpcmVjdHMgY29udGFpbiBhbiBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ09BdXRoIHJlZGlyZWN0IGZhaWxlZCcsIHtcbiAqICAgZXJyb3I6ICdhY2Nlc3NfZGVuaWVkJyxcbiAqICAgY29kZTogJ29hdXRoX2Vycm9yJyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gZHVyaW5nIFBLQ0UgY29kZSBleGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdQS0NFIGV4Y2hhbmdlIGZhaWxlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBQS0NFIGNvZGUgdmVyaWZpZXIgaXMgbm90IGZvdW5kIGluIHN0b3JhZ2UuXG4gKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gdGhlIGF1dGggZmxvdyB3YXMgaW5pdGlhdGVkIGluIGEgZGlmZmVyZW50XG4gKiBicm93c2VyLCBkZXZpY2UsIG9yIHRoZSBzdG9yYWdlIHdhcyBjbGVhcmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQS0NFIGNvZGUgdmVyaWZpZXIgbm90IGZvdW5kIGluIHN0b3JhZ2UuICcgK1xuICAgICAgICAgICAgJ1RoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYXV0aCBmbG93IHdhcyBpbml0aWF0ZWQgaW4gYSBkaWZmZXJlbnQgYnJvd3NlciBvciBkZXZpY2UsICcgK1xuICAgICAgICAgICAgJ29yIGlmIHRoZSBzdG9yYWdlIHdhcyBjbGVhcmVkLiBGb3IgU1NSIGZyYW1ld29ya3MgKE5leHQuanMsIFN2ZWx0ZUtpdCwgZXRjLiksICcgK1xuICAgICAgICAgICAgJ3VzZSBAc3VwYWJhc2Uvc3NyIG9uIGJvdGggdGhlIHNlcnZlciBhbmQgY2xpZW50IHRvIHN0b3JlIHRoZSBjb2RlIHZlcmlmaWVyIGluIGNvb2tpZXMuJywgJ0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yJywgNDAwLCAncGtjZV9jb2RlX3ZlcmlmaWVyX25vdF9mb3VuZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHRyYW5zaWVudCBmZXRjaCBpc3N1ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcignU2VydmljZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsIDUwMylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcic7XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHN1cHBsaWVkIHBhc3N3b3JkIGlzIGNvbnNpZGVyZWQgd2Vhay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhXZWFrUGFzc3dvcmRFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoJ1Bhc3N3b3JkIHRvbyBzaG9ydCcsIDQwMCwgWydtaW5fbGVuZ3RoJ10pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJztcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBKV1QgY2Fubm90IGJlIHZlcmlmaWVkIG9yIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbnZhbGlkSnd0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignVG9rZW4gc2lnbmF0dXJlIGlzIGludmFsaWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZEp3dEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZEp3dEVycm9yJywgNDAwLCAnaW52YWxpZF9qd3QnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIkF1dGhFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwiY29kZSIsIl9faXNBdXRoRXJyb3IiLCJuYW1lIiwiaXNBdXRoRXJyb3IiLCJlcnJvciIsIkF1dGhBcGlFcnJvciIsImlzQXV0aEFwaUVycm9yIiwiQXV0aFVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJDdXN0b21BdXRoRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsInVuZGVmaW5lZCIsImlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciIsIkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsInRvSlNPTiIsImRldGFpbHMiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIiwiaXNBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciIsIkF1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsInJlYXNvbnMiLCJpc0F1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: function() { return /* binding */ _generateLinkResponse; },\n/* harmony export */   _noResolveJsonResponse: function() { return /* binding */ _noResolveJsonResponse; },\n/* harmony export */   _request: function() { return /* binding */ _request; },\n/* harmony export */   _sessionResponse: function() { return /* binding */ _sessionResponse; },\n/* harmony export */   _sessionResponsePassword: function() { return /* binding */ _sessionResponsePassword; },\n/* harmony export */   _ssoResponse: function() { return /* binding */ _ssoResponse; },\n/* harmony export */   _userResponse: function() { return /* binding */ _userResponse; },\n/* harmony export */   handleError: function() { return /* binding */ handleError; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = \"Bearer \".concat(options.jwt);\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3FDO0FBQ21CO0FBQzZDO0FBQ3BJLE1BQU1XLG1CQUFtQixDQUFDQyxNQUFRQSxJQUFJQyxHQUFHLElBQUlELElBQUlFLE9BQU8sSUFBSUYsSUFBSUcsaUJBQWlCLElBQUlILElBQUlJLEtBQUssSUFBSUMsS0FBS0MsU0FBUyxDQUFDTjtBQUNqSCxNQUFNTyxzQkFBc0I7SUFBQztJQUFLO0lBQUs7Q0FBSTtBQUNwQyxlQUFlQyxZQUFZSixLQUFLO0lBQ25DLElBQUlLO0lBQ0osSUFBSSxDQUFDakIsZ0VBQXNCQSxDQUFDWSxRQUFRO1FBQ2hDLE1BQU0sSUFBSVQsNERBQXVCQSxDQUFDSSxpQkFBaUJLLFFBQVE7SUFDL0Q7SUFDQSxJQUFJRyxvQkFBb0JHLFFBQVEsQ0FBQ04sTUFBTU8sTUFBTSxHQUFHO1FBQzVDLDZFQUE2RTtRQUM3RSxNQUFNLElBQUloQiw0REFBdUJBLENBQUNJLGlCQUFpQkssUUFBUUEsTUFBTU8sTUFBTTtJQUMzRTtJQUNBLElBQUlDO0lBQ0osSUFBSTtRQUNBQSxPQUFPLE1BQU1SLE1BQU1TLElBQUk7SUFDM0IsRUFDQSxPQUFPQyxHQUFHO1FBQ04sTUFBTSxJQUFJakIscURBQWdCQSxDQUFDRSxpQkFBaUJlLElBQUlBO0lBQ3BEO0lBQ0EsSUFBSUMsWUFBWUM7SUFDaEIsTUFBTUMscUJBQXFCeEIsaUVBQXVCQSxDQUFDVztJQUNuRCxJQUFJYSxzQkFDQUEsbUJBQW1CQyxPQUFPLE1BQU03QixvREFBWSxDQUFDLGFBQWEsQ0FBQzhCLFNBQVMsSUFDcEUsT0FBT1AsU0FBUyxZQUNoQkEsUUFDQSxPQUFPQSxLQUFLUSxJQUFJLEtBQUssVUFBVTtRQUMvQkwsWUFBWUgsS0FBS1EsSUFBSTtJQUN6QixPQUNLLElBQUksT0FBT1IsU0FBUyxZ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QUNVLGFBQWEsR0FBR1YsS0FBS1UsYUFBYTtJQUNwRDtJQUNBLE9BQU8yQztBQUNYO0FBQ08sU0FBU0MsY0FBY3RELElBQUk7SUFDOUIsSUFBSUg7SUFDSixNQUFNc0QsT0FBTyxDQUFDdEQsS0FBS0csS0FBS21ELElBQUksTUFBTSxRQUFRdEQsT0FBTyxLQUFLLElBQUlBLEtBQUtHO0lBQy9ELE9BQU87UUFBRUEsTUFBTTtZQUFFbUQ7UUFBSztRQUFHM0QsT0FBTztJQUFLO0FBQ3pDO0FBQ08sU0FBUytELGFBQWF2RCxJQUFJO0lBQzdCLE9BQU87UUFBRUE7UUFBTVIsT0FBTztJQUFLO0FBQy9CO0FBQ08sU0FBU2dFLHNCQUFzQnhELElBQUk7SUFDdEMsTUFBTSxFQUFFeUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHN0QsTUFBTThELE9BQU90Riw2Q0FBTUEsQ0FBQ3dCLE1BQU07UUFBQztRQUFlO1FBQWE7UUFBZ0I7UUFBZTtLQUFvQjtJQUMzTCxNQUFNK0QsYUFBYTtRQUNmTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsTUFBTVYsT0FBTzFCLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0g5RCxNQUFNO1lBQ0YrRDtZQUNBWjtRQUNKO1FBQ0EzRCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVN3RSx1QkFBdUJoRSxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2dELFdBQVdoRCxJQUFJO0lBQ3BCLE9BQU9BLEtBQUtpRSxZQUFZLElBQUlqRSxLQUFLa0UsYUFBYSxJQUFJbEUsS0FBS2tELFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcz8wMjMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgQXV0aEFwaUVycm9yLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgQXV0aFdlYWtQYXNzd29yZEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICAgICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YDtcbiAgICB9XG4gICAgY29uc3QgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUbztcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCArIHF1ZXJ5U3RyaW5nLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uLFxuICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0pID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKGRhdGEpIDogeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3I6IG51bGwgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwgT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IF9fcmVzdChkYXRhLCBbXCJhY3Rpb25fbGlua1wiLCBcImVtYWlsX290cFwiLCBcImhhc2hlZF90b2tlblwiLCBcInJlZGlyZWN0X3RvXCIsIFwidmVyaWZpY2F0aW9uX3R5cGVcIl0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGFjdGlvbl9saW5rLFxuICAgICAgICBlbWFpbF9vdHAsXG4gICAgICAgIGhhc2hlZF90b2tlbixcbiAgICAgICAgcmVkaXJlY3RfdG8sXG4gICAgICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICAgIH07XG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJBUElfVkVSU0lPTlMiLCJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsImV4cGlyZXNBdCIsImxvb2tzTGlrZUZldGNoUmVzcG9uc2UiLCJwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiIsIkF1dGhBcGlFcnJvciIsIkF1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiQXV0aFdlYWtQYXNzd29yZEVycm9yIiwiQXV0aFVua25vd25FcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiX2dldEVycm9yTWVzc2FnZSIsImVyciIsIm1zZyIsIm1lc3NhZ2UiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIk5FVFdPUktfRVJST1JfQ09ERVMiLCJoYW5kbGVFcnJvciIsIl9hIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsImUiLCJlcnJvckNvZGUiLCJ1bmRlZmluZWQiLCJyZXNwb25zZUFQSVZlcnNpb24iLCJnZXRUaW1lIiwidGltZXN0YW1wIiwiY29kZSIsImVycm9yX2NvZGUiLCJ3ZWFrX3Bhc3N3b3JkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVhc29ucyIsImxlbmd0aCIsInJlZHVjZSIsImEiLCJpIiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJvcHRpb25zIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwiX3JlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwibmFtZSIsImp3dCIsInFzIiwicXVlcnkiLCJyZWRpcmVjdFRvIiwicXVlcnlTdHJpbmciLCJrZXlzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJfaGFuZGxlUmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJ4Zm9ybSIsInJlcXVlc3RQYXJhbXMiLCJyZXN1bHQiLCJjb25zb2xlIiwib2siLCJfc2Vzc2lvblJlc3BvbnNlIiwic2Vzc2lvbiIsImhhc1Nlc3Npb24iLCJleHBpcmVzX2F0IiwiZXhwaXJlc19pbiIsInVzZXIiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJyZXNwb25zZSIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJhY3Rpb25fbGluayIsImVtYWlsX290cCIsImhhc2hlZF90b2tlbiIsInJlZGlyZWN0X3RvIiwidmVyaWZpY2F0aW9uX3R5cGUiLCJyZXN0IiwicHJvcGVydGllcyIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: function() { return /* binding */ Deferred; },\n/* harmony export */   decodeJWT: function() { return /* binding */ decodeJWT; },\n/* harmony export */   deepClone: function() { return /* binding */ deepClone; },\n/* harmony export */   expiresAt: function() { return /* binding */ expiresAt; },\n/* harmony export */   generateCallbackId: function() { return /* binding */ generateCallbackId; },\n/* harmony export */   generatePKCEChallenge: function() { return /* binding */ generatePKCEChallenge; },\n/* harmony export */   generatePKCEVerifier: function() { return /* binding */ generatePKCEVerifier; },\n/* harmony export */   getAlgorithm: function() { return /* binding */ getAlgorithm; },\n/* harmony export */   getCodeChallengeAndMethod: function() { return /* binding */ getCodeChallengeAndMethod; },\n/* harmony export */   getItemAsync: function() { return /* binding */ getItemAsync; },\n/* harmony export */   insecureUserWarningProxy: function() { return /* binding */ insecureUserWarningProxy; },\n/* harmony export */   isBrowser: function() { return /* binding */ isBrowser; },\n/* harmony export */   looksLikeFetchResponse: function() { return /* binding */ looksLikeFetchResponse; },\n/* harmony export */   parseParametersFromURL: function() { return /* binding */ parseParametersFromURL; },\n/* harmony export */   parseResponseAPIVersion: function() { return /* binding */ parseResponseAPIVersion; },\n/* harmony export */   removeItemAsync: function() { return /* binding */ removeItemAsync; },\n/* harmony export */   resolveFetch: function() { return /* binding */ resolveFetch; },\n/* harmony export */   retryable: function() { return /* binding */ retryable; },\n/* harmony export */   setItemAsync: function() { return /* binding */ setItemAsync; },\n/* harmony export */   sleep: function() { return /* binding */ sleep; },\n/* harmony export */   supportsLocalStorage: function() { return /* binding */ supportsLocalStorage; },\n/* harmony export */   userNotAvailableProxy: function() { return /* binding */ userNotAvailableProxy; },\n/* harmony export */   validateExp: function() { return /* binding */ validateExp; },\n/* harmony export */   validateUUID: function() { return /* binding */ validateUUID; }\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\n/**\n * Generates a unique identifier for internal callback subscriptions.\n *\n * This function uses JavaScript Symbols to create guaranteed-unique identifiers\n * for auth state change callbacks. Symbols are ideal for this use case because:\n * - They are guaranteed unique by the JavaScript runtime\n * - They work in all environments (browser, SSR, Node.js)\n * - They avoid issues with Next.js 16 deterministic rendering requirements\n * - They are perfect for internal, non-serializable identifiers\n *\n * Note: This function is only used for internal subscription management,\n * not for security-critical operations like session tokens.\n */ function generateCallbackId() {\n    return Symbol(\"auth-callback\");\n}\nconst isBrowser = ()=> true && typeof document !== \"undefined\";\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = \"lswt-\".concat(Math.random()).concat(Math.random());\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return customFetch(...args);\n        };\n    }\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return fetch(...args);\n    };\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey) {\n    let isPasswordRecovery = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, \"\".concat(storageKey, \"-code-verifier\"), storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(\"\".concat(apiVersion, \"T00:00:00.0Z\"));\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error(\"@supabase/auth-js: Expected parameter to be UUID but is not\");\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop)=>{\n            if (prop === \"__isUserNotAvailableProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\") {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"'.concat(prop, '\" property of the session object is not supported. Please use getUser() instead.'));\n        },\n        set: (_target, prop)=>{\n            throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"'.concat(prop, '\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.'));\n        },\n        deleteProperty: (_target, prop)=>{\n            throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"'.concat(prop, '\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.'));\n        }\n    });\n}\n/**\n * Creates a proxy around a user object that warns when properties are accessed on the server.\n * This is used to alert developers that using user data from getSession() on the server is insecure.\n *\n * @param user The actual user object to wrap\n * @param suppressWarningRef An object with a 'value' property that controls warning suppression\n * @returns A proxied user object that warns on property access\n */ function insecureUserWarningProxy(user, suppressWarningRef) {\n    return new Proxy(user, {\n        get: (target, prop, receiver)=>{\n            // Allow internal checks without warning\n            if (prop === \"__isInsecureUserWarningProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\" || sProp === \"Symbol(nodejs.util.inspect.custom)\") {\n                    // Return the actual value for these symbols to allow proper inspection\n                    return Reflect.get(target, prop, receiver);\n                }\n            }\n            // Emit warning on first property access\n            if (!suppressWarningRef.value && typeof prop === \"string\") {\n                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                suppressWarningRef.value = true;\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */ function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDeEI7QUFDMEI7QUFDbEUsU0FBU0ssVUFBVUMsU0FBUztJQUMvQixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztJQUN4QyxPQUFPSixVQUFVRDtBQUNyQjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNNO0lBQ1osT0FBT0MsT0FBTztBQUNsQjtBQUNPLE1BQU1DLFlBQVksSUFBTSxLQUFrQixJQUFlLE9BQU9DLGFBQWEsWUFBWTtBQUNoRyxNQUFNQyx5QkFBeUI7SUFDM0JDLFFBQVE7SUFDUkMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDTSxNQUFNQyx1QkFBdUI7SUFDaEMsSUFBSSxDQUFDTCxhQUFhO1FBQ2QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLElBQUksT0FBT00sV0FBV0MsWUFBWSxLQUFLLFVBQVU7WUFDN0MsT0FBTztRQUNYO0lBQ0osRUFDQSxPQUFPQyxHQUFHO1FBQ04sOENBQThDO1FBQzlDLE9BQU87SUFDWDtJQUNBLElBQUlOLHVCQUF1QkMsTUFBTSxFQUFFO1FBQy9CLE9BQU9ELHVCQUF1QkUsUUFBUTtJQUMxQztJQUNBLE1BQU1LLFlBQVksUUFBd0JmLE9BQWhCQSxLQUFLZ0IsTUFBTSxJQUFtQixPQUFkaEIsS0FBS2dCLE1BQU07SUFDckQsSUFBSTtRQUNBSixXQUFXQyxZQUFZLENBQUNJLE9BQU8sQ0FBQ0YsV0FBV0E7UUFDM0NILFdBQVdDLFlBQVksQ0FBQ0ssVUFBVSxDQUFDSDtRQUNuQ1AsdUJBQXVCQyxNQUFNLEdBQUc7UUFDaENELHVCQUF1QkUsUUFBUSxHQUFHO0lBQ3RDLEVBQ0EsT0FBT0ksR0FBRztRQUNOLG1DQUFtQztRQUNuQywrS0FBK0s7UUFDL0tOLHVCQUF1QkMsTUFBTSxHQUFHO1FBQ2hDRCx1QkFBdUJFLFFBQVEsR0FBRztJQUN0QztJQUNBLE9BQU9GLHVCQUF1QkUsUUFBUTtBQUMxQyxFQUFFO0FBQ0Y7O0NBRUMsR0FDTSxTQUFTUyx1QkFBdUJDLElBQUk7SUFDdkMsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUMsSUFBSUg7SUFDcEIsSUFBSUUsSUFBSUUsSUFBSSxJQUFJRixJQUFJRSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUs7UUFDakMsSUFBSTtZQUNBLE1BQU1DLG1CQUFtQixJQUFJQyxnQkFBZ0JKLElBQUlFLElBQUksQ0FBQ0csU0FBUyxDQUFDO1lBQ2hFRixpQkFBaUJHLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztnQkFDN0JULE1BQU0sQ0FBQ1MsSUFBSSxHQUFHRDtZQUNsQjtRQUNKLEVBQ0EsT0FBT2YsR0FBRztRQUNOLDZCQUE2QjtRQUNqQztJQUNKO0lBQ0EseURBQXlEO0lBQ3pEUSxJQUFJUyxZQUFZLENBQUNILE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUM3QlQsTUFBTSxDQUFDUyxJQUFJLEdBQUdEO0lBQ2xCO0lBQ0EsT0FBT1I7QUFDWDtBQUNPLE1BQU1XLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUEsYUFBYTtRQUNiLE9BQU87NkNBQUlDO2dCQUFBQTs7bUJBQVNELGVBQWVDOztJQUN2QztJQUNBLE9BQU87eUNBQUlBO1lBQUFBOztlQUFTQyxTQUFTRDs7QUFDakMsRUFBRTtBQUNLLE1BQU1FLHlCQUF5QixDQUFDQztJQUNuQyxPQUFRLE9BQU9BLGtCQUFrQixZQUM3QkEsa0JBQWtCLFFBQ2xCLFlBQVlBLGlCQUNaLFFBQVFBLGlCQUNSLFVBQVVBLGlCQUNWLE9BQU9BLGNBQWNDLElBQUksS0FBSztBQUN0QyxFQUFFO0FBQ0Ysa0JBQWtCO0FBQ1gsTUFBTUMsZUFBZSxPQUFPQyxTQUFTVixLQUFLVztJQUM3QyxNQUFNRCxRQUFRdkIsT0FBTyxDQUFDYSxLQUFLWSxLQUFLQyxTQUFTLENBQUNGO0FBQzlDLEVBQUU7QUFDSyxNQUFNRyxlQUFlLE9BQU9KLFNBQVNWO0lBQ3hDLE1BQU1ELFFBQVEsTUFBTVcsUUFBUUssT0FBTyxDQUFDZjtJQUNwQyxJQUFJLENBQUNELE9BQU87UUFDUixPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsT0FBT2EsS0FBS0ksS0FBSyxDQUFDakI7SUFDdEIsRUFDQSxPQUFPa0IsSUFBSTtRQUNQLE9BQU9sQjtJQUNYO0FBQ0osRUFBRTtBQUNLLE1BQU1tQixrQkFBa0IsT0FBT1IsU0FBU1Y7SUFDM0MsTUFBTVUsUUFBUXRCLFVBQVUsQ0FBQ1k7QUFDN0IsRUFBRTtBQUNGOzs7O0NBSUMsR0FDTSxNQUFNbUI7SUFDVEMsYUFBYztRQUNWLDREQUE0RDs7UUFFNUQsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUYsU0FBU0csa0JBQWtCLENBQUMsQ0FBQ0MsS0FBS0M7WUFDakQsNERBQTREOztZQUU1RCxJQUFJLENBQUNDLE9BQU8sR0FBR0Y7WUFDZixJQUFJLENBQUNHLE1BQU0sR0FBR0Y7UUFDbEI7SUFDSjtBQUNKO0FBQ0FMLFNBQVNHLGtCQUFrQixHQUFHSztBQUN2QixTQUFTQyxVQUFVQyxLQUFLO0lBQzNCLE1BQU1DLFFBQVFELE1BQU1FLEtBQUssQ0FBQztJQUMxQixJQUFJRCxNQUFNRSxNQUFNLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUlwRSx3REFBbUJBLENBQUM7SUFDbEM7SUFDQSxvQ0FBb0M7SUFDcEMsSUFBSyxJQUFJcUUsSUFBSSxHQUFHQSxJQUFJSCxNQUFNRSxNQUFNLEVBQUVDLElBQUs7UUFDbkMsSUFBSSxDQUFDdEUsdURBQWVBLENBQUN1RSxJQUFJLENBQUNKLEtBQUssQ0FBQ0csRUFBRSxHQUFHO1lBQ2pDLE1BQU0sSUFBSXJFLHdEQUFtQkEsQ0FBQztRQUNsQztJQUNKO0lBQ0EsTUFBTStDLE9BQU87UUFDVCxzQkFBc0I7UUFDdEJ3QixRQUFRdkIsS0FBS0ksS0FBSyxDQUFDbEQsK0RBQW1CQSxDQUFDZ0UsS0FBSyxDQUFDLEVBQUU7UUFDL0NNLFNBQVN4QixLQUFLSSxLQUFLLENBQUNsRCwrREFBbUJBLENBQUNnRSxLQUFLLENBQUMsRUFBRTtRQUNoRE8sV0FBV3hFLGlFQUFxQkEsQ0FBQ2lFLEtBQUssQ0FBQyxFQUFFO1FBQ3pDUSxLQUFLO1lBQ0RILFFBQVFMLEtBQUssQ0FBQyxFQUFFO1lBQ2hCTSxTQUFTTixLQUFLLENBQUMsRUFBRTtRQUNyQjtJQUNKO0lBQ0EsT0FBT25CO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLGVBQWU0QixNQUFNQyxJQUFJO0lBQzVCLE9BQU8sTUFBTSxJQUFJYixRQUFRLENBQUNjO1FBQ3RCQyxXQUFXLElBQU1ELE9BQU8sT0FBT0Q7SUFDbkM7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTRyxVQUFVQyxFQUFFLEVBQUVDLFdBQVc7SUFDckMsTUFBTXhCLFVBQVUsSUFBSU0sUUFBUSxDQUFDYyxRQUFRZjtRQUNqQyw0REFBNEQ7O1FBRTNEO1lBQ0csSUFBSyxJQUFJb0IsVUFBVSxHQUFHQSxVQUFVQyxVQUFVRCxVQUFXO2dCQUNqRCxJQUFJO29CQUNBLE1BQU12RCxTQUFTLE1BQU1xRCxHQUFHRTtvQkFDeEIsSUFBSSxDQUFDRCxZQUFZQyxTQUFTLE1BQU12RCxTQUFTO3dCQUNyQ2tELE9BQU9sRDt3QkFDUDtvQkFDSjtnQkFDSixFQUNBLE9BQU9QLEdBQUc7b0JBQ04sSUFBSSxDQUFDNkQsWUFBWUMsU0FBUzlELElBQUk7d0JBQzFCMEMsT0FBTzFDO3dCQUNQO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3FDO0FBQ1g7QUFDQSxTQUFTMkIsUUFBUUMsR0FBRztJQUNoQixPQUFPLENBQUMsTUFBTUEsSUFBSUMsUUFBUSxDQUFDLEdBQUUsRUFBR0MsTUFBTSxDQUFDLENBQUM7QUFDNUM7QUFDQSwwSkFBMEo7QUFDbkosU0FBU0M7SUFDWixNQUFNQyxpQkFBaUI7SUFDdkIsTUFBTUMsUUFBUSxJQUFJQyxZQUFZRjtJQUM5QixJQUFJLE9BQU9HLFdBQVcsYUFBYTtRQUMvQixNQUFNQyxVQUFVO1FBQ2hCLE1BQU1DLGFBQWFELFFBQVF6QixNQUFNO1FBQ2pDLElBQUkyQixXQUFXO1FBQ2YsSUFBSyxJQUFJMUIsSUFBSSxHQUFHQSxJQUFJb0IsZ0JBQWdCcEIsSUFBSztZQUNyQzBCLFlBQVlGLFFBQVFHLE1BQU0sQ0FBQzFGLEtBQUsyRixLQUFLLENBQUMzRixLQUFLZ0IsTUFBTSxLQUFLd0U7UUFDMUQ7UUFDQSxPQUFPQztJQUNYO0lBQ0FILE9BQU9NLGVBQWUsQ0FBQ1I7SUFDdkIsT0FBT1MsTUFBTUMsSUFBSSxDQUFDVixPQUFPTixTQUFTaUIsSUFBSSxDQUFDO0FBQzNDO0FBQ0EsZUFBZUMsT0FBT0MsWUFBWTtJQUM5QixNQUFNQyxVQUFVLElBQUlDO0lBQ3BCLE1BQU1DLGNBQWNGLFFBQVFHLE1BQU0sQ0FBQ0o7SUFDbkMsTUFBTXpFLE9BQU8sTUFBTThELE9BQU9nQixNQUFNLENBQUNDLE1BQU0sQ0FBQyxXQUFXSDtJQUNuRCxNQUFNSSxRQUFRLElBQUlDLFdBQVdqRjtJQUM3QixPQUFPcUUsTUFBTUMsSUFBSSxDQUFDVSxPQUNiRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUMsT0FBT0MsWUFBWSxDQUFDRixJQUMvQlosSUFBSSxDQUFDO0FBQ2Q7QUFDTyxlQUFlZSxzQkFBc0JyQixRQUFRO0lBQ2hELE1BQU1zQixtQkFBbUIsT0FBT3pCLFdBQVcsZUFDdkMsT0FBT0EsT0FBT2dCLE1BQU0sS0FBSyxlQUN6QixPQUFPSCxnQkFBZ0I7SUFDM0IsSUFBSSxDQUFDWSxrQkFBa0I7UUFDbkJDLFFBQVFDLElBQUksQ0FBQztRQUNiLE9BQU94QjtJQUNYO0lBQ0EsTUFBTXlCLFNBQVMsTUFBTWxCLE9BQU9QO0lBQzVCLE9BQU8wQixLQUFLRCxRQUFRRSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsT0FBTztBQUMvRTtBQUNPLGVBQWVDLDBCQUEwQjdFLE9BQU8sRUFBRThFLFVBQVU7UUFBRUMscUJBQUFBLGlFQUFxQjtJQUN0RixNQUFNQyxlQUFldEM7SUFDckIsSUFBSXVDLHFCQUFxQkQ7SUFDekIsSUFBSUQsb0JBQW9CO1FBQ3BCRSxzQkFBc0I7SUFDMUI7SUFDQSxNQUFNbEYsYUFBYUMsU0FBUyxHQUFjLE9BQVg4RSxZQUFXLG1CQUFpQkc7SUFDM0QsTUFBTUMsZ0JBQWdCLE1BQU1aLHNCQUFzQlU7SUFDbEQsTUFBTUcsc0JBQXNCSCxpQkFBaUJFLGdCQUFnQixVQUFVO0lBQ3ZFLE9BQU87UUFBQ0E7UUFBZUM7S0FBb0I7QUFDL0M7QUFDQSxnREFBZ0QsR0FDaEQsTUFBTUMsb0JBQW9CO0FBQ25CLFNBQVNDLHdCQUF3QkMsUUFBUTtJQUM1QyxNQUFNQyxhQUFhRCxTQUFTRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ3pJLCtEQUF1QkE7SUFDL0QsSUFBSSxDQUFDdUksWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLElBQUksQ0FBQ0EsV0FBV0csS0FBSyxDQUFDTixvQkFBb0I7UUFDdEMsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE1BQU1PLE9BQU8sSUFBSWpJLEtBQUssR0FBYyxPQUFYNkgsWUFBVztRQUNwQyxPQUFPSTtJQUNYLEVBQ0EsT0FBT3JILEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVNzSCxZQUFZQyxHQUFHO0lBQzNCLElBQUksQ0FBQ0EsS0FBSztRQUNOLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU12SSxVQUFVQyxLQUFLMkYsS0FBSyxDQUFDekYsS0FBS0MsR0FBRyxLQUFLO0lBQ3hDLElBQUlrSSxPQUFPdEksU0FBUztRQUNoQixNQUFNLElBQUl1SSxNQUFNO0lBQ3BCO0FBQ0o7QUFDTyxTQUFTQyxhQUFhQyxHQUFHO0lBQzVCLE9BQVFBO1FBQ0osS0FBSztZQUNELE9BQU87Z0JBQ0hDLE1BQU07Z0JBQ05qSCxNQUFNO29CQUFFaUgsTUFBTTtnQkFBVTtZQUM1QjtRQUNKLEtBQUs7WUFDRCxPQUFPO2dCQUNIQSxNQUFNO2dCQUNOQyxZQUFZO2dCQUNabEgsTUFBTTtvQkFBRWlILE1BQU07Z0JBQVU7WUFDNUI7UUFDSjtZQUNJLE1BQU0sSUFBSUgsTUFBTTtJQUN4QjtBQUNKO0FBQ0EsTUFBTUssYUFBYTtBQUNaLFNBQVNDLGFBQWFDLEdBQUc7SUFDNUIsSUFBSSxDQUFDRixXQUFXM0UsSUFBSSxDQUFDNkUsTUFBTTtRQUN2QixNQUFNLElBQUlQLE1BQU07SUFDcEI7QUFDSjtBQUNPLFNBQVNRO0lBQ1osTUFBTUMsY0FBYyxDQUFDO0lBQ3JCLE9BQU8sSUFBSUMsTUFBTUQsYUFBYTtRQUMxQmQsS0FBSyxDQUFDZ0IsUUFBUUM7WUFDVixJQUFJQSxTQUFTLDZCQUE2QjtnQkFDdEMsT0FBTztZQUNYO1lBQ0EsOEVBQThFO1lBQzlFLG1GQUFtRjtZQUNuRixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDMUIsTUFBTUMsUUFBUUQsS0FBS2xFLFFBQVE7Z0JBQzNCLElBQUltRSxVQUFVLGdDQUNWQSxVQUFVLGdDQUNWQSxVQUFVLCtCQUErQjtvQkFDekMsdUJBQXVCO29CQUN2QixPQUFPQztnQkFDWDtZQUNKO1lBQ0EsTUFBTSxJQUFJZCxNQUFNLGtJQUF1SSxPQUFMWSxNQUFLO1FBQzNKO1FBQ0FHLEtBQUssQ0FBQ0MsU0FBU0o7WUFDWCxNQUFNLElBQUlaLE1BQU0sZ0lBQXFJLE9BQUxZLE1BQUs7UUFDeko7UUFDQUssZ0JBQWdCLENBQUNELFNBQVNKO1lBQ3RCLE1BQU0sSUFBSVosTUFBTSxpSUFBc0ksT0FBTFksTUFBSztRQUMxSjtJQUNKO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ00sU0FBU00seUJBQXlCQyxJQUFJLEVBQUVDLGtCQUFrQjtJQUM3RCxPQUFPLElBQUlWLE1BQU1TLE1BQU07UUFDbkJ4QixLQUFLLENBQUNnQixRQUFRQyxNQUFNUztZQUNoQix3Q0FBd0M7WUFDeEMsSUFBSVQsU0FBUyxnQ0FBZ0M7Z0JBQ3pDLE9BQU87WUFDWDtZQUNBLDhFQUE4RTtZQUM5RSxrRkFBa0Y7WUFDbEYsSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzFCLE1BQU1DLFFBQVFELEtBQUtsRSxRQUFRO2dCQUMzQixJQUFJbUUsVUFBVSxnQ0FDVkEsVUFBVSxnQ0FDVkEsVUFBVSxpQ0FDVkEsVUFBVSxzQ0FBc0M7b0JBQ2hELHVFQUF1RTtvQkFDdkUsT0FBT1MsUUFBUTNCLEdBQUcsQ0FBQ2dCLFFBQVFDLE1BQU1TO2dCQUNyQztZQUNKO1lBQ0Esd0NBQXdDO1lBQ3hDLElBQUksQ0FBQ0QsbUJBQW1CN0gsS0FBSyxJQUFJLE9BQU9xSCxTQUFTLFVBQVU7Z0JBQ3ZEbEMsUUFBUUMsSUFBSSxDQUFDO2dCQUNieUMsbUJBQW1CN0gsS0FBSyxHQUFHO1lBQy9CO1lBQ0EsT0FBTytILFFBQVEzQixHQUFHLENBQUNnQixRQUFRQyxNQUFNUztRQUNyQztJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxTQUFTRSxVQUFVQyxHQUFHO0lBQ3pCLE9BQU9wSCxLQUFLSSxLQUFLLENBQUNKLEtBQUtDLFNBQVMsQ0FBQ21IO0FBQ3JDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcz81YTY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FLCBCQVNFNjRVUkxfUkVHRVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBzdHJpbmdGcm9tQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW4pIHtcbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW47XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBpbnRlcm5hbCBjYWxsYmFjayBzdWJzY3JpcHRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBKYXZhU2NyaXB0IFN5bWJvbHMgdG8gY3JlYXRlIGd1YXJhbnRlZWQtdW5pcXVlIGlkZW50aWZpZXJzXG4gKiBmb3IgYXV0aCBzdGF0ZSBjaGFuZ2UgY2FsbGJhY2tzLiBTeW1ib2xzIGFyZSBpZGVhbCBmb3IgdGhpcyB1c2UgY2FzZSBiZWNhdXNlOlxuICogLSBUaGV5IGFyZSBndWFyYW50ZWVkIHVuaXF1ZSBieSB0aGUgSmF2YVNjcmlwdCBydW50aW1lXG4gKiAtIFRoZXkgd29yayBpbiBhbGwgZW52aXJvbm1lbnRzIChicm93c2VyLCBTU1IsIE5vZGUuanMpXG4gKiAtIFRoZXkgYXZvaWQgaXNzdWVzIHdpdGggTmV4dC5qcyAxNiBkZXRlcm1pbmlzdGljIHJlbmRlcmluZyByZXF1aXJlbWVudHNcbiAqIC0gVGhleSBhcmUgcGVyZmVjdCBmb3IgaW50ZXJuYWwsIG5vbi1zZXJpYWxpemFibGUgaWRlbnRpZmllcnNcbiAqXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBmb3IgaW50ZXJuYWwgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQsXG4gKiBub3QgZm9yIHNlY3VyaXR5LWNyaXRpY2FsIG9wZXJhdGlvbnMgbGlrZSBzZXNzaW9uIHRva2Vucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbGJhY2tJZCgpIHtcbiAgICByZXR1cm4gU3ltYm9sKCdhdXRoLWNhbGxiYWNrJyk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gICAgdGVzdGVkOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KTtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgICAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IChtYXliZVJlc3BvbnNlKSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2YgbWF5YmVSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICAgICAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICB0eXBlb2YgbWF5YmVSZXNwb25zZS5qc29uID09PSAnZnVuY3Rpb24nKTtcbn07XG4vLyBTdG9yYWdlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5LCBkYXRhKSA9PiB7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5KSA9PiB7XG4gICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG59O1xuLyoqXG4gKiBBIGRlZmVycmVkIHJlcHJlc2VudHMgc29tZSBhc3luY2hyb25vdXMgd29yayB0aGF0IGlzIG5vdCB5ZXQgZmluaXNoZWQsIHdoaWNoXG4gKiBtYXkgb3IgbWF5IG5vdCBjdWxtaW5hdGUgaW4gYSB2YWx1ZS5cbiAqIFRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9taWtlLW5vcnRoL3R5cGVzL2Jsb2IvbWFzdGVyL3NyYy9hc3luYy50c1xuICovXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZTtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVKV1QodG9rZW4pIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignSW52YWxpZCBKV1Qgc3RydWN0dXJlJyk7XG4gICAgfVxuICAgIC8vIFJlZ2V4IGNoZWNrcyBmb3IgYmFzZTY0dXJsIGZvcm1hdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFCQVNFNjRVUkxfUkVHRVgudGVzdChwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdKV1Qgbm90IGluIGJhc2U2NHVybCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAvLyB1c2luZyBiYXNlNjR1cmwgbGliXG4gICAgICAgIGhlYWRlcjogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzBdKSksXG4gICAgICAgIHBheWxvYWQ6IEpTT04ucGFyc2Uoc3RyaW5nRnJvbUJhc2U2NFVSTChwYXJ0c1sxXSkpLFxuICAgICAgICBzaWduYXR1cmU6IGJhc2U2NFVybFRvVWludDhBcnJheShwYXJ0c1syXSksXG4gICAgICAgIHJhdzoge1xuICAgICAgICAgICAgaGVhZGVyOiBwYXJ0c1swXSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBhcnRzWzFdLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbnVsbCBhZnRlciBzb21lIHRpbWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChhY2NlcHQpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhY2NlcHQobnVsbCksIHRpbWUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXN5bmMgZnVuY3Rpb24gaW50byBhIHJldHJ5YWJsZSBmdW5jdGlvbi4gRWFjaCByZXN1bHRcbiAqIG9yIHRocm93biBlcnJvciBpcyBzZW50IHRvIHRoZSBpc1JldHJ5YWJsZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0dXJuIHRydWVcbiAqIGlmIHRoZSBmdW5jdGlvbiBzaG91bGQgcnVuIGFnYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlhYmxlKGZuLCBpc1JldHJ5YWJsZSkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgIDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgSW5maW5pdHk7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIG51bGwsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRlYzJoZXgoZGVjKSB7XG4gICAgcmV0dXJuICgnMCcgKyBkZWMudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpO1xufVxuLy8gRnVuY3Rpb25zIGJlbG93IHRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMzA5NDA5L2NyZWF0aW5nLWEtY29kZS12ZXJpZmllci1hbmQtY2hhbGxlbmdlLWZvci1wa2NlLWF1dGgtb24tc3BvdGlmeS1hcGktaW4tcmVhY3Rqc1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUEtDRVZlcmlmaWVyKCkge1xuICAgIGNvbnN0IHZlcmlmaWVyTGVuZ3RoID0gNTY7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkodmVyaWZpZXJMZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBjaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LS5ffic7XG4gICAgICAgIGNvbnN0IGNoYXJTZXRMZW4gPSBjaGFyU2V0Lmxlbmd0aDtcbiAgICAgICAgbGV0IHZlcmlmaWVyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyaWZpZXJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVyaWZpZXIgKz0gY2hhclNldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhclNldExlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJpZmllcjtcbiAgICB9XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGRlYzJoZXgpLmpvaW4oJycpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2hhMjU2KHJhbmRvbVN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGVuY29kZXIuZW5jb2RlKHJhbmRvbVN0cmluZyk7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2RlZERhdGEpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgICAgIC5tYXAoKGMpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYykpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UodmVyaWZpZXIpIHtcbiAgICBjb25zdCBoYXNDcnlwdG9TdXBwb3J0ID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKCFoYXNDcnlwdG9TdXBwb3J0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2ViQ3J5cHRvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBDb2RlIGNoYWxsZW5nZSBtZXRob2Qgd2lsbCBkZWZhdWx0IHRvIHVzZSBwbGFpbiBpbnN0ZWFkIG9mIHNoYTI1Ni4nKTtcbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBhd2FpdCBzaGEyNTYodmVyaWZpZXIpO1xuICAgIHJldHVybiBidG9hKGhhc2hlZCkucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPSskLywgJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2Qoc3RvcmFnZSwgc3RvcmFnZUtleSwgaXNQYXNzd29yZFJlY292ZXJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpO1xuICAgIGxldCBzdG9yZWRDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXI7XG4gICAgaWYgKGlzUGFzc3dvcmRSZWNvdmVyeSkge1xuICAgICAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSc7XG4gICAgfVxuICAgIGF3YWl0IHNldEl0ZW1Bc3luYyhzdG9yYWdlLCBgJHtzdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCwgc3RvcmVkQ29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gYXdhaXQgZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKGNvZGVWZXJpZmllcik7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZU1ldGhvZCA9IGNvZGVWZXJpZmllciA9PT0gY29kZUNoYWxsZW5nZSA/ICdwbGFpbicgOiAnczI1Nic7XG4gICAgcmV0dXJuIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXTtcbn1cbi8qKiBQYXJzZXMgdGhlIEFQSSB2ZXJzaW9uIHdoaWNoIGlzIDJZWVktTU0tREQuICovXG5jb25zdCBBUElfVkVSU0lPTl9SRUdFWCA9IC9eMlswLTldezN9LSgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFbMC05XXwyWzAtOV18M1swLTFdKSQvaTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZSkge1xuICAgIGNvbnN0IGFwaVZlcnNpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChBUElfVkVSU0lPTl9IRUFERVJfTkFNRSk7XG4gICAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7YXBpVmVyc2lvbn1UMDA6MDA6MDAuMFpgKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV4cChleHApIHtcbiAgICBpZiAoIWV4cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZXhwIGNsYWltJyk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICBpZiAoZXhwIDw9IHRpbWVOb3cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaGFzIGV4cGlyZWQnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxnb3JpdGhtKGFsZykge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1JTMjU2JzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICAgICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgICAgICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWxnIGNsYWltJyk7XG4gICAgfVxufVxuY29uc3QgVVVJRF9SRUdFWCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC87XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVVUlEKHN0cikge1xuICAgIGlmICghVVVJRF9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogRXhwZWN0ZWQgcGFyYW1ldGVyIHRvIGJlIFVVSUQgYnV0IGlzIG5vdCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VyTm90QXZhaWxhYmxlUHJveHkoKSB7XG4gICAgY29uc3QgcHJveHlUYXJnZXQgPSB7fTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHByb3h5VGFyZ2V0LCB7XG4gICAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJldmVudGF0aXZlIGNoZWNrIGZvciBjb21tb24gcHJvYmxlbWF0aWMgc3ltYm9scyBkdXJpbmcgY2xvbmluZy9pbnNwZWN0aW9uXG4gICAgICAgICAgICAvLyBUaGVzZSBzeW1ib2xzIG1pZ2h0IGJlIGFjY2Vzc2VkIGJ5IHN0cnVjdHVyZWRDbG9uZSBvciBvdGhlciBpbnRlcm5hbCBtZWNoYW5pc21zLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNQcm9wID0gcHJvcC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9QcmltaXRpdmUpJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9TdHJpbmdUYWcpJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbCh1dGlsLmluc3BlY3QuY3VzdG9tKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZS5qcyB1dGlsLmluc3BlY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBBY2Nlc3NpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSBpbnN0ZWFkLmApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBTZXR0aW5nIHRoZSBcIiR7cHJvcH1cIiBwcm9wZXJ0eSBvZiB0aGUgc2Vzc2lvbiBvYmplY3QgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBnZXRVc2VyKCkgdG8gZmV0Y2ggYSB1c2VyIG9iamVjdCB5b3UgY2FuIG1hbmlwdWxhdGUuYCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVByb3BlcnR5OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogY2xpZW50IHdhcyBjcmVhdGVkIHdpdGggdXNlclN0b3JhZ2Ugb3B0aW9uIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBzdG9yZWQgaW4gdGhlIHVzZXIgc3RvcmFnZS4gRGVsZXRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IGFyb3VuZCBhIHVzZXIgb2JqZWN0IHRoYXQgd2FybnMgd2hlbiBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZCBvbiB0aGUgc2VydmVyLlxuICogVGhpcyBpcyB1c2VkIHRvIGFsZXJ0IGRldmVsb3BlcnMgdGhhdCB1c2luZyB1c2VyIGRhdGEgZnJvbSBnZXRTZXNzaW9uKCkgb24gdGhlIHNlcnZlciBpcyBpbnNlY3VyZS5cbiAqXG4gKiBAcGFyYW0gdXNlciBUaGUgYWN0dWFsIHVzZXIgb2JqZWN0IHRvIHdyYXBcbiAqIEBwYXJhbSBzdXBwcmVzc1dhcm5pbmdSZWYgQW4gb2JqZWN0IHdpdGggYSAndmFsdWUnIHByb3BlcnR5IHRoYXQgY29udHJvbHMgd2FybmluZyBzdXBwcmVzc2lvblxuICogQHJldHVybnMgQSBwcm94aWVkIHVzZXIgb2JqZWN0IHRoYXQgd2FybnMgb24gcHJvcGVydHkgYWNjZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkodXNlciwgc3VwcHJlc3NXYXJuaW5nUmVmKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh1c2VyLCB7XG4gICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIEFsbG93IGludGVybmFsIGNoZWNrcyB3aXRob3V0IHdhcm5pbmdcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnX19pc0luc2VjdXJlVXNlcldhcm5pbmdQcm94eScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnRhdGl2ZSBjaGVjayBmb3IgY29tbW9uIHByb2JsZW1hdGljIHN5bWJvbHMgZHVyaW5nIGNsb25pbmcvaW5zcGVjdGlvblxuICAgICAgICAgICAgLy8gVGhlc2Ugc3ltYm9scyBtaWdodCBiZSBhY2Nlc3NlZCBieSBzdHJ1Y3R1cmVkQ2xvbmUgb3Igb3RoZXIgaW50ZXJuYWwgbWVjaGFuaXNtc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNQcm9wID0gcHJvcC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9QcmltaXRpdmUpJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9TdHJpbmdUYWcpJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbCh1dGlsLmluc3BlY3QuY3VzdG9tKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2wobm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20pJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCB2YWx1ZSBmb3IgdGhlc2Ugc3ltYm9scyB0byBhbGxvdyBwcm9wZXIgaW5zcGVjdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW1pdCB3YXJuaW5nIG9uIGZpcnN0IHByb3BlcnR5IGFjY2Vzc1xuICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmdSZWYudmFsdWUgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVc2luZyB0aGUgdXNlciBvYmplY3QgYXMgcmV0dXJuZWQgZnJvbSBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKSBvciBmcm9tIHNvbWUgc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgpIGV2ZW50cyBjb3VsZCBiZSBpbnNlY3VyZSEgVGhpcyB2YWx1ZSBjb21lcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIG1lZGl1bSAodXN1YWxseSBjb29raWVzIG9uIHRoZSBzZXJ2ZXIpIGFuZCBtYXkgbm90IGJlIGF1dGhlbnRpYy4gVXNlIHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpIGluc3RlYWQgd2hpY2ggYXV0aGVudGljYXRlcyB0aGUgZGF0YSBieSBjb250YWN0aW5nIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlci4nKTtcbiAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmdSZWYudmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBEZWVwIGNsb25lcyBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCB1c2luZyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpLlxuICogTm90ZTogT25seSB3b3JrcyBmb3IgSlNPTi1zYWZlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsIkJBU0U2NFVSTF9SRUdFWCIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJiYXNlNjRVcmxUb1VpbnQ4QXJyYXkiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiZXhwaXJlc0F0IiwiZXhwaXJlc0luIiwidGltZU5vdyIsIk1hdGgiLCJyb3VuZCIsIkRhdGUiLCJub3ciLCJnZW5lcmF0ZUNhbGxiYWNrSWQiLCJTeW1ib2wiLCJpc0Jyb3dzZXIiLCJkb2N1bWVudCIsImxvY2FsU3RvcmFnZVdyaXRlVGVzdHMiLCJ0ZXN0ZWQiLCJ3cml0YWJsZSIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsImxvY2FsU3RvcmFnZSIsImUiLCJyYW5kb21LZXkiLCJyYW5kb20iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJocmVmIiwicmVzdWx0IiwidXJsIiwiVVJMIiwiaGFzaCIsImhhc2hTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzdWJzdHJpbmciLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJzZWFyY2hQYXJhbXMiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsImxvb2tzTGlrZUZldGNoUmVzcG9uc2UiLCJtYXliZVJlc3BvbnNlIiwianNvbiIsInNldEl0ZW1Bc3luYyIsInN0b3JhZ2UiLCJkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEl0ZW1Bc3luYyIsImdldEl0ZW0iLCJwYXJzZSIsIl9hIiwicmVtb3ZlSXRlbUFzeW5jIiwiRGVmZXJyZWQiLCJjb25zdHJ1Y3RvciIsInByb21pc2UiLCJwcm9taXNlQ29uc3RydWN0b3IiLCJyZXMiLCJyZWoiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsImRlY29kZUpXVCIsInRva2VuIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsImkiLCJ0ZXN0IiwiaGVhZGVyIiwicGF5bG9hZCIsInNpZ25hdHVyZSIsInJhdyIsInNsZWVwIiwidGltZSIsImFjY2VwdCIsInNldFRpbWVvdXQiLCJyZXRyeWFibGUiLCJmbiIsImlzUmV0cnlhYmxlIiwiYXR0ZW1wdCIsIkluZmluaXR5IiwiZGVjMmhleCIsImRlYyIsInRvU3RyaW5nIiwic3Vic3RyIiwiZ2VuZXJhdGVQS0NFVmVyaWZpZXIiLCJ2ZXJpZmllckxlbmd0aCIsImFycmF5IiwiVWludDMyQXJyYXkiLCJjcnlwdG8iLCJjaGFyU2V0IiwiY2hhclNldExlbiIsInZlcmlmaWVyIiwiY2hhckF0IiwiZmxvb3IiLCJnZXRSYW5kb21WYWx1ZXMiLCJBcnJheSIsImZyb20iLCJqb2luIiwic2hhMjU2IiwicmFuZG9tU3RyaW5nIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlZERhdGEiLCJlbmNvZGUiLCJzdWJ0bGUiLCJkaWdlc3QiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJtYXAiLCJjIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlIiwiaGFzQ3J5cHRvU3VwcG9ydCIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzaGVkIiwiYnRvYSIsInJlcGxhY2UiLCJnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kIiwic3RvcmFnZUtleSIsImlzUGFzc3dvcmRSZWNvdmVyeSIsImNvZGVWZXJpZmllciIsInN0b3JlZENvZGVWZXJpZmllciIsImNvZGVDaGFsbGVuZ2UiLCJjb2RlQ2hhbGxlbmdlTWV0aG9kIiwiQVBJX1ZFUlNJT05fUkVHRVgiLCJwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiIsInJlc3BvbnNlIiwiYXBpVmVyc2lvbiIsImhlYWRlcnMiLCJnZXQiLCJtYXRjaCIsImRhdGUiLCJ2YWxpZGF0ZUV4cCIsImV4cCIsIkVycm9yIiwiZ2V0QWxnb3JpdGhtIiwiYWxnIiwibmFtZSIsIm5hbWVkQ3VydmUiLCJVVUlEX1JFR0VYIiwidmFsaWRhdGVVVUlEIiwic3RyIiwidXNlck5vdEF2YWlsYWJsZVByb3h5IiwicHJveHlUYXJnZXQiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJzUHJvcCIsInVuZGVmaW5lZCIsInNldCIsIl90YXJnZXQiLCJkZWxldGVQcm9wZXJ0eSIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsInVzZXIiLCJzdXBwcmVzc1dhcm5pbmdSZWYiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJkZWVwQ2xvbmUiLCJvYmoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoryLocalStorageAdapter: function() { return /* binding */ memoryLocalStorageAdapter; }\n/* harmony export */ });\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter() {\n    let store = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBQ00sU0FBU0E7UUFBMEJDLFFBQUFBLGlFQUFRLENBQUM7SUFDL0MsT0FBTztRQUNIQyxTQUFTLENBQUNDO1lBQ04sT0FBT0YsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDekI7UUFDQUMsU0FBUyxDQUFDRCxLQUFLRTtZQUNYSixLQUFLLENBQUNFLElBQUksR0FBR0U7UUFDakI7UUFDQUMsWUFBWSxDQUFDSDtZQUNULE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNyQjtJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9sb2NhbC1zdG9yYWdlLmpzPzIzYzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxTdG9yYWdlLWxpa2Ugb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBrZXktdmFsdWUgcGFpcnMgaW5cbiAqIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmUgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbC1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwic3RvcmUiLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInZhbHVlIiwicmVtb3ZlSXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: function() { return /* binding */ LockAcquireTimeoutError; },\n/* harmony export */   NavigatorLockAcquireTimeoutError: function() { return /* binding */ NavigatorLockAcquireTimeoutError; },\n/* harmony export */   ProcessLockAcquireTimeoutError: function() { return /* binding */ ProcessLockAcquireTimeoutError; },\n/* harmony export */   internals: function() { return /* binding */ internals; },\n/* harmony export */   navigatorLock: function() { return /* binding */ navigatorLock; },\n/* harmony export */   processLock: function() { return /* binding */ processLock; }\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError('Acquiring an exclusive Navigator LockManager lock \"'.concat(name, '\" immediately failed'));\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                console.warn('@supabase/gotrue-js: Lock \"'.concat(name, '\" acquisition timed out after ').concat(acquireTimeout, \"ms. \") + \"This may be caused by another operation holding the lock. \" + \"Consider increasing lockAcquireTimeout or checking for stuck operations.\");\n                reject(new ProcessLockAcquireTimeoutError('Acquiring process lock with name \"'.concat(name, '\" timed out')));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNqRDs7Q0FFQyxHQUNNLE1BQU1DLFlBQVk7SUFDckI7O0tBRUMsR0FDREMsT0FBTyxDQUFDLENBQUVDLENBQUFBLGNBQ05ILDhEQUFvQkEsTUFDcEJHLFdBQVdDLFlBQVksSUFDdkJELFdBQVdDLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLHNDQUFzQyxNQUFLO0FBQ25GLEVBQUU7QUFDRjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNQyxnQ0FBZ0NDO0lBQ3pDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7SUFDNUI7QUFDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLHlDQUF5Q0w7QUFDdEQ7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNTSx1Q0FBdUNOO0FBQ3BEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQyxHQUNNLGVBQWVPLGNBQWNDLElBQUksRUFBRUMsY0FBYyxFQUFFQyxFQUFFO0lBQ3hELElBQUlmLFVBQVVDLEtBQUssRUFBRTtRQUNqQmUsUUFBUUMsR0FBRyxDQUFDLG9EQUFvREosTUFBTUM7SUFDMUU7SUFDQSxNQUFNSSxrQkFBa0IsSUFBSWhCLFdBQVdpQixlQUFlO0lBQ3RELElBQUlMLGlCQUFpQixHQUFHO1FBQ3BCTSxXQUFXO1lBQ1BGLGdCQUFnQkcsS0FBSztZQUNyQixJQUFJckIsVUFBVUMsS0FBSyxFQUFFO2dCQUNqQmUsUUFBUUMsR0FBRyxDQUFDLHdEQUF3REo7WUFDeEU7UUFDSixHQUFHQztJQUNQO0lBQ0Esb0ZBQW9GO0lBQ3BGLDBFQUEwRTtJQUMxRSx5RUFBeUU7SUFDekUsMEVBQTBFO0lBQzFFLDJFQUEyRTtJQUMzRSw2RUFBNkU7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TDtJQUNWO0lBQ0EseUVBQXlFO0lBQ3pFLHlDQUF5QztJQUN6QyxPQUFPLE1BQU1NO0FBQ2pCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanM/MDM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycyc7XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZGVidWc6ICEhKGdsb2JhbFRoaXMgJiZcbiAgICAgICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWcnKSA9PT0gJ3RydWUnKSxcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogY2xhc3MgQ3VzdG9tTG9ja0Vycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcignTG9jayB0aW1lZCBvdXQnKVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaXNBY3F1aXJlVGltZW91dCA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgYnJvd3NlciBOYXZpZ2F0b3IgTG9jayBBUEkgZmFpbHMgdG8gYWNxdWlyZSBhIGxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcignTG9jayB0aW1lZCBvdXQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHByb2Nlc3MtbGV2ZWwgbG9jayBoZWxwZXIgY2Fubm90IGFjcXVpcmUgYSBsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcignTG9jayB0aW1lZCBvdXQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogYXdhaXQgbmF2aWdhdG9yTG9jaygnc3luYy11c2VyJywgMTAwMCwgYXN5bmMgKCkgPT4ge1xuICogICBhd2FpdCByZWZyZXNoU2Vzc2lvbigpXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0b3JMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmUgbG9jaycsIG5hbWUsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgaWYgKGFjcXVpcmVUaW1lb3V0ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrIGFjcXVpcmUgdGltZWQgb3V0JywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KTtcbiAgICB9XG4gICAgLy8gTUROIGFydGljbGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0XG4gICAgLy8gV3JhcHBpbmcgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSB3aXRoIGEgcGxhaW4gUHJvbWlzZSBpcyBkb25lIGFzIHNvbWVcbiAgICAvLyBsaWJyYXJpZXMgbGlrZSB6b25lLmpzIHBhdGNoIHRoZSBQcm9taXNlIG9iamVjdCB0byB0cmFjayB0aGUgZXhlY3V0aW9uXG4gICAgLy8gY29udGV4dC4gSG93ZXZlciwgaXQgYXBwZWFycyB0aGF0IG1vc3QgYnJvd3NlcnMgdXNlIGFuIGludGVybmFsIHByb21pc2VcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiB3aGVuIHVzaW5nIHRoZSBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIEFQSSBjYXVzaW5nIHRoZW1cbiAgICAvLyB0byBsb3NlIGNvbnRleHQgYW5kIGVtaXQgY29uZnVzaW5nIGxvZyBtZXNzYWdlcyBvciBicmVhayBjZXJ0YWluIGZlYXR1cmVzLlxuICAgIC8vIFRoaXMgd3JhcHBpbmcgaXMgYmVsaWV2ZWQgdG8gaGVscCB6b25lLmpzIHRyYWNrIHRoZSBleGVjdXRpb24gY29udGV4dFxuICAgIC8vIGJldHRlci5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KG5hbWUsIGFjcXVpcmVUaW1lb3V0ID09PSAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBpZkF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9LCBhc3luYyAobG9jaykgPT4ge1xuICAgICAgICBpZiAobG9jaykge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogcmVsZWFzZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhY3F1aXJlVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKGBBY3F1aXJpbmcgYW4gZXhjbHVzaXZlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBsb2NrIFwiJHtuYW1lfVwiIGltbWVkaWF0ZWx5IGZhaWxlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBFcnJvciB3aGVuIHF1ZXJ5aW5nIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHNwZWMsIGl0XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB3ZSBkaWRuJ3QgdXNlIGlmQXZhaWxhYmxlLiBTbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAvLyBhbmQgdXNlciBleHBlcmllbmNlIGFuZCBqdXN0IHJ1biB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB1c2luZyAjcmVxdWVzdCB3aXRob3V0IGlmQXZhaWxhYmxlIHNldCB0byB0cnVlLCBpdCBhcHBlYXJzIHRoaXMgYnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBMb2NrTWFuYWdlciBzcGVjIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG59XG5jb25zdCBQUk9DRVNTX0xPQ0tTID0ge307XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdGhhdCB3b3JrcyBvbmx5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyBsaWtlIFJlYWN0IE5hdGl2ZSBvciBvdGhlciBub24tYnJvd3NlclxuICogc2luZ2xlLXByb2Nlc3MgKGkuZS4gbm8gY29uY2VwdCBvZiBcInRhYnNcIikgZW52aXJvbm1lbnRzLlxuICpcbiAqIFVzZSB7QGxpbmsgI25hdmlnYXRvckxvY2t9IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogYXdhaXQgcHJvY2Vzc0xvY2soJ21pZ3JhdGUnLCA1MDAwLCBhc3luYyAoKSA9PiB7XG4gKiAgIGF3YWl0IHJ1bk1pZ3JhdGlvbigpXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSAoX2EgPSBQUk9DRVNTX0xPQ0tTW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yIG9mIHByZXZpb3VzIG9wZXJhdGlvbiB0aGF0IHdlJ3JlIHdhaXRpbmcgdG8gZmluaXNoXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSksXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0ID49IDBcbiAgICAgICAgICAgID8gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEBzdXBhYmFzZS9nb3RydWUtanM6IExvY2sgXCIke25hbWV9XCIgYWNxdWlzaXRpb24gdGltZWQgb3V0IGFmdGVyICR7YWNxdWlyZVRpbWVvdXR9bXMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgbWF5IGJlIGNhdXNlZCBieSBhbm90aGVyIG9wZXJhdGlvbiBob2xkaW5nIHRoZSBsb2NrLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb25zaWRlciBpbmNyZWFzaW5nIGxvY2tBY3F1aXJlVGltZW91dCBvciBjaGVja2luZyBmb3Igc3R1Y2sgb3BlcmF0aW9ucy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVpcmluZyBwcm9jZXNzIGxvY2sgd2l0aCBuYW1lIFwiJHtuYW1lfVwiIHRpbWVkIG91dGApKTtcbiAgICAgICAgICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsLFxuICAgIF0uZmlsdGVyKCh4KSA9PiB4KSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KVxuICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIHByZXZpb3VzIG9wZXJhdGlvbnMgZmluaXNoZWQgYW5kIHdlIGRpZG4ndCBnZXQgYSByYWNlIG9uIHRoZSBhY3F1aXJlXG4gICAgICAgIC8vIHRpbWVvdXQsIHNvIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBjYW4gZmluYWxseSBzdGFydFxuICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICB9KTtcbiAgICBQUk9DRVNTX0xPQ0tTW25hbWVdID0gY3VycmVudE9wZXJhdGlvbi5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aW1lZCBvdXQsIGl0IGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGZpbmlzaGVkLCBzbyB3ZSBuZWVkIGNvbnRudWUgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoXG4gICAgICAgICAgICBhd2FpdCBwcmV2aW91c09wZXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gICAgLy8gZmluYWxseSB3YWl0IGZvciB0aGUgY3VycmVudCBvcGVyYXRpb24gdG8gZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2l0aCBhblxuICAgIC8vIGVycm9yIG9yIHdpdGggYW4gYWNxdWlyZSB0aW1lb3V0IGVycm9yXG4gICAgcmV0dXJuIGF3YWl0IGN1cnJlbnRPcGVyYXRpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2Nrcy5qcy5tYXAiXSwibmFtZXMiOlsic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJpbnRlcm5hbHMiLCJkZWJ1ZyIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImlzQWNxdWlyZVRpbWVvdXQiLCJOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIlByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIm5hdmlnYXRvckxvY2siLCJuYW1lIiwiYWNxdWlyZVRpbWVvdXQiLCJmbiIsImNvbnNvbGUiLCJsb2ciLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJuYXZpZ2F0b3IiLCJsb2NrcyIsInJlcXVlc3QiLCJtb2RlIiwiaWZBdmFpbGFibGUiLCJzaWduYWwiLCJsb2NrIiwicmVzdWx0IiwicXVlcnkiLCJKU09OIiwic3RyaW5naWZ5IiwiZSIsIndhcm4iLCJQUk9DRVNTX0xPQ0tTIiwicHJvY2Vzc0xvY2siLCJfYSIsInByZXZpb3VzT3BlcmF0aW9uIiwiY3VycmVudE9wZXJhdGlvbiIsInJhY2UiLCJjYXRjaCIsIl8iLCJyZWplY3QiLCJmaWx0ZXIiLCJ4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: function() { return /* binding */ polyfillGlobalThis; }\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNNLFNBQVNBO0lBQ1osSUFBSSxPQUFPQyxlQUFlLFVBQ3RCO0lBQ0osSUFBSTtRQUNBQyxPQUFPQyxjQUFjLENBQUNELE9BQU9FLFNBQVMsRUFBRSxhQUFhO1lBQ2pEQyxLQUFLO2dCQUNELE9BQU8sSUFBSTtZQUNmO1lBQ0FDLGNBQWM7UUFDbEI7UUFDQSwyQ0FBMkM7UUFDM0NDLFVBQVVOLFVBQVUsR0FBR007UUFDdkIsMkNBQTJDO1FBQzNDLE9BQU9MLE9BQU9FLFNBQVMsQ0FBQ0csU0FBUztJQUNyQyxFQUNBLE9BQU9DLEdBQUc7UUFDTixJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUM3Qiw2Q0FBNkM7WUFDN0NBLEtBQUtSLFVBQVUsR0FBR1E7UUFDdEI7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzPzYzZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX187XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgICAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbHMuanMubWFwIl0sIm5hbWVzIjpbInBvbHlmaWxsR2xvYmFsVGhpcyIsImdsb2JhbFRoaXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImdldCIsImNvbmZpZ3VyYWJsZSIsIl9fbWFnaWNfXyIsImUiLCJzZWxmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIGN_OUT_SCOPES: function() { return /* binding */ SIGN_OUT_SCOPES; }\n/* harmony export */ });\nconst WeakPasswordReasons = [\n    \"length\",\n    \"characters\",\n    \"pwned\"\n];\nconst AMRMethods = [\n    \"password\",\n    \"otp\",\n    \"oauth\",\n    \"totp\",\n    \"mfa/totp\",\n    \"mfa/phone\",\n    \"mfa/webauthn\",\n    \"anonymous\",\n    \"sso/saml\",\n    \"magiclink\",\n    \"web3\",\n    \"oauth_provider/authorization_code\"\n];\nconst FactorTypes = [\n    \"totp\",\n    \"phone\",\n    \"webauthn\"\n];\nconst FactorVerificationStatuses = [\n    \"verified\",\n    \"unverified\"\n];\nconst MFATOTPChannels = [\n    \"sms\",\n    \"whatsapp\"\n];\nconst SIGN_OUT_SCOPES = [\n    \"global\",\n    \"local\",\n    \"others\"\n]; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHNCQUFzQjtJQUFDO0lBQVU7SUFBYztDQUFRO0FBQzdELE1BQU1DLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLGNBQWM7SUFBQztJQUFRO0lBQVM7Q0FBVztBQUNqRCxNQUFNQyw2QkFBNkI7SUFBQztJQUFZO0NBQWE7QUFDN0QsTUFBTUMsa0JBQWtCO0lBQUM7SUFBTztDQUFXO0FBQ3BDLE1BQU1DLGtCQUFrQjtJQUFDO0lBQVU7SUFBUztDQUFTLENBQUMsQ0FDN0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanM/MWY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBXZWFrUGFzc3dvcmRSZWFzb25zID0gWydsZW5ndGgnLCAnY2hhcmFjdGVycycsICdwd25lZCddO1xuY29uc3QgQU1STWV0aG9kcyA9IFtcbiAgICAncGFzc3dvcmQnLFxuICAgICdvdHAnLFxuICAgICdvYXV0aCcsXG4gICAgJ3RvdHAnLFxuICAgICdtZmEvdG90cCcsXG4gICAgJ21mYS9waG9uZScsXG4gICAgJ21mYS93ZWJhdXRobicsXG4gICAgJ2Fub255bW91cycsXG4gICAgJ3Nzby9zYW1sJyxcbiAgICAnbWFnaWNsaW5rJyxcbiAgICAnd2ViMycsXG4gICAgJ29hdXRoX3Byb3ZpZGVyL2F1dGhvcml6YXRpb25fY29kZScsXG5dO1xuY29uc3QgRmFjdG9yVHlwZXMgPSBbJ3RvdHAnLCAncGhvbmUnLCAnd2ViYXV0aG4nXTtcbmNvbnN0IEZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzID0gWyd2ZXJpZmllZCcsICd1bnZlcmlmaWVkJ107XG5jb25zdCBNRkFUT1RQQ2hhbm5lbHMgPSBbJ3NtcycsICd3aGF0c2FwcCddO1xuZXhwb3J0IGNvbnN0IFNJR05fT1VUX1NDT1BFUyA9IFsnZ2xvYmFsJywgJ2xvY2FsJywgJ290aGVycyddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIldlYWtQYXNzd29yZFJlYXNvbnMiLCJBTVJNZXRob2RzIiwiRmFjdG9yVHlwZXMiLCJGYWN0b3JWZXJpZmljYXRpb25TdGF0dXNlcyIsIk1GQVRPVFBDaGFubmVscyIsIlNJR05fT1VUX1NDT1BFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.95.3\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNkVBQTZFO0FBQzdFLGdFQUFnRTtBQUNoRSx1RUFBdUU7QUFDdkUsaUVBQWlFO0FBQ2pFLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDMUQsTUFBTUEsVUFBVSxTQUFTLENBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanM/OTc3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgcmVsZWFzZXMgYnkgc2NyaXB0cy91cGRhdGUtdmVyc2lvbi1maWxlcy50c1xuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHJ1bnRpbWUgYWNjZXNzIHRvIHRoZSBwYWNrYWdlIHZlcnNpb24gZm9yOlxuLy8gLSBIVFRQIHJlcXVlc3QgaGVhZGVycyAoZS5nLiwgWC1DbGllbnQtSW5mbyBoZWFkZXIgZm9yIEFQSSByZXF1ZXN0cylcbi8vIC0gRGVidWdnaW5nIGFuZCBzdXBwb3J0IChpZGVudGlmeWluZyB3aGljaCB2ZXJzaW9uIGlzIHJ1bm5pbmcpXG4vLyAtIFRlbGVtZXRyeSBhbmQgbG9nZ2luZyAodmVyc2lvbiByZXBvcnRpbmcgaW4gZXJyb3JzL2FuYWx5dGljcylcbi8vIC0gRW5zdXJpbmcgYnVpbGQgYXJ0aWZhY3RzIG1hdGNoIHRoZSBwdWJsaXNoZWQgcGFja2FnZSB2ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjk1LjMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSiweMessage: function() { return /* binding */ createSiweMessage; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   getAddress: function() { return /* binding */ getAddress; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; }\n/* harmony export */ });\n// types and functions copied over from viem so this library doesn't depend on it\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error('@supabase/auth-js: Address \"'.concat(address, '\" is invalid.'));\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return \"0x\" + hex;\n}\n/**\n * Creates EIP-4361 formatted message.\n */ function createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId)) throw new Error('@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: '.concat(chainId));\n        if (!domain) throw new Error('@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.');\n        if (nonce && nonce.length < 8) throw new Error('@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: '.concat(nonce));\n        if (!uri) throw new Error('@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.');\n        if (version !== \"1\") throw new Error(\"@supabase/auth-js: Invalid SIWE message field \\\"version\\\". Version must be '1'. Provided value: \".concat(version));\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes(\"\\n\")) throw new Error(\"@supabase/auth-js: Invalid SIWE message field \\\"statement\\\". Statement must not include '\\\\n'. Provided value: \".concat(parameters.statement));\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? \"\".concat(scheme, \"://\").concat(domain) : domain;\n    const statement = parameters.statement ? \"\".concat(parameters.statement, \"\\n\") : \"\";\n    const prefix = \"\".concat(origin, \" wants you to sign in with your Ethereum account:\\n\").concat(address, \"\\n\\n\").concat(statement);\n    let suffix = \"URI: \".concat(uri, \"\\nVersion: \").concat(version, \"\\nChain ID: \").concat(chainId).concat(nonce ? \"\\nNonce: \".concat(nonce) : \"\", \"\\nIssued At: \").concat(issuedAt.toISOString());\n    if (expirationTime) suffix += \"\\nExpiration Time: \".concat(expirationTime.toISOString());\n    if (notBefore) suffix += \"\\nNot Before: \".concat(notBefore.toISOString());\n    if (requestId) suffix += \"\\nRequest ID: \".concat(requestId);\n    if (resources) {\n        let content = \"\\nResources:\";\n        for (const resource of resources){\n            if (!resource || typeof resource !== \"string\") throw new Error('@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: '.concat(resource));\n            content += \"\\n- \".concat(resource);\n        }\n        suffix += content;\n    }\n    return \"\".concat(prefix, \"\\n\").concat(suffix);\n} //# sourceMappingURL=ethereum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViMy9ldGhlcmV1bS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsaUZBQWlGO0FBQzFFLFNBQVNBLFdBQVdDLE9BQU87SUFDOUIsSUFBSSxDQUFDLHNCQUFzQkMsSUFBSSxDQUFDRCxVQUFVO1FBQ3RDLE1BQU0sSUFBSUUsTUFBTSwrQkFBdUMsT0FBUkYsU0FBUTtJQUMzRDtJQUNBLE9BQU9BLFFBQVFHLFdBQVc7QUFDOUI7QUFDTyxTQUFTQyxRQUFRQyxHQUFHO0lBQ3ZCLE9BQU9DLFNBQVNELEtBQUs7QUFDekI7QUFDTyxTQUFTRSxNQUFNQyxLQUFLO0lBQ3ZCLE1BQU1DLFFBQVEsSUFBSUMsY0FBY0MsTUFBTSxDQUFDSDtJQUN2QyxNQUFNSCxNQUFNTyxNQUFNQyxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssT0FBU0EsS0FBS0MsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztJQUNqRixPQUFRLE9BQU9aO0FBQ25CO0FBQ0E7O0NBRUMsR0FDTSxTQUFTYSxrQkFBa0JDLFVBQVU7SUFDeEMsSUFBSUM7SUFDSixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxjQUFjLEVBQUVDLFdBQVcsSUFBSUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxPQUFPLEVBQUcsR0FBR2I7SUFDbEksa0JBQWtCO0lBQ2xCO1FBQ0ksSUFBSSxDQUFDYyxPQUFPQyxTQUFTLENBQUNiLFVBQ2xCLE1BQU0sSUFBSW5CLE1BQU0saUhBQXlILE9BQVJtQjtRQUNySSxJQUFJLENBQUNDLFFBQ0QsTUFBTSxJQUFJcEIsTUFBTztRQUNyQixJQUFJd0IsU0FBU0EsTUFBTVMsTUFBTSxHQUFHLEdBQ3hCLE1BQU0sSUFBSWpDLE1BQU0sK0dBQXFILE9BQU53QjtRQUNuSSxJQUFJLENBQUNLLEtBQ0QsTUFBTSxJQUFJN0IsTUFBTztRQUNyQixJQUFJOEIsWUFBWSxLQUNaLE1BQU0sSUFBSTlCLE1BQU0sbUdBQXlHLE9BQVI4QjtRQUNySCxJQUFJLENBQUNaLEtBQUtELFdBQVdpQixTQUFTLE1BQU0sUUFBUWhCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2lCLFFBQVEsQ0FBQyxPQUM3RSxNQUFNLElBQUluQyxNQUFNLGtIQUFxSSxPQUFyQmlCLFdBQVdpQixTQUFTO0lBQzVKO0lBQ0Esb0JBQW9CO0lBQ3BCLE1BQU1wQyxVQUFVRCxXQUFXb0IsV0FBV25CLE9BQU87SUFDN0MsTUFBTXNDLFNBQVNSLFNBQVMsR0FBZVIsT0FBWlEsUUFBTyxPQUFZLE9BQVBSLFVBQVdBO0lBQ2xELE1BQU1jLFlBQVlqQixXQUFXaUIsU0FBUyxHQUFHLEdBQXdCLE9BQXJCakIsV0FBV2lCLFNBQVMsRUFBQyxRQUFNO0lBQ3ZFLE1BQU1HLFNBQVMsR0FBK0R2QyxPQUE1RHNDLFFBQU8sdURBQW1FRixPQUFkcEMsU0FBUSxRQUFnQixPQUFWb0M7SUFDNUYsSUFBSUksU0FBUyxRQUF5QlIsT0FBakJELEtBQUksZUFBbUNWLE9BQXRCVyxTQUFRLGdCQUF3Qk4sT0FBVkwsU0FBMERHLE9BQWhERSxRQUFRLFlBQWtCLE9BQU5BLFNBQVUsSUFBRyxpQkFBc0MsT0FBdkJGLFNBQVNpQixXQUFXO0lBQzFJLElBQUlsQixnQkFDQWlCLFVBQVUsc0JBQW1ELE9BQTdCakIsZUFBZWtCLFdBQVc7SUFDOUQsSUFBSWQsV0FDQWEsVUFBVSxpQkFBeUMsT0FBeEJiLFVBQVVjLFdBQVc7SUFDcEQsSUFBSWIsV0FDQVksVUFBVSxpQkFBMkIsT0FBVlo7SUFDL0IsSUFBSUMsV0FBVztRQUNYLElBQUlhLFVBQVU7UUFDZCxLQUFLLE1BQU1DLFlBQVlkLFVBQVc7WUFDOUIsSUFBSSxDQUFDYyxZQUFZLE9BQU9BLGFBQWEsVUFDakMsTUFBTSxJQUFJekMsTUFBTSxxSEFBOEgsT0FBVHlDO1lBQ3pJRCxXQUFXLE9BQWdCLE9BQVRDO1FBQ3RCO1FBQ0FILFVBQVVFO0lBQ2Q7SUFDQSxPQUFPLEdBQWNGLE9BQVhELFFBQU8sTUFBVyxPQUFQQztBQUN6QixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYjMvZXRoZXJldW0uanM/MjBkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0eXBlcyBhbmQgZnVuY3Rpb25zIGNvcGllZCBvdmVyIGZyb20gdmllbSBzbyB0aGlzIGxpYnJhcnkgZG9lc24ndCBkZXBlbmQgb24gaXRcbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIS9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbiAgICBjb25zdCBoZXggPSBBcnJheS5mcm9tKGJ5dGVzLCAoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgcmV0dXJuICgnMHgnICsgaGV4KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBFSVAtNDM2MSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpd2VNZXNzYWdlKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBjaGFpbklkLCBkb21haW4sIGV4cGlyYXRpb25UaW1lLCBpc3N1ZWRBdCA9IG5ldyBEYXRlKCksIG5vbmNlLCBub3RCZWZvcmUsIHJlcXVlc3RJZCwgcmVzb3VyY2VzLCBzY2hlbWUsIHVyaSwgdmVyc2lvbiwgfSA9IHBhcmFtZXRlcnM7XG4gICAgLy8gVmFsaWRhdGUgZmllbGRzXG4gICAge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY2hhaW5JZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcImNoYWluSWRcIi4gQ2hhaW4gSUQgbXVzdCBiZSBhIEVJUC0xNTUgY2hhaW4gSUQuIFByb3ZpZGVkIHZhbHVlOiAke2NoYWluSWR9YCk7XG4gICAgICAgIGlmICghZG9tYWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJkb21haW5cIi4gRG9tYWluIG11c3QgYmUgcHJvdmlkZWQuYCk7XG4gICAgICAgIGlmIChub25jZSAmJiBub25jZS5sZW5ndGggPCA4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJub25jZVwiLiBOb25jZSBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycy4gUHJvdmlkZWQgdmFsdWU6ICR7bm9uY2V9YCk7XG4gICAgICAgIGlmICghdXJpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJ1cmlcIi4gVVJJIG11c3QgYmUgcHJvdmlkZWQuYCk7XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSAnMScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInZlcnNpb25cIi4gVmVyc2lvbiBtdXN0IGJlICcxJy4gUHJvdmlkZWQgdmFsdWU6ICR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKChfYSA9IHBhcmFtZXRlcnMuc3RhdGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ1xcbicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJzdGF0ZW1lbnRcIi4gU3RhdGVtZW50IG11c3Qgbm90IGluY2x1ZGUgJ1xcXFxuJy4gUHJvdmlkZWQgdmFsdWU6ICR7cGFyYW1ldGVycy5zdGF0ZW1lbnR9YCk7XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCBtZXNzYWdlXG4gICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MocGFyYW1ldGVycy5hZGRyZXNzKTtcbiAgICBjb25zdCBvcmlnaW4gPSBzY2hlbWUgPyBgJHtzY2hlbWV9Oi8vJHtkb21haW59YCA6IGRvbWFpbjtcbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBwYXJhbWV0ZXJzLnN0YXRlbWVudCA/IGAke3BhcmFtZXRlcnMuc3RhdGVtZW50fVxcbmAgOiAnJztcbiAgICBjb25zdCBwcmVmaXggPSBgJHtvcmlnaW59IHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxcbiR7YWRkcmVzc31cXG5cXG4ke3N0YXRlbWVudH1gO1xuICAgIGxldCBzdWZmaXggPSBgVVJJOiAke3VyaX1cXG5WZXJzaW9uOiAke3ZlcnNpb259XFxuQ2hhaW4gSUQ6ICR7Y2hhaW5JZH0ke25vbmNlID8gYFxcbk5vbmNlOiAke25vbmNlfWAgOiAnJ31cXG5Jc3N1ZWQgQXQ6ICR7aXNzdWVkQXQudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChleHBpcmF0aW9uVGltZSlcbiAgICAgICAgc3VmZml4ICs9IGBcXG5FeHBpcmF0aW9uIFRpbWU6ICR7ZXhwaXJhdGlvblRpbWUudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChub3RCZWZvcmUpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuTm90IEJlZm9yZTogJHtub3RCZWZvcmUudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChyZXF1ZXN0SWQpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuUmVxdWVzdCBJRDogJHtyZXF1ZXN0SWR9YDtcbiAgICBpZiAocmVzb3VyY2VzKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gJ1xcblJlc291cmNlczonO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgICAgICAgICAgaWYgKCFyZXNvdXJjZSB8fCB0eXBlb2YgcmVzb3VyY2UgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwicmVzb3VyY2VzXCIuIEV2ZXJ5IHJlc291cmNlIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuIFByb3ZpZGVkIHZhbHVlOiAke3Jlc291cmNlfWApO1xuICAgICAgICAgICAgY29udGVudCArPSBgXFxuLSAke3Jlc291cmNlfWA7XG4gICAgICAgIH1cbiAgICAgICAgc3VmZml4ICs9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmVmaXh9XFxuJHtzdWZmaXh9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVyZXVtLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiYWRkcmVzcyIsInRlc3QiLCJFcnJvciIsInRvTG93ZXJDYXNlIiwiZnJvbUhleCIsImhleCIsInBhcnNlSW50IiwidG9IZXgiLCJ2YWx1ZSIsImJ5dGVzIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJBcnJheSIsImZyb20iLCJieXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJjcmVhdGVTaXdlTWVzc2FnZSIsInBhcmFtZXRlcnMiLCJfYSIsImNoYWluSWQiLCJkb21haW4iLCJleHBpcmF0aW9uVGltZSIsImlzc3VlZEF0IiwiRGF0ZSIsIm5vbmNlIiwibm90QmVmb3JlIiwicmVxdWVzdElkIiwicmVzb3VyY2VzIiwic2NoZW1lIiwidXJpIiwidmVyc2lvbiIsIk51bWJlciIsImlzSW50ZWdlciIsImxlbmd0aCIsInN0YXRlbWVudCIsImluY2x1ZGVzIiwib3JpZ2luIiwicHJlZml4Iiwic3VmZml4IiwidG9JU09TdHJpbmciLCJjb250ZW50IiwicmVzb3VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnError: function() { return /* binding */ WebAuthnError; },\n/* harmony export */   WebAuthnUnknownError: function() { return /* binding */ WebAuthnUnknownError; },\n/* harmony export */   identifyAuthenticationError: function() { return /* binding */ identifyAuthenticationError; },\n/* harmony export */   identifyRegistrationError: function() { return /* binding */ identifyRegistrationError; },\n/* harmony export */   isWebAuthnError: function() { return /* binding */ isWebAuthnError; }\n/* harmony export */ });\n/* harmony import */ var _webauthn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */ \n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */ class WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, {\n            cause\n        });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        this.code = code;\n    }\n}\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */ class WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError){\n        super({\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: originalError,\n            message\n        });\n        this.name = \"WebAuthnUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */ function isWebAuthnError(error) {\n    return typeof error === \"object\" && error !== null && \"__isWebAuthnError\" in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */ function identifyRegistrationError(param) {\n    let { error, options } = param;\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (// @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === \"conditional\" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: \"User verification was required during automatic registration but it could not be performed\",\n                code: \"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE\",\n                cause: error\n            });\n        } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === \"required\") {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: 'The RP ID \"'.concat(publicKey.rp.id, '\" is invalid for this domain'),\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */ function identifyAuthenticationError(param) {\n    let { error, options } = param;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: 'The RP ID \"'.concat(publicKey.rpId, '\" is invalid for this domain'),\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n} //# sourceMappingURL=webauthn.errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLG9EQUFvRCxHQUNUO0FBQzNDOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ00sTUFBTUMsc0JBQXNCQztJQUMvQkMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUcsQ0FBRTtRQUN6QyxJQUFJQztRQUNKLGlFQUFpRTtRQUNqRSxLQUFLLENBQUNKLFNBQVM7WUFBRUU7UUFBTTtRQUN2QixJQUFJLENBQUNHLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0YsSUFBSSxHQUFHLENBQUNDLEtBQUtELFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUlBLE9BQVFELGlCQUFpQkosUUFBUUksTUFBTUMsSUFBSSxHQUFHRyxTQUFTLE1BQU8sUUFBUUYsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDaEosSUFBSSxDQUFDSCxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNTSw2QkFBNkJWO0lBQ3RDRSxZQUFZQyxPQUFPLEVBQUVRLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUM7WUFDRlAsTUFBTTtZQUNOQyxPQUFPTTtZQUNQUjtRQUNKO1FBQ0EsSUFBSSxDQUFDRyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNLLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxnQkFBZ0JDLEtBQUs7SUFDakMsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSx1QkFBdUJBO0FBQ2pGO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTQywwQkFBMEIsS0FBbUI7UUFBbkIsRUFBRUQsS0FBSyxFQUFFRSxPQUFPLEVBQUcsR0FBbkI7SUFDdEMsSUFBSVIsSUFBSVMsSUFBSUM7SUFD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T0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssaUJBQWlCO1FBQ3JDLE1BQU15QixrQkFBa0JDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTtRQUNoRCxJQUFJLENBQUNuQyx3REFBYUEsQ0FBQ2dDLGtCQUFrQjtZQUNqQyxnRkFBZ0Y7WUFDaEYsT0FBTyxJQUFJL0IsY0FBYztnQkFDckJHLFNBQVMsR0FBNEIsT0FBekI2QixPQUFPQyxRQUFRLENBQUNDLFFBQVEsRUFBQztnQkFDckM5QixNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0osT0FDSyxJQUFJSyxVQUFVc0IsSUFBSSxLQUFLVCxpQkFBaUI7WUFDekMsZ0ZBQWdGO1lBQ2hGLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLGNBQTZCLE9BQWZlLFVBQVVzQixJQUFJLEVBQUM7Z0JBQ3RDcEMsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKO0lBQ0osT0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssZ0JBQWdCO1FBQ3BDLG1FQUFtRTtRQUNuRSxvRUFBb0U7UUFDcEUsT0FBTyxJQUFJTixjQUFjO1lBQ3JCRyxTQUFTO1lBQ1RDLE1BQU07WUFDTkMsT0FBT1E7UUFDWDtJQUNKO0lBQ0EsT0FBTyxJQUFJYixjQUFjO1FBQ3JCRyxTQUFTO1FBQ1RDLE1BQU07UUFDTkMsT0FBT1E7SUFDWDtBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uZXJyb3JzLmpzP2I5NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG5pbXBvcnQgeyBpc1ZhbGlkRG9tYWluIH0gZnJvbSAnLi93ZWJhdXRobic7XG4vKipcbiAqIEEgY3VzdG9tIEVycm9yIHVzZWQgdG8gcmV0dXJuIGEgbW9yZSBudWFuY2VkIGVycm9yIGRldGFpbGluZyBfd2h5XyBvbmUgb2YgdGhlIGVpZ2h0IGRvY3VtZW50ZWRcbiAqIGVycm9ycyBpbiB0aGUgc3BlYyB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKWAgb3JcbiAqIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClgOlxuICpcbiAqIC0gYEFib3J0RXJyb3JgXG4gKiAtIGBDb25zdHJhaW50RXJyb3JgXG4gKiAtIGBJbnZhbGlkU3RhdGVFcnJvcmBcbiAqIC0gYE5vdEFsbG93ZWRFcnJvcmBcbiAqIC0gYE5vdFN1cHBvcnRlZEVycm9yYFxuICogLSBgU2VjdXJpdHlFcnJvcmBcbiAqIC0gYFR5cGVFcnJvcmBcbiAqIC0gYFVua25vd25FcnJvcmBcbiAqXG4gKiBFcnJvciBtZXNzYWdlcyB3ZXJlIGRldGVybWluZWQgdGhyb3VnaCBpbnZlc3RpZ2F0aW9uIG9mIHRoZSBzcGVjIHRvIGRldGVybWluZSB1bmRlciB3aGljaFxuICogc2NlbmFyaW9zIGEgZ2l2ZW4gZXJyb3Igd291bGQgYmUgcmFpc2VkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UsIGNvZGUsIGNhdXNlLCBuYW1lLCB9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogaGVscCBSb2xsdXAgdW5kZXJzdGFuZCB0aGF0IGBjYXVzZWAgaXMgb2theSB0byBzZXRcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICAgICAgdGhpcy5fX2lzV2ViQXV0aG5FcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMubmFtZSA9IChfYSA9IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IChjYXVzZSBpbnN0YW5jZW9mIEVycm9yID8gY2F1c2UubmFtZSA6IHVuZGVmaW5lZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdVbmtub3duIEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIGNsYXNzIGZvciB1bmtub3duIFdlYkF1dGhuIGVycm9ycy5cbiAqIFdyYXBzIHVuZXhwZWN0ZWQgZXJyb3JzIHRoYXQgZG9uJ3QgbWF0Y2gga25vd24gV2ViQXV0aG4gZXJyb3IgY29uZGl0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkF1dGhuVW5rbm93bkVycm9yIGV4dGVuZHMgV2ViQXV0aG5FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBvcmlnaW5hbEVycm9yLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXZWJBdXRoblVua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgV2ViQXV0aG5FcnJvci5cbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFdlYkF1dGhuRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViQXV0aG5FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzV2ViQXV0aG5FcnJvcicgaW4gZXJyb3I7XG59XG4vKipcbiAqIEF0dGVtcHQgdG8gaW50dWl0IF93aHlfIGFuIGVycm9yIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYC5cbiAqIE1hcHMgYnJvd3NlciBlcnJvcnMgdG8gc3BlY2lmaWMgV2ViQXV0aG4gZXJyb3IgY29kZXMgZm9yIGJldHRlciBkZWJ1Z2dpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gRXJyb3IgaWRlbnRpZmljYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtFcnJvcn0gcGFyYW1zLmVycm9yIC0gVGhlIGVycm9yIHRocm93biBieSB0aGUgYnJvd3NlclxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVhdGUgQ3JlZGVudGlhbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IoeyBlcnJvciwgb3B0aW9ucywgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb25zIHdhcyBtaXNzaW5nIHJlcXVpcmVkIHB1YmxpY0tleSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVnaXN0cmF0aW9uIGNlcmVtb255IHdhcyBzZW50IGFuIGFib3J0IHNpZ25hbCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0NFUkVNT05ZX0FCT1JURUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgICAgIGlmICgoKF9hID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXF1aXJlUmVzaWRlbnRLZXkpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgNClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Rpc2NvdmVyYWJsZSBjcmVkZW50aWFscyB3ZXJlIHJlcXVpcmVkIGJ1dCBubyBhdmFpbGFibGUgYXV0aGVudGljYXRvciBzdXBwb3J0ZWQgaXQnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX01JU1NJTkdfRElTQ09WRVJBQkxFX0NSRURFTlRJQUxfU1VQUE9SVCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGBtZWRpYXRpb25gIGRvZXNuJ3QgeWV0IGV4aXN0IG9uIENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgYnV0IGl0J3MgcG9zc2libGUgYXMgb2YgU2VwdCAyMDI0XG4gICAgICAgIG9wdGlvbnMubWVkaWF0aW9uID09PSAnY29uZGl0aW9uYWwnICYmXG4gICAgICAgICAgICAoKF9iID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VyVmVyaWZpY2F0aW9uKSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMjIuNClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgdmVyaWZpY2F0aW9uIHdhcyByZXF1aXJlZCBkdXJpbmcgYXV0b21hdGljIHJlZ2lzdHJhdGlvbiBidXQgaXQgY291bGQgbm90IGJlIHBlcmZvcm1lZCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVE9fUkVHSVNURVJfVVNFUl9WRVJJRklDQVRJT05fRkFJTFVSRScsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChfYyA9IHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXNlclZlcmlmaWNhdGlvbikgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciB2ZXJpZmljYXRpb24gd2FzIHJlcXVpcmVkIGJ1dCBubyBhdmFpbGFibGUgYXV0aGVudGljYXRvciBzdXBwb3J0ZWQgaXQnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX01JU1NJTkdfVVNFUl9WRVJJRklDQVRJT05fU1VQUE9SVCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDIwKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMylcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgYXV0aGVudGljYXRvciB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX1BSRVZJT1VTTFlfUkVHSVNURVJFRCcsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyB0aGUgZXJyb3IgZGlyZWN0bHkgdGhyb3VnaC4gUGxhdGZvcm1zIGFyZSBvdmVybG9hZGluZyB0aGlzIGVycm9yIGJleW9uZCB3aGF0IHRoZSBzcGVjXG4gICAgICAgICAqIGRlZmluZXMgYW5kIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIHBvdGVudGlhbGx5IHVzZWZ1bCBlcnJvciBtZXNzYWdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90U3VwcG9ydGVkRXJyb3InKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUHViS2V5Q3JlZFBhcmFtcyA9IHB1YmxpY0tleS5wdWJLZXlDcmVkUGFyYW1zLmZpbHRlcigocGFyYW0pID0+IHBhcmFtLnR5cGUgPT09ICdwdWJsaWMta2V5Jyk7XG4gICAgICAgIGlmICh2YWxpZFB1YktleUNyZWRQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTm8gZW50cnkgaW4gcHViS2V5Q3JlZFBhcmFtcyB3YXMgb2YgdHlwZSBcInB1YmxpYy1rZXlcIicsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX01BTEZPUk1FRF9QVUJLRVlDUkVEUEFSQU1TJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMilcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBhdmFpbGFibGUgYXV0aGVudGljYXRvciBzdXBwb3J0ZWQgYW55IG9mIHRoZSBzcGVjaWZpZWQgcHViS2V5Q3JlZFBhcmFtcyBhbGdvcml0aG1zJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX05PX1NVUFBPUlRFRF9QVUJLRVlDUkVEUEFSQU1TX0FMRycsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlRG9tYWluID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICBpZiAoIWlzVmFsaWREb21haW4oZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA3KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycC5pZCAhPT0gZWZmZWN0aXZlRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycC5pZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoIDwgMSB8fCBwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgSUQgd2FzIG5vdCBiZXR3ZWVuIDEgYW5kIDY0IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1VTRVJfSURfTEVOR1RIJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMSlcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDgpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBjcmVkZW50aWFsJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2EgTm9uLVdlYmF1dGhuIHJlbGF0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJyxcbiAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KTtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClgLlxuICogTWFwcyBicm93c2VyIGVycm9ycyB0byBzcGVjaWZpYyBXZWJBdXRobiBlcnJvciBjb2RlcyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBFcnJvciBpZGVudGlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Vycm9yfSBwYXJhbXMuZXJyb3IgLSBUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBicm93c2VyXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gcGFyYW1zLm9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gY3JlZGVudGlhbHMuZ2V0KClcbiAqIEByZXR1cm5zIHtXZWJBdXRobkVycm9yfSBBIFdlYkF1dGhuRXJyb3Igd2l0aCBhIHNwZWNpZmljIGVycm9yIGNvZGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1nZXRBc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBHZXQgQXNzZXJ0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIGNlcmVtb255IHdhcyBzZW50IGFuIGFib3J0IHNpZ25hbCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0NFUkVNT05ZX0FCT1JURUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1kaXNjb3Zlci1mcm9tLWV4dGVybmFsLXNvdXJjZSAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycElkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWRpc2NvdmVyLWZyb20tZXh0ZXJuYWwtc291cmNlIChTdGVwIDYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycElkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9SUF9JRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1Vua25vd25FcnJvcicpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtZ2V0LWFzc2VydGlvbiAoU3RlcCAxKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyB1bmFibGUgdG8gcHJvY2VzcyB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIG9yIGNvdWxkIG5vdCBjcmVhdGUgYSBuZXcgYXNzZXJ0aW9uIHNpZ25hdHVyZScsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9HRU5FUkFMX0VSUk9SJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdhIE5vbi1XZWJhdXRobiByZWxhdGVkIGVycm9yIGhhcyBvY2N1cnJlZCcsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbImlzVmFsaWREb21haW4iLCJXZWJBdXRobkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwiY2F1c2UiLCJuYW1lIiwiX2EiLCJfX2lzV2ViQXV0aG5FcnJvciIsInVuZGVmaW5lZCIsIldlYkF1dGhuVW5rbm93bkVycm9yIiwib3JpZ2luYWxFcnJvciIsImlzV2ViQXV0aG5FcnJvciIsImVycm9yIiwiaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciIsIm9wdGlvbnMiLCJfYiIsIl9jIiwicHVibGljS2V5Iiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJhdXRoZW50aWNhdG9yU2VsZWN0aW9uIiwicmVxdWlyZVJlc2lkZW50S2V5IiwibWVkaWF0aW9uIiwidXNlclZlcmlmaWNhdGlvbiIsInZhbGlkUHViS2V5Q3JlZFBhcmFtcyIsInB1YktleUNyZWRQYXJhbXMiLCJmaWx0ZXIiLCJwYXJhbSIsInR5cGUiLCJsZW5ndGgiLCJlZmZlY3RpdmVEb21haW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwicnAiLCJpZCIsInVzZXIiLCJieXRlTGVuZ3RoIiwiaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yIiwicnBJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CREATION_OPTIONS: function() { return /* binding */ DEFAULT_CREATION_OPTIONS; },\n/* harmony export */   DEFAULT_REQUEST_OPTIONS: function() { return /* binding */ DEFAULT_REQUEST_OPTIONS; },\n/* harmony export */   WebAuthnAbortService: function() { return /* binding */ WebAuthnAbortService; },\n/* harmony export */   WebAuthnApi: function() { return /* binding */ WebAuthnApi; },\n/* harmony export */   WebAuthnError: function() { return /* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnError; },\n/* harmony export */   createCredential: function() { return /* binding */ createCredential; },\n/* harmony export */   deserializeCredentialCreationOptions: function() { return /* binding */ deserializeCredentialCreationOptions; },\n/* harmony export */   deserializeCredentialRequestOptions: function() { return /* binding */ deserializeCredentialRequestOptions; },\n/* harmony export */   getCredential: function() { return /* binding */ getCredential; },\n/* harmony export */   identifyAuthenticationError: function() { return /* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError; },\n/* harmony export */   identifyRegistrationError: function() { return /* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError; },\n/* harmony export */   isValidDomain: function() { return /* binding */ isValidDomain; },\n/* harmony export */   isWebAuthnError: function() { return /* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.isWebAuthnError; },\n/* harmony export */   mergeCredentialCreationOptions: function() { return /* binding */ mergeCredentialCreationOptions; },\n/* harmony export */   mergeCredentialRequestOptions: function() { return /* binding */ mergeCredentialRequestOptions; },\n/* harmony export */   serializeCredentialCreationResponse: function() { return /* binding */ serializeCredentialCreationResponse; },\n/* harmony export */   serializeCredentialRequestResponse: function() { return /* binding */ serializeCredentialRequestResponse; },\n/* harmony export */   webAuthnAbortService: function() { return /* binding */ webAuthnAbortService; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webauthn.errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\");\n\n\n\n\n\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */ class WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */ createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */ cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */ const webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */ function deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential creation options are required\");\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */ options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"user\",\n        \"excludeCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), {\n        id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(userOpts.id).buffer\n    });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge,\n        user\n    });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for(let i = 0; i < excludeCredentials.length; i++){\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */ function deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential request options are required\");\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"allowCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge\n    });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for(let i = 0; i < allowCredentials.length; i++){\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))\n        },\n        type: \"public-key\",\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            authenticatorData: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle ? (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined\n        },\n        type: \"public-key\",\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */ function isValidDomain(hostname) {\n    return(// Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */ function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */ async function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */ async function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\nconst DEFAULT_CREATION_OPTIONS = {\n    hints: [\n        \"security-key\"\n    ],\n    authenticatorSelection: {\n        authenticatorAttachment: \"cross-platform\",\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n        residentKey: \"discouraged\"\n    },\n    attestation: \"direct\"\n};\nconst DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n    hints: [\n        \"security-key\"\n    ],\n    attestation: \"direct\"\n};\nfunction deepMerge() {\n    for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n        sources[_key] = arguments[_key];\n    }\n    const isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\n    const isArrayBufferLike = (val)=>val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources){\n        if (!source) continue;\n        for(const key in source){\n            const value = source[key];\n            if (value === undefined) continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            } else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            } else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                } else {\n                    result[key] = deepMerge(value);\n                }\n            } else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */ function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */ function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */ class WebAuthnApi {\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */ async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n            factorType: \"webauthn\"\n        }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */ async _challenge(param, overrides) {\n        let { factorId, webauthn, friendlyName, signal } = param;\n        var _a;\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */ if (challengeResponse.webauthn.type === \"create\") {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\n                    // This maintains backward compatibility with the ${user.id}:${name} format\n                    const nameToUse = friendlyName;\n                    if (!nameToUse) {\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\n                        const currentUser = await this.client.getUser();\n                        const userData = currentUser.data.user;\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || \"User\";\n                        user.name = \"\".concat(user.id, \":\").concat(fallbackName);\n                    } else {\n                        user.name = \"\".concat(user.id, \":\").concat(nameToUse);\n                    }\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch(challengeResponse.webauthn.type){\n                case \"create\":\n                    {\n                        const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                        const { data, error } = await createCredential({\n                            publicKey: options,\n                            signal: abortSignal\n                        });\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                case \"request\":\n                    {\n                        const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                        const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n                            publicKey: options,\n                            signal: abortSignal\n                        }));\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n            }\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in challenge\", error)\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */ async _verify(param) {\n        let { challengeId, factorId, webauthn } = param;\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */ async _authenticate(param, overrides) {\n        let { factorId, webauthn: { rpId =  true ? window.location.hostname : 0, rpOrigins =  true ? [\n            window.location.origin\n        ] : 0, signal } = {} } = param;\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn authentication\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                request: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in authenticate\", error)\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */ async _register(param, overrides) {\n        let { friendlyName, webauthn: { rpId =  true ? window.location.hostname : 0, rpOrigins =  true ? [\n            window.location.origin\n        ] : 0, signal } = {} } = param;\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn registration\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName\n            });\n            if (!factor) {\n                await this.client.mfa.listFactors().then((factors)=>{\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v)=>v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n                }).then((factor)=>factor ? this.client.mfa.unenroll({\n                        factorId: factor === null || factor === void 0 ? void 0 : factor.id\n                    }) : void 0);\n                return {\n                    data: null,\n                    error: enrollError\n                };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                create: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in register\", error)\n            };\n        }\n    }\n    constructor(client){\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n} //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDdUM7QUFDRjtBQUM5QjtBQUM0RztBQUNoRDtBQUNsRzs7Ozs7O0NBTUMsR0FDTSxNQUFNWTtJQUNUOzs7Ozs7S0FNQyxHQUNEQyx1QkFBdUI7UUFDbkIsNEZBQTRGO1FBQzVGLElBQUksSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDakIsTUFBTUMsYUFBYSxJQUFJQyxNQUFNO1lBQzdCRCxXQUFXRSxJQUFJLEdBQUc7WUFDbEIsSUFBSSxDQUFDSCxVQUFVLENBQUNJLEtBQUssQ0FBQ0g7UUFDMUI7UUFDQSxNQUFNSSxnQkFBZ0IsSUFBSUM7UUFDMUIsSUFBSSxDQUFDTixVQUFVLEdBQUdLO1FBQ2xCLE9BQU9BLGNBQWNFLE1BQU07SUFDL0I7SUFDQTs7Ozs7S0FLQyxHQUNEQyxpQkFBaUI7UUFDYixJQUFJLElBQUksQ0FBQ1IsVUFBVSxFQUFFO1lBQ2pCLE1BQU1DLGFBQWEsSUFBSUMsTUFBTTtZQUM3QkQsV0FBV0UsSUFBSSxHQUFHO1lBQ2xCLElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxLQUFLLENBQUNIO1lBQ3RCLElBQUksQ0FBQ0QsVUFBVSxHQUFHUztRQUN0QjtJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1DLHVCQUF1QixJQUFJWix1QkFBdUI7QUFDL0Q7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTYSxxQ0FBcUNDLE9BQU87SUFDeEQsSUFBSSxDQUFDQSxTQUFTO1FBQ1YsTUFBTSxJQUFJVixNQUFNO0lBQ3BCO0lBQ0EsdUVBQXVFO0lBQ3ZFLElBQUksT0FBT1csd0JBQXdCLGVBQy9CLGtDQUFrQ0EsdUJBQ2xDLE9BQU9BLG9CQUNGQyw0QkFBNEIsS0FBSyxZQUFZO1FBQ2xELHlDQUF5QztRQUN6QyxPQUFPRCxvQkFBb0JDLDRCQUE0QixDQUN2RCw0RkFBNEYsR0FDNUZGO0lBQ0o7SUFDQSwrRUFBK0U7SUFDL0UsMERBQTBEO0lBQzFELE1BQU0sRUFBRUcsV0FBV0MsWUFBWSxFQUFFQyxNQUFNQyxRQUFRLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdQLFNBQVNRLGNBQWNsQyw2Q0FBTUEsQ0FBQzBCLFNBRXBHO1FBQUM7UUFBYTtRQUFRO0tBQXFCO0lBQzdDLGtEQUFrRDtJQUNsRCxNQUFNRyxZQUFZNUIsaUVBQXFCQSxDQUFDNkIsY0FBY0ssTUFBTTtJQUM1RCxnREFBZ0Q7SUFDaEQsTUFBTUosT0FBT0ssT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHTCxXQUFXO1FBQUVNLElBQUlyQyxpRUFBcUJBLENBQUMrQixTQUFTTSxFQUFFLEVBQUVILE1BQU07SUFBQztJQUN4RywwQkFBMEI7SUFDMUIsTUFBTUksU0FBU0gsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCxjQUFjO1FBQUVMO1FBQzNERTtJQUFLO0lBQ1QsMkNBQTJDO0lBQzNDLElBQUlFLHNCQUFzQkEsbUJBQW1CTyxNQUFNLEdBQUcsR0FBRztRQUNyREQsT0FBT04sa0JBQWtCLEdBQUcsSUFBSVEsTUFBTVIsbUJBQW1CTyxNQUFNO1FBQy9ELElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJVCxtQkFBbUJPLE1BQU0sRUFBRUUsSUFBSztZQUNoRCxNQUFNQyxPQUFPVixrQkFBa0IsQ0FBQ1MsRUFBRTtZQUNsQ0gsT0FBT04sa0JBQWtCLENBQUNTLEVBQUUsR0FBR04sT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHTSxPQUFPO2dCQUFFTCxJQUFJckMsaUVBQXFCQSxDQUFDMEMsS0FBS0wsRUFBRSxFQUFFSCxNQUFNO2dCQUFFUyxNQUFNRCxLQUFLQyxJQUFJLElBQUk7Z0JBQ2xJLGdFQUFnRTtnQkFDaEVDLFlBQVlGLEtBQUtFLFVBQVU7WUFBQztRQUNwQztJQUNKO0lBQ0EsT0FBT047QUFDWDtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU08sb0NBQW9DcEIsT0FBTztJQUN2RCxJQUFJLENBQUNBLFNBQVM7UUFDVixNQUFNLElBQUlWLE1BQU07SUFDcEI7SUFDQSxzRUFBc0U7SUFDdEUsSUFBSSxPQUFPVyx3QkFBd0IsZUFDL0IsaUNBQWlDQSx1QkFDakMsT0FBT0Esb0JBQ0ZvQiwyQkFBMkIsS0FBSyxZQUFZO1FBQ2pELHlDQUF5QztRQUN6QyxPQUFPcEIsb0JBQW9Cb0IsMkJBQTJCLENBQUNyQjtJQUMzRDtJQUNBLCtFQUErRTtJQUMvRSwwREFBMEQ7SUFDMUQsTUFBTSxFQUFFRyxXQUFXQyxZQUFZLEVBQUVrQixnQkFBZ0IsRUFBRSxHQUFHdEIsU0FBU1EsY0FBY2xDLDZDQUFNQSxDQUFDMEIsU0FFbEY7UUFBQztRQUFhO0tBQW1CO0lBQ25DLGtEQUFrRDtJQUNsRCxNQUFNRyxZQUFZNUIsaUVBQXFCQSxDQUFDNkIsY0FBY0ssTUFBTTtJQUM1RCwwQkFBMEI7SUFDMUIsTUFBTUksU0FBU0gsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCxjQUFjO1FBQUVMO0lBQVU7SUFDekUseUNBQXlDO0lBQ3pDLElBQUltQixvQkFBb0JBLGlCQUFpQlIsTUFBTSxHQUFHLEdBQUc7UUFDakRELE9BQU9TLGdCQUFnQixHQUFHLElBQUlQLE1BQU1PLGlCQUFpQlIsTUFBTTtRQUMzRCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSU0saUJBQWlCUixNQUFNLEVBQUVFLElBQUs7WUFDOUMsTUFBTUMsT0FBT0ssZ0JBQWdCLENBQUNOLEVBQUU7WUFDaENILE9BQU9TLGdCQUFnQixDQUFDTixFQUFFLEdBQUdOLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR00sT0FBTztnQkFBRUwsSUFBSXJDLGlFQUFxQkEsQ0FBQzBDLEtBQUtMLEVBQUUsRUFBRUgsTUFBTTtnQkFBRVMsTUFBTUQsS0FBS0MsSUFBSSxJQUFJO2dCQUNoSSxnRUFBZ0U7Z0JBQ2hFQyxZQUFZRixLQUFLRSxVQUFVO1lBQUM7UUFDcEM7SUFDSjtJQUNBLE9BQU9OO0FBQ1g7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNVLG9DQUFvQ0MsVUFBVTtJQUMxRCxJQUFJQztJQUNKLHlEQUF5RDtJQUN6RCxJQUFJLFlBQVlELGNBQWMsT0FBT0EsV0FBV0UsTUFBTSxLQUFLLFlBQVk7UUFDbkUseUNBQXlDO1FBQ3pDLE9BQU9GLFdBQVdFLE1BQU07SUFDNUI7SUFDQSxNQUFNQywyQkFBMkJIO0lBQ2pDLE9BQU87UUFDSFosSUFBSVksV0FBV1osRUFBRTtRQUNqQmdCLE9BQU9KLFdBQVdaLEVBQUU7UUFDcEJpQixVQUFVO1lBQ05DLG1CQUFtQnRELDREQUFnQkEsQ0FBQyxJQUFJdUQsV0FBV1AsV0FBV0ssUUFBUSxDQUFDQyxpQkFBaUI7WUFDeEZFLGdCQUFnQnhELDREQUFnQkEsQ0FBQyxJQUFJdUQsV0FBV1AsV0FBV0ssUUFBUSxDQUFDRyxjQUFjO1FBQ3RGO1FBQ0FkLE1BQU07UUFDTmUsd0JBQXdCVCxXQUFXVSx5QkFBeUI7UUFDNUQscUVBQXFFO1FBQ3JFQyx5QkFBMEIsQ0FBQ1YsS0FBS0UseUJBQXlCUSx1QkFBdUIsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSUEsS0FBSzVCO0lBQ3ZIO0FBQ0o7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVN1QyxtQ0FBbUNaLFVBQVU7SUFDekQsSUFBSUM7SUFDSix5REFBeUQ7SUFDekQsSUFBSSxZQUFZRCxjQUFjLE9BQU9BLFdBQVdFLE1BQU0sS0FBSyxZQUFZO1FBQ25FLHlDQUF5QztRQUN6QyxPQUFPRixXQUFXRSxNQUFNO0lBQzVCO0lBQ0EsdUVBQXVFO0lBQ3ZFLDZGQUE2RjtJQUM3RixpRkFBaUY7SUFDakYsTUFBTUMsMkJBQTJCSDtJQUNqQyxNQUFNUyx5QkFBeUJULFdBQVdVLHlCQUF5QjtJQUNuRSxNQUFNRyxvQkFBb0JiLFdBQVdLLFFBQVE7SUFDN0MsT0FBTztRQUNIakIsSUFBSVksV0FBV1osRUFBRTtRQUNqQmdCLE9BQU9KLFdBQVdaLEVBQUU7UUFDcEJpQixVQUFVO1lBQ05TLG1CQUFtQjlELDREQUFnQkEsQ0FBQyxJQUFJdUQsV0FBV00sa0JBQWtCQyxpQkFBaUI7WUFDdEZOLGdCQUFnQnhELDREQUFnQkEsQ0FBQyxJQUFJdUQsV0FBV00sa0JBQWtCTCxjQUFjO1lBQ2hGTyxXQUFXL0QsNERBQWdCQSxDQUFDLElBQUl1RCxXQUFXTSxrQkFBa0JFLFNBQVM7WUFDdEVDLFlBQVlILGtCQUFrQkcsVUFBVSxHQUNsQ2hFLDREQUFnQkEsQ0FBQyxJQUFJdUQsV0FBV00sa0JBQWtCRyxVQUFVLEtBQzVEM0M7UUFDVjtRQUNBcUIsTUFBTTtRQUNOZTtRQUNBLHFFQUFxRTtRQUNyRUUseUJBQTBCLENBQUNWLEtBQUtFLHlCQUF5QlEsdUJBQXVCLE1BQU0sUUFBUVYsT0FBTyxLQUFLLElBQUlBLEtBQUs1QjtJQUN2SDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBUzRDLGNBQWNDLFFBQVE7SUFDbEMsT0FDQSx1RUFBdUU7SUFDdkVBLGFBQWEsZUFBZSwwQ0FBMENDLElBQUksQ0FBQ0Q7QUFDL0U7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRTtJQUNMLElBQUluQixJQUFJb0I7SUFDUixPQUFPLENBQUMsQ0FBRWpFLENBQUFBLG1EQUFTQSxNQUNmLHlCQUF5QmtFLFVBQ3pCQSxPQUFPN0MsbUJBQW1CLElBQzFCLGlCQUFpQjhDLGFBQ2pCLE9BQVEsRUFBQ3RCLEtBQUtzQixjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUMsV0FBVyxNQUFNLFFBQVF2QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3QixNQUFNLE1BQU0sY0FDL0ksT0FBUSxFQUFDSixLQUFLRSxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUMsV0FBVyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ssR0FBRyxNQUFNLFVBQVM7QUFDN0o7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLGVBQWVDLGlCQUFpQm5ELE9BQU87SUFDMUMsSUFBSTtRQUNBLE1BQU02QixXQUFXLE1BQU1rQixVQUFVQyxXQUFXLENBQUNDLE1BQU0sQ0FDbkQsK0RBQStELEdBQy9EakQ7UUFDQSxJQUFJLENBQUM2QixVQUFVO1lBQ1gsT0FBTztnQkFDSHVCLE1BQU07Z0JBQ05DLE9BQU8sSUFBSXBFLGtFQUFvQkEsQ0FBQyw2QkFBNkI0QztZQUNqRTtRQUNKO1FBQ0EsSUFBSSxDQUFFQSxDQUFBQSxvQkFBb0I1QixtQkFBa0IsR0FBSTtZQUM1QyxPQUFPO2dCQUNIbUQsTUFBTTtnQkFDTkMsT0FBTyxJQUFJcEUsa0VBQW9CQSxDQUFDLCtDQUErQzRDO1lBQ25GO1FBQ0o7UUFDQSxPQUFPO1lBQUV1QixNQUFNdkI7WUFBVXdCLE9BQU87UUFBSztJQUN6QyxFQUNBLE9BQU9DLEtBQUs7UUFDUixPQUFPO1lBQ0hGLE1BQU07WUFDTkMsT0FBT3ZFLDJFQUF5QkEsQ0FBQztnQkFDN0J1RSxPQUFPQztnQkFDUHREO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLGVBQWV1RCxjQUFjdkQsT0FBTztJQUN2QyxJQUFJO1FBQ0EsTUFBTTZCLFdBQVcsTUFBTWtCLFVBQVVDLFdBQVcsQ0FBQ0UsR0FBRyxDQUNoRCwrREFBK0QsR0FDL0RsRDtRQUNBLElBQUksQ0FBQzZCLFVBQVU7WUFDWCxPQUFPO2dCQUNIdUIsTUFBTTtnQkFDTkMsT0FBTyxJQUFJcEUsa0VBQW9CQSxDQUFDLDZCQUE2QjRDO1lBQ2pFO1FBQ0o7UUFDQSxJQUFJLENBQUVBLENBQUFBLG9CQUFvQjVCLG1CQUFrQixHQUFJO1lBQzVDLE9BQU87Z0JBQ0htRCxNQUFNO2dCQUNOQyxPQUFPLElBQUlwRSxrRUFBb0JBLENBQUMsK0NBQStDNEM7WUFDbkY7UUFDSjtRQUNBLE9BQU87WUFBRXVCLE1BQU12QjtZQUFVd0IsT0FBTztRQUFLO0lBQ3pDLEVBQ0EsT0FBT0MsS0FBSztRQUNSLE9BQU87WUFDSEYsTUFBTTtZQUNOQyxPQUFPeEUsNkVBQTJCQSxDQUFDO2dCQUMvQndFLE9BQU9DO2dCQUNQdEQ7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUNPLE1BQU13RCwyQkFBMkI7SUFDcENDLE9BQU87UUFBQztLQUFlO0lBQ3ZCQyx3QkFBd0I7UUFDcEJ2Qix5QkFBeUI7UUFDekJ3QixvQkFBb0I7UUFDcEIscUVBQXFFLEdBQ3JFQyxrQkFBa0I7UUFDbEJDLGFBQWE7SUFDakI7SUFDQUMsYUFBYTtBQUNqQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCO0lBQ25DLHFFQUFxRSxHQUNyRUgsa0JBQWtCO0lBQ2xCSCxPQUFPO1FBQUM7S0FBZTtJQUN2QkssYUFBYTtBQUNqQixFQUFFO0FBQ0YsU0FBU0U7SUFBVTtRQUFHQyxRQUFILHVCQUFVOztJQUN6QixNQUFNQyxXQUFXLENBQUNDLE1BQVFBLFFBQVEsUUFBUSxPQUFPQSxRQUFRLFlBQVksQ0FBQ3BELE1BQU1xRCxPQUFPLENBQUNEO0lBQ3BGLE1BQU1FLG9CQUFvQixDQUFDRixNQUFRQSxlQUFlRyxlQUFlQSxZQUFZQyxNQUFNLENBQUNKO0lBQ3BGLE1BQU10RCxTQUFTLENBQUM7SUFDaEIsS0FBSyxNQUFNMkQsVUFBVVAsUUFBUztRQUMxQixJQUFJLENBQUNPLFFBQ0Q7UUFDSixJQUFLLE1BQU1DLE9BQU9ELE9BQVE7WUFDdEIsTUFBTUUsUUFBUUYsTUFBTSxDQUFDQyxJQUFJO1lBQ3pCLElBQUlDLFVBQVU3RSxXQUNWO1lBQ0osSUFBSWtCLE1BQU1xRCxPQUFPLENBQUNNLFFBQVE7Z0JBQ3RCLDJFQUEyRTtnQkFDM0U3RCxNQUFNLENBQUM0RCxJQUFJLEdBQUdDO1lBQ2xCLE9BQ0ssSUFBSUwsa0JBQWtCSyxRQUFRO2dCQUMvQjdELE1BQU0sQ0FBQzRELElBQUksR0FBR0M7WUFDbEIsT0FDSyxJQUFJUixTQUFTUSxRQUFRO2dCQUN0QixNQUFNQyxXQUFXOUQsTUFBTSxDQUFDNEQsSUFBSTtnQkFDNUIsSUFBSVAsU0FBU1MsV0FBVztvQkFDcEI5RCxNQUFNLENBQUM0RCxJQUFJLEdBQUdULFVBQVVXLFVBQVVEO2dCQUN0QyxPQUNLO29CQUNEN0QsTUFBTSxDQUFDNEQsSUFBSSxHQUFHVCxVQUFVVTtnQkFDNUI7WUFDSixPQUNLO2dCQUNEN0QsTUFBTSxDQUFDNEQsSUFBSSxHQUFHQztZQUNsQjtRQUNKO0lBQ0o7SUFDQSxPQUFPN0Q7QUFDWDtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVMrRCwrQkFBK0JDLFdBQVcsRUFBRUMsU0FBUztJQUNqRSxPQUFPZCxVQUFVUiwwQkFBMEJxQixhQUFhQyxhQUFhLENBQUM7QUFDMUU7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNDLDhCQUE4QkYsV0FBVyxFQUFFQyxTQUFTO0lBQ2hFLE9BQU9kLFVBQVVELHlCQUF5QmMsYUFBYUMsYUFBYSxDQUFDO0FBQ3pFO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1FO0lBVVQ7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNQyxRQUFRQyxNQUFNLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDQyxNQUFNLENBQUMzRSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUd1RSxTQUFTO1lBQUVJLFlBQVk7UUFBVztJQUNwRztJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRCxNQUFNQyxXQUFXLEtBQTZDLEVBQUVULFNBQVMsRUFBRTtZQUExRCxFQUFFVSxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFL0YsTUFBTSxFQUFHLEdBQTdDO1FBQ2IsSUFBSThCO1FBQ0osSUFBSTtZQUNBLDJEQUEyRDtZQUMzRCxNQUFNLEVBQUUyQixNQUFNdUMsaUJBQWlCLEVBQUV0QyxPQUFPdUMsY0FBYyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNULE1BQU0sQ0FBQ0MsR0FBRyxDQUFDakYsU0FBUyxDQUFDO2dCQUN2RnFGO2dCQUNBQztZQUNKO1lBQ0EsSUFBSSxDQUFDRSxtQkFBbUI7Z0JBQ3BCLE9BQU87b0JBQUV2QyxNQUFNO29CQUFNQyxPQUFPdUM7Z0JBQWU7WUFDL0M7WUFDQSxNQUFNQyxjQUFjbEcsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSUEsU0FBU0cscUJBQXFCWCxvQkFBb0I7WUFDN0csbUVBQW1FLEdBQ25FLElBQUl3RyxrQkFBa0JGLFFBQVEsQ0FBQ3ZFLElBQUksS0FBSyxVQUFVO2dCQUM5QyxNQUFNLEVBQUViLElBQUksRUFBRSxHQUFHc0Ysa0JBQWtCRixRQUFRLENBQUNLLGtCQUFrQixDQUFDQyxTQUFTO2dCQUN4RSxJQUFJLENBQUMxRixLQUFLZCxJQUFJLEVBQUU7b0JBQ1osbUZBQW1GO29CQUNuRiwyRUFBMkU7b0JBQzNFLE1BQU15RyxZQUFZTjtvQkFDbEIsSUFBSSxDQUFDTSxXQUFXO3dCQUNaLHVGQUF1Rjt3QkFDdkYsTUFBTUMsY0FBYyxNQUFNLElBQUksQ0FBQ2QsTUFBTSxDQUFDZSxPQUFPO3dCQUM3QyxNQUFNQyxXQUFXRixZQUFZN0MsSUFBSSxDQUFDL0MsSUFBSTt3QkFDdEMsTUFBTStGLGVBQWUsQ0FBQyxDQUFDM0UsS0FBSzBFLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTRSxhQUFhLE1BQU0sUUFBUTVFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2xDLElBQUksS0FBTTRHLENBQUFBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTRyxLQUFLLEtBQU1ILENBQUFBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTdkYsRUFBRSxLQUFLO3dCQUN0U1AsS0FBS2QsSUFBSSxHQUFHLEdBQWM2RyxPQUFYL0YsS0FBS08sRUFBRSxFQUFDLEtBQWdCLE9BQWJ3RjtvQkFDOUIsT0FDSzt3QkFDRC9GLEtBQUtkLElBQUksR0FBRyxHQUFjeUcsT0FBWDNGLEtBQUtPLEVBQUUsRUFBQyxLQUFhLE9BQVZvRjtvQkFDOUI7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDM0YsS0FBS2tHLFdBQVcsRUFBRTtvQkFDbkJsRyxLQUFLa0csV0FBVyxHQUFHbEcsS0FBS2QsSUFBSTtnQkFDaEM7WUFDSjtZQUNBLE9BQVFvRyxrQkFBa0JGLFFBQVEsQ0FBQ3ZFLElBQUk7Z0JBQ25DLEtBQUs7b0JBQVU7d0JBQ1gsTUFBTWxCLFVBQVU0RSwrQkFBK0JlLGtCQUFrQkYsUUFBUSxDQUFDSyxrQkFBa0IsQ0FBQ0MsU0FBUyxFQUFFakIsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFVBQVU3QixNQUFNO3dCQUM5SyxNQUFNLEVBQUVHLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUYsaUJBQWlCOzRCQUMzQzRDLFdBQVcvRjs0QkFDWEwsUUFBUWtHO3dCQUNaO3dCQUNBLElBQUl6QyxNQUFNOzRCQUNOLE9BQU87Z0NBQ0hBLE1BQU07b0NBQ0ZvQztvQ0FDQWdCLGFBQWFiLGtCQUFrQi9FLEVBQUU7b0NBQ2pDNkUsVUFBVTt3Q0FDTnZFLE1BQU15RSxrQkFBa0JGLFFBQVEsQ0FBQ3ZFLElBQUk7d0NBQ3JDdUYscUJBQXFCckQ7b0NBQ3pCO2dDQUNKO2dDQUNBQyxPQUFPOzRCQUNYO3dCQUNKO3dCQUNBLE9BQU87NEJBQUVELE1BQU07NEJBQU1DO3dCQUFNO29CQUMvQjtnQkFDQSxLQUFLO29CQUFXO3dCQUNaLE1BQU1yRCxVQUFVK0UsOEJBQThCWSxrQkFBa0JGLFFBQVEsQ0FBQ0ssa0JBQWtCLENBQUNDLFNBQVMsRUFBRWpCLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVNEIsT0FBTzt3QkFDOUssTUFBTSxFQUFFdEQsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNRSxjQUFjN0MsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZ0Ysa0JBQWtCRixRQUFRLENBQUNLLGtCQUFrQixHQUFHOzRCQUFFQyxXQUFXL0Y7NEJBQVNMLFFBQVFrRzt3QkFBWTt3QkFDdEssSUFBSXpDLE1BQU07NEJBQ04sT0FBTztnQ0FDSEEsTUFBTTtvQ0FDRm9DO29DQUNBZ0IsYUFBYWIsa0JBQWtCL0UsRUFBRTtvQ0FDakM2RSxVQUFVO3dDQUNOdkUsTUFBTXlFLGtCQUFrQkYsUUFBUSxDQUFDdkUsSUFBSTt3Q0FDckN1RixxQkFBcUJyRDtvQ0FDekI7Z0NBQ0o7Z0NBQ0FDLE9BQU87NEJBQ1g7d0JBQ0o7d0JBQ0EsT0FBTzs0QkFBRUQsTUFBTTs0QkFBTUM7d0JBQU07b0JBQy9CO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJMUUsb0RBQVdBLENBQUMwRSxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE9BQU87Z0JBQ0hELE1BQU07Z0JBQ05DLE9BQU8sSUFBSTNFLHFEQUFnQkEsQ0FBQyxpQ0FBaUMyRTtZQUNqRTtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7T0FXRyxHQUNILE1BQU1zRCxRQUFRLEtBQW9DLEVBQUU7WUFBdEMsRUFBRUgsV0FBVyxFQUFFaEIsUUFBUSxFQUFFQyxRQUFRLEVBQUcsR0FBcEM7UUFDVixPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDQyxHQUFHLENBQUN3QixNQUFNLENBQUM7WUFDMUJwQjtZQUNBZ0I7WUFDQWYsVUFBVUE7UUFDZDtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QsTUFBTW9CLGNBQWMsS0FBd00sRUFBRS9CLFNBQVMsRUFBRTtZQUFyTixFQUFFVSxRQUFRLEVBQUVDLFVBQVUsRUFBRXFCLE9BQU8sS0FBa0IsR0FBY2hFLE9BQU9pRSxRQUFRLENBQUNyRSxRQUFRLEdBQUc3QyxDQUFTLEVBQUVtSCxZQUFZLEtBQWtCLEdBQWM7WUFBQ2xFLE9BQU9pRSxRQUFRLENBQUNFLE1BQU07U0FBQyxHQUFHcEgsQ0FBUyxFQUFFRixNQUFNLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRyxHQUF4TTtRQUNoQixJQUFJLENBQUNtSCxNQUFNO1lBQ1AsT0FBTztnQkFDSDFELE1BQU07Z0JBQ05DLE9BQU8sSUFBSTVFLDhDQUFTQSxDQUFDO1lBQ3pCO1FBQ0o7UUFDQSxJQUFJO1lBQ0EsSUFBSSxDQUFDbUUsMkJBQTJCO2dCQUM1QixPQUFPO29CQUNIUSxNQUFNO29CQUNOQyxPQUFPLElBQUkzRSxxREFBZ0JBLENBQUMscUNBQXFDO2dCQUNyRTtZQUNKO1lBQ0EsK0JBQStCO1lBQy9CLE1BQU0sRUFBRTBFLE1BQU11QyxpQkFBaUIsRUFBRXRDLE9BQU91QyxjQUFjLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ3pGLFNBQVMsQ0FBQztnQkFDNUVxRjtnQkFDQUMsVUFBVTtvQkFBRXFCO29CQUFNRTtnQkFBVTtnQkFDNUJySDtZQUNKLEdBQUc7Z0JBQUUrRyxTQUFTNUI7WUFBVTtZQUN4QixJQUFJLENBQUNhLG1CQUFtQjtnQkFDcEIsT0FBTztvQkFBRXZDLE1BQU07b0JBQU1DLE9BQU91QztnQkFBZTtZQUMvQztZQUNBLE1BQU0sRUFBRUgsUUFBUSxFQUFFLEdBQUdFO1lBQ3JCLG9CQUFvQjtZQUNwQixPQUFPLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQztnQkFDaEJuQjtnQkFDQWdCLGFBQWFiLGtCQUFrQmEsV0FBVztnQkFDMUNmLFVBQVU7b0JBQ052RSxNQUFNdUUsU0FBU3ZFLElBQUk7b0JBQ25CNEY7b0JBQ0FFO29CQUNBUCxxQkFBcUJoQixTQUFTZ0IsbUJBQW1CO2dCQUNyRDtZQUNKO1FBQ0osRUFDQSxPQUFPcEQsT0FBTztZQUNWLElBQUkxRSxvREFBV0EsQ0FBQzBFLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsT0FBTztnQkFDSEQsTUFBTTtnQkFDTkMsT0FBTyxJQUFJM0UscURBQWdCQSxDQUFDLG9DQUFvQzJFO1lBQ3BFO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7OztLQWNDLEdBQ0QsTUFBTTZELFVBQVUsS0FBNE0sRUFBRXBDLFNBQVMsRUFBRTtZQUF6TixFQUFFWSxZQUFZLEVBQUVELFVBQVUsRUFBRXFCLE9BQU8sS0FBa0IsR0FBY2hFLE9BQU9pRSxRQUFRLENBQUNyRSxRQUFRLEdBQUc3QyxDQUFTLEVBQUVtSCxZQUFZLEtBQWtCLEdBQWM7WUFBQ2xFLE9BQU9pRSxRQUFRLENBQUNFLE1BQU07U0FBQyxHQUFHcEgsQ0FBUyxFQUFFRixNQUFNLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRyxHQUE1TTtRQUNaLElBQUksQ0FBQ21ILE1BQU07WUFDUCxPQUFPO2dCQUNIMUQsTUFBTTtnQkFDTkMsT0FBTyxJQUFJNUUsOENBQVNBLENBQUM7WUFDekI7UUFDSjtRQUNBLElBQUk7WUFDQSxJQUFJLENBQUNtRSwyQkFBMkI7Z0JBQzVCLE9BQU87b0JBQ0hRLE1BQU07b0JBQ05DLE9BQU8sSUFBSTNFLHFEQUFnQkEsQ0FBQyxxQ0FBcUM7Z0JBQ3JFO1lBQ0o7WUFDQSxnQkFBZ0I7WUFDaEIsTUFBTSxFQUFFMEUsTUFBTStELE1BQU0sRUFBRTlELE9BQU8rRCxXQUFXLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ25DLE9BQU8sQ0FBQztnQkFDNURTO1lBQ0o7WUFDQSxJQUFJLENBQUN5QixRQUFRO2dCQUNULE1BQU0sSUFBSSxDQUFDaEMsTUFBTSxDQUFDQyxHQUFHLENBQ2hCaUMsV0FBVyxHQUNYQyxJQUFJLENBQUMsQ0FBQ0M7b0JBQ1AsSUFBSTlGO29CQUNKLE9BQU8sQ0FBQ0EsS0FBSzhGLFFBQVFuRSxJQUFJLE1BQU0sUUFBUTNCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRytGLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLFdBQVcsS0FBSyxjQUNqR0QsRUFBRUUsYUFBYSxLQUFLbEMsZ0JBQ3BCZ0MsRUFBRUcsTUFBTSxLQUFLO2dCQUNyQixHQUNLUCxJQUFJLENBQUMsQ0FBQ0gsU0FBWUEsU0FBUyxJQUFJLENBQUNoQyxNQUFNLENBQUNDLEdBQUcsQ0FBQzBDLFFBQVEsQ0FBQzt3QkFBRXRDLFVBQVUyQixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT3ZHLEVBQUU7b0JBQUMsS0FBSyxLQUFLO2dCQUN6SSxPQUFPO29CQUFFd0MsTUFBTTtvQkFBTUMsT0FBTytEO2dCQUFZO1lBQzVDO1lBQ0Esc0NBQXNDO1lBQ3RDLE1BQU0sRUFBRWhFLE1BQU11QyxpQkFBaUIsRUFBRXRDLE9BQU91QyxjQUFjLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0wsVUFBVSxDQUFDO2dCQUM3RUMsVUFBVTJCLE9BQU92RyxFQUFFO2dCQUNuQjhFLGNBQWN5QixPQUFPUyxhQUFhO2dCQUNsQ25DLFVBQVU7b0JBQUVxQjtvQkFBTUU7Z0JBQVU7Z0JBQzVCckg7WUFDSixHQUFHO2dCQUNDc0QsUUFBUTZCO1lBQ1o7WUFDQSxJQUFJLENBQUNhLG1CQUFtQjtnQkFDcEIsT0FBTztvQkFBRXZDLE1BQU07b0JBQU1DLE9BQU91QztnQkFBZTtZQUMvQztZQUNBLE9BQU8sSUFBSSxDQUFDZSxPQUFPLENBQUM7Z0JBQ2hCbkIsVUFBVTJCLE9BQU92RyxFQUFFO2dCQUNuQjRGLGFBQWFiLGtCQUFrQmEsV0FBVztnQkFDMUNmLFVBQVU7b0JBQ05xQjtvQkFDQUU7b0JBQ0E5RixNQUFNeUUsa0JBQWtCRixRQUFRLENBQUN2RSxJQUFJO29CQUNyQ3VGLHFCQUFxQmQsa0JBQWtCRixRQUFRLENBQUNnQixtQkFBbUI7Z0JBQ3ZFO1lBQ0o7UUFDSixFQUNBLE9BQU9wRCxPQUFPO1lBQ1YsSUFBSTFFLG9EQUFXQSxDQUFDMEUsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxPQUFPO2dCQUNIRCxNQUFNO2dCQUNOQyxPQUFPLElBQUkzRSxxREFBZ0JBLENBQUMsZ0NBQWdDMkU7WUFDaEU7UUFDSjtJQUNKO0lBdlJBMEUsWUFBWTVDLE1BQU0sQ0FBRTtRQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDRSxNQUFNLEdBQUcsSUFBSSxDQUFDSixPQUFPLENBQUMrQyxJQUFJLENBQUMsSUFBSTtRQUNwQyxJQUFJLENBQUM3SCxTQUFTLEdBQUcsSUFBSSxDQUFDb0YsVUFBVSxDQUFDeUMsSUFBSSxDQUFDLElBQUk7UUFDMUMsSUFBSSxDQUFDcEIsTUFBTSxHQUFHLElBQUksQ0FBQ0QsT0FBTyxDQUFDcUIsSUFBSSxDQUFDLElBQUk7UUFDcEMsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSSxDQUFDcEIsYUFBYSxDQUFDbUIsSUFBSSxDQUFDLElBQUk7UUFDaEQsSUFBSSxDQUFDRSxRQUFRLEdBQUcsSUFBSSxDQUFDaEIsU0FBUyxDQUFDYyxJQUFJLENBQUMsSUFBSTtJQUM1QztBQWdSSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmpzPzg4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBiYXNlNjRVcmxUb1VpbnQ4QXJyYXksIGJ5dGVzVG9CYXNlNjRVUkwgfSBmcm9tICcuL2Jhc2U2NHVybCc7XG5pbXBvcnQgeyBBdXRoRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciwgaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciwgaXNXZWJBdXRobkVycm9yLCBXZWJBdXRobkVycm9yLCBXZWJBdXRoblVua25vd25FcnJvciwgfSBmcm9tICcuL3dlYmF1dGhuLmVycm9ycyc7XG5leHBvcnQgeyBXZWJBdXRobkVycm9yLCBpc1dlYkF1dGhuRXJyb3IsIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IsIGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciB9O1xuLyoqXG4gKiBXZWJBdXRobiBhYm9ydCBzZXJ2aWNlIHRvIG1hbmFnZSBjZXJlbW9ueSBjYW5jZWxsYXRpb24uXG4gKiBFbnN1cmVzIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUgdG8gcHJldmVudCBcIm9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIgZXJyb3JzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBjbGFzcyBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tYXV0b21hdGlvbi13ZWJkcml2ZXItY2FwYWJpbGl0eSBXM0MgV2ViQXV0aG4gU3BlYyAtIEFib3J0aW5nIENlcmVtb25pZXN9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkFib3J0U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFib3J0IHNpZ25hbCBmb3IgYSBuZXcgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgY2FuY2VscyBhbnkgZXhpc3Rpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fib3J0U2lnbmFsfSBTaWduYWwgdG8gcGFzcyB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgb3IgLmdldCgpXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsIE1ETiAtIEFib3J0U2lnbmFsfVxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0Fib3J0U2lnbmFsKCkge1xuICAgICAgICAvLyBBYm9ydCBhbnkgZXhpc3RpbmcgY2FsbHMgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdDYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsIGZvciBuZXcgb25lJyk7XG4gICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoYWJvcnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3Q29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBjYW5jZWwgdGhlIGN1cnJlbnQgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIFVzZWZ1bCBmb3IgY2xlYW5pbmcgdXAgd2hlbiB1c2VyIGNhbmNlbHMgb3IgbmF2aWdhdGVzIGF3YXkuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRDb250cm9sbGVyL2Fib3J0IE1ETiAtIEFib3J0Q29udHJvbGxlci5hYm9ydH1cbiAgICAgKi9cbiAgICBjYW5jZWxDZXJlbW9ueSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignTWFudWFsbHkgY2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCcpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UgdG8gZW5zdXJlIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUuXG4gKiBUaGlzIHByZXZlbnRzIFwib3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiBlcnJvcnMgd2hlbiByZXRyeWluZyBXZWJBdXRobiBvcGVyYXRpb25zLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBpbnN0YW5jZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKi9cbmV4cG9ydCBjb25zdCB3ZWJBdXRobkFib3J0U2VydmljZSA9IG5ldyBXZWJBdXRobkFib3J0U2VydmljZSgpO1xuLyoqXG4gKiBDb252ZXJ0IGJhc2U2NHVybCBlbmNvZGVkIHN0cmluZ3MgaW4gV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIHRvIEFycmF5QnVmZmVyc1xuICogYXMgcmVxdWlyZWQgYnkgdGhlIFdlYkF1dGhuIGJyb3dzZXIgQVBJLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gSlNPTiBvcHRpb25zIGZyb20gc2VydmVyIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZmllbGRzXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gT3B0aW9ucyByZWFkeSBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBXM0MgV2ViQXV0aG4gU3BlYyAtIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIG1ldGhvZCBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICdwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OJyBpbiBQdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgIHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsXG4gICAgICAgICAgICAucGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSBvcHRpb25zIGhlcmUgYXMgdHlwZXNjcmlwdCBzdGlsbCBkb2Vzbid0IGtub3cgYWJvdXQgZnV0dXJlIHdlYmF1dGhuIHR5cGVzICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgcGFyc2luZyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgbWV0aG9kXG4gICAgLy8gRGVzdHJ1Y3R1cmUgdG8gc2VwYXJhdGUgZmllbGRzIHRoYXQgbmVlZCB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHsgY2hhbGxlbmdlOiBjaGFsbGVuZ2VTdHIsIHVzZXI6IHVzZXJPcHRzLCBleGNsdWRlQ3JlZGVudGlhbHMgfSA9IG9wdGlvbnMsIHJlc3RPcHRpb25zID0gX19yZXN0KG9wdGlvbnNcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgICwgW1wiY2hhbGxlbmdlXCIsIFwidXNlclwiLCBcImV4Y2x1ZGVDcmVkZW50aWFsc1wiXSk7XG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY2hhbGxlbmdlU3RyKS5idWZmZXI7XG4gICAgLy8gQ29udmVydCB1c2VyLmlkIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXNlck9wdHMpLCB7IGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkodXNlck9wdHMuaWQpLmJ1ZmZlciB9KTtcbiAgICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE9wdGlvbnMpLCB7IGNoYWxsZW5nZSxcbiAgICAgICAgdXNlciB9KTtcbiAgICAvLyBPbmx5IGFkZCBleGNsdWRlQ3JlZGVudGlhbHMgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGV4Y2x1ZGVDcmVkZW50aWFscyAmJiBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzID0gbmV3IEFycmF5KGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGV4Y2x1ZGVDcmVkZW50aWFsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5leGNsdWRlQ3JlZGVudGlhbHNbaV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWQpLCB7IGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY3JlZC5pZCkuYnVmZmVyLCB0eXBlOiBjcmVkLnR5cGUgfHwgJ3B1YmxpYy1rZXknLCBcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHRyYW5zcG9ydHMgdG8gaGFuZGxlIGZ1dHVyZSB0cmFuc3BvcnQgdHlwZXMgbGlrZSBcImNhYmxlXCJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzOiBjcmVkLnRyYW5zcG9ydHMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHRvIEFycmF5QnVmZmVyc1xuICogYXMgcmVxdWlyZWQgYnkgdGhlIFdlYkF1dGhuIGJyb3dzZXIgQVBJLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlckNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gT3B0aW9ucyByZWFkeSBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIFczQyBXZWJBdXRobiBTcGVjIC0gcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgbmF0aXZlIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBtZXRob2QgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAncGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OJyBpbiBQdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgIHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsXG4gICAgICAgICAgICAucGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBQdWJsaWNLZXlDcmVkZW50aWFsLnBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTihvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHBhcnNpbmcgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIG1ldGhvZFxuICAgIC8vIERlc3RydWN0dXJlIHRvIHNlcGFyYXRlIGZpZWxkcyB0aGF0IG5lZWQgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB7IGNoYWxsZW5nZTogY2hhbGxlbmdlU3RyLCBhbGxvd0NyZWRlbnRpYWxzIH0gPSBvcHRpb25zLCByZXN0T3B0aW9ucyA9IF9fcmVzdChvcHRpb25zXG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICAsIFtcImNoYWxsZW5nZVwiLCBcImFsbG93Q3JlZGVudGlhbHNcIl0pO1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgY2hhbGxlbmdlID0gYmFzZTY0VXJsVG9VaW50OEFycmF5KGNoYWxsZW5nZVN0cikuYnVmZmVyO1xuICAgIC8vIEJ1aWxkIHRoZSByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0T3B0aW9ucyksIHsgY2hhbGxlbmdlIH0pO1xuICAgIC8vIE9ubHkgYWRkIGFsbG93Q3JlZGVudGlhbHMgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGFsbG93Q3JlZGVudGlhbHMgJiYgYWxsb3dDcmVkZW50aWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5hbGxvd0NyZWRlbnRpYWxzID0gbmV3IEFycmF5KGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkID0gYWxsb3dDcmVkZW50aWFsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hbGxvd0NyZWRlbnRpYWxzW2ldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVkKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlciwgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JywgXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0czogY3JlZC50cmFuc3BvcnRzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbnZlcnQgYSByZWdpc3RyYXRpb24vZW5yb2xsbWVudCBjcmVkZW50aWFsIHJlc3BvbnNlIHRvIHNlcnZlciBmb3JtYXQuXG4gKiBTZXJpYWxpemVzIGJpbmFyeSBmaWVsZHMgdG8gYmFzZTY0dXJsIGZvciBKU09OIHRyYW5zbWlzc2lvbi5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgdG9KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtSZWdpc3RyYXRpb25DcmVkZW50aWFsfSBjcmVkZW50aWFsIC0gQ3JlZGVudGlhbCBmcm9tIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHJldHVybnMge1JlZ2lzdHJhdGlvblJlc3BvbnNlSlNPTn0gSlNPTi1zZXJpYWxpemFibGUgY3JlZGVudGlhbCBmb3Igc2VydmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RvbS1wdWJsaWNrZXljcmVkZW50aWFsLXRvanNvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIHRvSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKGNyZWRlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gICAgaWYgKCd0b0pTT04nIGluIGNyZWRlbnRpYWwgJiYgdHlwZW9mIGNyZWRlbnRpYWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgICBjb25zdCBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQgPSBjcmVkZW50aWFsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF0dGVzdGF0aW9uT2JqZWN0OiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGNyZWRlbnRpYWwucmVzcG9uc2UuYXR0ZXN0YXRpb25PYmplY3QpKSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGNyZWRlbnRpYWwucmVzcG9uc2UuY2xpZW50RGF0YUpTT04pKSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzOiBjcmVkZW50aWFsLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKSxcbiAgICAgICAgLy8gQ29udmVydCBudWxsIHRvIHVuZGVmaW5lZCBhbmQgY2FzdCB0byBBdXRoZW50aWNhdG9yQXR0YWNobWVudCB0eXBlXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAoKF9hID0gY3JlZGVudGlhbFdpdGhBdHRhY2htZW50LmF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYW4gYXV0aGVudGljYXRpb24vdmVyaWZpY2F0aW9uIGNyZWRlbnRpYWwgcmVzcG9uc2UgdG8gc2VydmVyIGZvcm1hdC5cbiAqIFNlcmlhbGl6ZXMgYmluYXJ5IGZpZWxkcyB0byBiYXNlNjR1cmwgZm9yIEpTT04gdHJhbnNtaXNzaW9uLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyB0b0pTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAqIEByZXR1cm5zIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlSlNPTn0gSlNPTi1zZXJpYWxpemFibGUgY3JlZGVudGlhbCBmb3Igc2VydmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RvbS1wdWJsaWNrZXljcmVkZW50aWFsLXRvanNvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIHRvSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UoY3JlZGVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBDaGVjayBpZiB0aGUgY3JlZGVudGlhbCBpbnN0YW5jZSBoYXMgdGhlIHRvSlNPTiBtZXRob2RcbiAgICBpZiAoJ3RvSlNPTicgaW4gY3JlZGVudGlhbCAmJiB0eXBlb2YgY3JlZGVudGlhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWwudG9KU09OKCk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBjb252ZXJzaW9uIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdG9KU09OXG4gICAgLy8gQWNjZXNzIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHZpYSB0eXBlIGFzc2VydGlvbiB0byBoYW5kbGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGRpZmZlcmVuY2VzXG4gICAgLy8gQHNpbXBsZXdlYmF1dGhuL3R5cGVzIGluY2x1ZGVzIHRoaXMgcHJvcGVydHkgYnV0IGJhc2UgVHlwZVNjcmlwdCA0LjcuNCBkb2Vzbid0XG4gICAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbDtcbiAgICBjb25zdCBjbGllbnRFeHRlbnNpb25SZXN1bHRzID0gY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCk7XG4gICAgY29uc3QgYXNzZXJ0aW9uUmVzcG9uc2UgPSBjcmVkZW50aWFsLnJlc3BvbnNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCwgLy8gVzNDIHNwZWMgZXhwZWN0cyByYXdJZCB0byBtYXRjaCBpZCBmb3IgSlNPTiBmb3JtYXRcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhKSksXG4gICAgICAgICAgICBjbGllbnREYXRhSlNPTjogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5jbGllbnREYXRhSlNPTikpLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLnNpZ25hdHVyZSkpLFxuICAgICAgICAgICAgdXNlckhhbmRsZTogYXNzZXJ0aW9uUmVzcG9uc2UudXNlckhhbmRsZVxuICAgICAgICAgICAgICAgID8gYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS51c2VySGFuZGxlKSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzLFxuICAgICAgICAvLyBDb252ZXJ0IG51bGwgdG8gdW5kZWZpbmVkIGFuZCBjYXN0IHRvIEF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHR5cGVcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICgoX2EgPSBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCksXG4gICAgfTtcbn1cbi8qKlxuICogQSBzaW1wbGUgdGVzdCB0byBkZXRlcm1pbmUgaWYgYSBob3N0bmFtZSBpcyBhIHByb3Blcmx5LWZvcm1hdHRlZCBkb21haW4gbmFtZS5cbiAqIENvbnNpZGVycyBsb2NhbGhvc3QgdmFsaWQgZm9yIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAqXG4gKiBBIFwidmFsaWQgZG9tYWluXCIgaXMgZGVmaW5lZCBoZXJlOiBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3ZhbGlkLWRvbWFpblxuICpcbiAqIFJlZ2V4IHNvdXJjZWQgZnJvbSBoZXJlOlxuICogaHR0cHM6Ly93d3cub3JlaWxseS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MTQ0OTMyNzQ1My9jaDA4czE1Lmh0bWxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWUgLSBUaGUgaG9zdG5hbWUgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIGRvbWFpbiBvciBsb2NhbGhvc3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdmFsaWQtZG9tYWluIFdIQVRXRyBVUkwgU3BlYyAtIFZhbGlkIERvbWFpbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREb21haW4oaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgIC8vIENvbnNpZGVyIGxvY2FsaG9zdCB2YWxpZCBhcyB3ZWxsIHNpbmNlIGl0J3Mgb2theSB3cnQgU2VjdXJlIENvbnRleHRzXG4gICAgaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IC9eKFthLXowLTldKygtW2EtejAtOV0rKSpcXC4pK1thLXpdezIsfSQvaS50ZXN0KGhvc3RuYW1lKSk7XG59XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIFdlYkF1dGhuLlxuICogQ2hlY2tzIGZvciBuZWNlc3NhcnkgV2ViIEFQSXM6IFB1YmxpY0tleUNyZWRlbnRpYWwgYW5kIENyZWRlbnRpYWwgTWFuYWdlbWVudC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIFdlYkF1dGhuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVibGljS2V5Q3JlZGVudGlhbCNicm93c2VyX2NvbXBhdGliaWxpdHkgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbCBCcm93c2VyIENvbXBhdGliaWxpdHl9XG4gKi9cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuICEhKGlzQnJvd3NlcigpICYmXG4gICAgICAgICdQdWJsaWNLZXlDcmVkZW50aWFsJyBpbiB3aW5kb3cgJiZcbiAgICAgICAgd2luZG93LlB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICAgICAgJ2NyZWRlbnRpYWxzJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICAgdHlwZW9mICgoX2EgPSBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGUpID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiAoKF9iID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdXNpbmcgdGhlIGJyb3dzZXIncyBjcmVkZW50aWFscyBBUEkuXG4gKiBXcmFwcyBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgd2l0aCBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25zIGluY2x1ZGluZyBwdWJsaWNLZXkgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxSZWdpc3RyYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj59IENyZWF0ZWQgY3JlZGVudGlhbCBvciBlcnJvclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVhdGUgQ3JlZGVudGlhbH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcmVkZW50aWFsc0NvbnRhaW5lci9jcmVhdGUgTUROIC0gY3JlZGVudGlhbHMuY3JlYXRlfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ3JlZGVudGlhbChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSB0eXBlIGhlcmUgdW50aWwgdHlwZXNjcmlwdCB0eXBlcyBhcmUgdXBkYXRlZCAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0VtcHR5IGNyZWRlbnRpYWwgcmVzcG9uc2UnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUHVibGljS2V5Q3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdCcm93c2VyIHJldHVybmVkIHVuZXhwZWN0ZWQgY3JlZGVudGlhbCB0eXBlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEdldCBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdXNpbmcgdGhlIGJyb3dzZXIncyBjcmVkZW50aWFscyBBUEkuXG4gKiBXcmFwcyBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KCkgd2l0aCBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbnMgaW5jbHVkaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBSZXRyaWV2ZWQgY3JlZGVudGlhbCBvciBlcnJvclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvZ2V0IE1ETiAtIGNyZWRlbnRpYWxzLmdldH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENyZWRlbnRpYWwob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgdHlwZSBoZXJlIHVudGlsIHR5cGVzY3JpcHQgdHlwZXMgYXJlIHVwZGF0ZWQgKi9cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdFbXB0eSBjcmVkZW50aWFsIHJlc3BvbnNlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignQnJvd3NlciByZXR1cm5lZCB1bmV4cGVjdGVkIGNyZWRlbnRpYWwgdHlwZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UsIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9DUkVBVElPTl9PUFRJT05TID0ge1xuICAgIGhpbnRzOiBbJ3NlY3VyaXR5LWtleSddLFxuICAgIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb246IHtcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICdjcm9zcy1wbGF0Zm9ybScsXG4gICAgICAgIHJlcXVpcmVSZXNpZGVudEtleTogZmFsc2UsXG4gICAgICAgIC8qKiBzZXQgdG8gcHJlZmVycmVkIGJlY2F1c2Ugb2xkZXIgeXViaWtleXMgZG9uJ3QgaGF2ZSBQSU4vQmlvbWV0cmljICovXG4gICAgICAgIHVzZXJWZXJpZmljYXRpb246ICdwcmVmZXJyZWQnLFxuICAgICAgICByZXNpZGVudEtleTogJ2Rpc2NvdXJhZ2VkJyxcbiAgICB9LFxuICAgIGF0dGVzdGF0aW9uOiAnZGlyZWN0Jyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVFVRVNUX09QVElPTlMgPSB7XG4gICAgLyoqIHNldCB0byBwcmVmZXJyZWQgYmVjYXVzZSBvbGRlciB5dWJpa2V5cyBkb24ndCBoYXZlIFBJTi9CaW9tZXRyaWMgKi9cbiAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbiAgICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG59O1xuZnVuY3Rpb24gZGVlcE1lcmdlKC4uLnNvdXJjZXMpIHtcbiAgICBjb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIGNvbnN0IGlzQXJyYXlCdWZmZXJMaWtlID0gKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIGFycmF5IHJlZmVyZW5jZSwgaW5jbHVkaW5nIHVuaW9ucyBsaWtlIEF1dGhlbnRpY2F0b3JUcmFuc3BvcnRbXVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKGV4aXN0aW5nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZXMgV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIHdpdGggb3ZlcnJpZGVzLlxuICogU2V0cyBzZW5zaWJsZSBkZWZhdWx0cyBmb3IgYXV0aGVudGljYXRvciBzZWxlY3Rpb24gYW5kIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBiYXNlT3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnMgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE9wdGlvbmFsIG92ZXJyaWRlcyB0byBhcHBseVxuICogQHBhcmFtIHtzdHJpbmd9IGZyaWVuZGx5TmFtZSAtIE9wdGlvbmFsIGZyaWVuZGx5IG5hbWUgZm9yIHRoZSBjcmVkZW50aWFsXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gTWVyZ2VkIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkaWN0ZGVmLWF1dGhlbnRpY2F0b3JzZWxlY3Rpb25jcml0ZXJpYSBXM0MgV2ViQXV0aG4gU3BlYyAtIEF1dGhlbnRpY2F0b3JTZWxlY3Rpb25Dcml0ZXJpYX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhiYXNlT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZShERUZBVUxUX0NSRUFUSU9OX09QVElPTlMsIGJhc2VPcHRpb25zLCBvdmVycmlkZXMgfHwge30pO1xufVxuLyoqXG4gKiBNZXJnZXMgV2ViQXV0aG4gY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgd2l0aCBvdmVycmlkZXMuXG4gKiBTZXRzIHNlbnNpYmxlIGRlZmF1bHRzIGZvciB1c2VyIHZlcmlmaWNhdGlvbiBhbmQgaGludHMuXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkaWN0ZGVmLXB1YmxpY2tleWNyZWRlbnRpYWxyZXF1ZXN0b3B0aW9ucyBXM0MgV2ViQXV0aG4gU3BlYyAtIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKGJhc2VPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZGVlcE1lcmdlKERFRkFVTFRfUkVRVUVTVF9PUFRJT05TLCBiYXNlT3B0aW9ucywgb3ZlcnJpZGVzIHx8IHt9KTtcbn1cbi8qKlxuICogV2ViQXV0aG4gQVBJIHdyYXBwZXIgZm9yIFN1cGFiYXNlIEF1dGguXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBlbnJvbGxpbmcsIGNoYWxsZW5naW5nLCB2ZXJpZnlpbmcsIGF1dGhlbnRpY2F0aW5nLCBhbmQgcmVnaXN0ZXJpbmcgV2ViQXV0aG4gY3JlZGVudGlhbHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vIFczQyBXZWJBdXRobiBTcGVjaWZpY2F0aW9ufVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BdXRoZW50aWNhdGlvbl9BUEkgTUROIC0gV2ViIEF1dGhlbnRpY2F0aW9uIEFQSX1cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkF1dGhuQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8vIEJpbmQgYWxsIG1ldGhvZHMgc28gdGhleSBjYW4gYmUgZGVzdHJ1Y3R1cmVkXG4gICAgICAgIHRoaXMuZW5yb2xsID0gdGhpcy5fZW5yb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlID0gdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmVyaWZ5ID0gdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlID0gdGhpcy5fYXV0aGVudGljYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLl9yZWdpc3Rlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnJvbGwgYSBuZXcgV2ViQXV0aG4gZmFjdG9yLlxuICAgICAqIENyZWF0ZXMgYW4gdW52ZXJpZmllZCBXZWJBdXRobiBmYWN0b3IgdGhhdCBtdXN0IGJlIHZlcmlmaWVkIHdpdGggYSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPbWl0PE1GQUVucm9sbFdlYmF1dGhuUGFyYW1zLCAnZmFjdG9yVHlwZSc+fSBwYXJhbXMgLSBFbnJvbGxtZW50IHBhcmFtZXRlcnMgKGZyaWVuZGx5TmFtZSByZXF1aXJlZClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZT59IEVucm9sbGVkIGZhY3RvciBkZXRhaWxzIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RlcmluZyBhIE5ldyBDcmVkZW50aWFsfVxuICAgICAqL1xuICAgIGFzeW5jIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5tZmEuZW5yb2xsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBmYWN0b3JUeXBlOiAnd2ViYXV0aG4nIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbGxlbmdlIGZvciBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIENvbWJpbmVzIHNlcnZlciBjaGFsbGVuZ2Ugd2l0aCBicm93c2VyIGNyZWRlbnRpYWwgb3BlcmF0aW9ucy5cbiAgICAgKiBIYW5kbGVzIGJvdGggcmVnaXN0cmF0aW9uIChjcmVhdGUpIGFuZCBhdXRoZW50aWNhdGlvbiAocmVxdWVzdCkgZmxvd3MuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge01GQUNoYWxsZW5nZVdlYmF1dGhuUGFyYW1zICYgeyBmcmllbmRseU5hbWU/OiBzdHJpbmc7IHNpZ25hbD86IEFib3J0U2lnbmFsIH19IHBhcmFtcyAtIENoYWxsZW5nZSBwYXJhbWV0ZXJzIGluY2x1ZGluZyBmYWN0b3JJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgLSBBbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHNcbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5jcmVhdGUgLSBPdmVycmlkZSBvcHRpb25zIGZvciBjcmVkZW50aWFsIGNyZWF0aW9uXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5yZXF1ZXN0IC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgY3JlZGVudGlhbCByZXF1ZXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdD59IENoYWxsZW5nZSByZXNwb25zZSB3aXRoIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlZGVudGlhbC1jcmVhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWRlbnRpYWwgQ3JlYXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgQXNzZXJ0aW9ufVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2UoeyBmYWN0b3JJZCwgd2ViYXV0aG4sIGZyaWVuZGx5TmFtZSwgc2lnbmFsLCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGNoYWxsZW5nZSBmcm9tIHNlcnZlciB1c2luZyB0aGUgY2xpZW50J3MgTUZBIG1ldGhvZHNcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlUmVzcG9uc2UsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQubWZhLmNoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbGxlbmdlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0U2lnbmFsID0gc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdm9pZCAwID8gc2lnbmFsIDogd2ViQXV0aG5BYm9ydFNlcnZpY2UuY3JlYXRlTmV3QWJvcnRTaWduYWwoKTtcbiAgICAgICAgICAgIC8qKiB3ZWJhdXRobiB3aWxsIGZhaWwgaWYgZWl0aGVyIG9mIHRoZSBuYW1lL2Rpc3BsYXluYW1lIGFyZSBibGFuayAqL1xuICAgICAgICAgICAgaWYgKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5O1xuICAgICAgICAgICAgICAgIGlmICghdXNlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGZvcm1hdDogdXNlIGZyaWVuZGx5TmFtZSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZldGNoIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFpbnRhaW5zIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgJHt1c2VyLmlkfToke25hbWV9IGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lVG9Vc2UgPSBmcmllbmRseU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZVRvVXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGZldGNoIHVzZXIgZGF0YSBpZiBmcmllbmRseU5hbWUgaXMgbm90IHByb3ZpZGVkIChidWcgZml4IGZvciBudWxsIGZyaWVuZGx5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0VXNlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBjdXJyZW50VXNlci5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja05hbWUgPSAoKF9hID0gdXNlckRhdGEgPT09IG51bGwgfHwgdXNlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJEYXRhLnVzZXJfbWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSB8fCAodXNlckRhdGEgPT09IG51bGwgfHwgdXNlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJEYXRhLmVtYWlsKSB8fCAodXNlckRhdGEgPT09IG51bGwgfHwgdXNlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJEYXRhLmlkKSB8fCAnVXNlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyLm5hbWUgPSBgJHt1c2VyLmlkfToke2ZhbGxiYWNrTmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5uYW1lID0gYCR7dXNlci5pZH06JHtuYW1lVG9Vc2V9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5kaXNwbGF5TmFtZSA9IHVzZXIubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLmNyZWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNyZWF0ZUNyZWRlbnRpYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcXVlc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGdldENyZWRlbnRpYWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogb3B0aW9ucywgc2lnbmFsOiBhYm9ydFNpZ25hbCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGNoYWxsZW5nZScsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGEgV2ViQXV0aG4gY3JlZGVudGlhbCB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICogQ29tcGxldGVzIHRoZSBXZWJBdXRobiBjZXJlbW9ueSBieSBzZW5kaW5nIHRoZSBjcmVkZW50aWFsIHRvIHRoZSBzZXJ2ZXIgZm9yIHZlcmlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBWZXJpZmljYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbGxlbmdlSWQgLSBJRCBvZiB0aGUgY2hhbGxlbmdlIGJlaW5nIHZlcmlmaWVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge01GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPFQ+Wyd3ZWJhdXRobiddfSBwYXJhbXMud2ViYXV0aG4gLSBXZWJBdXRobiBjcmVkZW50aWFsIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPn0gVmVyaWZpY2F0aW9uIHJlc3VsdCB3aXRoIHNlc3Npb24gb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tdmVyaWZ5aW5nLWFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIFZlcmlmeWluZyBhbiBBdXRoZW50aWNhdGlvbiBBc3NlcnRpb259XG4gICAgICogKi9cbiAgICBhc3luYyBfdmVyaWZ5KHsgY2hhbGxlbmdlSWQsIGZhY3RvcklkLCB3ZWJhdXRobiwgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubWZhLnZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgIGNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgd2ViYXV0aG46IHdlYmF1dGhuLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgV2ViQXV0aG4gYXV0aGVudGljYXRpb24gZmxvdy5cbiAgICAgKiBQZXJmb3JtcyBjaGFsbGVuZ2UgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIGV4aXN0aW5nIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZhY3RvcklkIC0gSUQgb2YgdGhlIFdlYkF1dGhuIGZhY3RvciB0byBhdXRoZW50aWNhdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMud2ViYXV0aG4gLSBXZWJBdXRobiBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy53ZWJhdXRobi5ycElkIC0gUmVseWluZyBQYXJ0eSBJRCAoZGVmYXVsdHMgdG8gY3VycmVudCBob3N0bmFtZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMud2ViYXV0aG4ucnBPcmlnaW5zIC0gQWxsb3dlZCBvcmlnaW5zIChkZWZhdWx0cyB0byBjdXJyZW50IG9yaWdpbilcbiAgICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBwYXJhbXMud2ViYXV0aG4uc2lnbmFsIC0gT3B0aW9uYWwgYWJvcnQgc2lnbmFsXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhNRkFWZXJpZnlSZXNwb25zZURhdGEsIFdlYkF1dGhuRXJyb3IgfCBBdXRoRXJyb3I+Pn0gQXV0aGVudGljYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dGhlbnRpY2F0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gQXV0aGVudGljYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyBNRE4gLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gICAgICovXG4gICAgYXN5bmMgX2F1dGhlbnRpY2F0ZSh7IGZhY3RvcklkLCB3ZWJhdXRobjogeyBycElkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgOiB1bmRlZmluZWQsIHJwT3JpZ2lucyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gW3dpbmRvdy5sb2NhdGlvbi5vcmlnaW5dIDogdW5kZWZpbmVkLCBzaWduYWwsIH0gPSB7fSwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghcnBJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiBhdXRoZW50aWNhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGNoYWxsZW5nZSBhbmQgY3JlZGVudGlhbFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHsgcnBJZCwgcnBPcmlnaW5zIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgfSwgeyByZXF1ZXN0OiBvdmVycmlkZXMgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdlYmF1dGhuIH0gPSBjaGFsbGVuZ2VSZXNwb25zZTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSBjcmVkZW50aWFsXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogd2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiB3ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGUnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbiBmbG93LlxuICAgICAqIFBlcmZvcm1zIGVucm9sbG1lbnQsIGNoYWxsZW5nZSwgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIG5ldyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZnJpZW5kbHlOYW1lIC0gVXNlci1mcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+fSBSZWdpc3RyYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RyYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc31cbiAgICAgKi9cbiAgICBhc3luYyBfcmVnaXN0ZXIoeyBmcmllbmRseU5hbWUsIHdlYmF1dGhuOiB7IHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCwgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsIHNpZ25hbCwgfSA9IHt9LCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCFycElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5yb2xsIGZhY3RvclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBmYWN0b3IsIGVycm9yOiBlbnJvbGxFcnJvciB9ID0gYXdhaXQgdGhpcy5fZW5yb2xsKHtcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQubWZhXG4gICAgICAgICAgICAgICAgICAgIC5saXN0RmFjdG9ycygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGZhY3RvcnMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbC5maW5kKCh2KSA9PiB2LmZhY3Rvcl90eXBlID09PSAnd2ViYXV0aG4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmZyaWVuZGx5X25hbWUgPT09IGZyaWVuZGx5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0dXMgIT09ICd1bnZlcmlmaWVkJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGZhY3RvcikgPT4gKGZhY3RvciA/IHRoaXMuY2xpZW50Lm1mYS51bmVucm9sbCh7IGZhY3RvcklkOiBmYWN0b3IgPT09IG51bGwgfHwgZmFjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWN0b3IuaWQgfSkgOiB2b2lkIDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZW5yb2xsRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWF0ZSBjcmVkZW50aWFsXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWU6IGZhY3Rvci5mcmllbmRseV9uYW1lLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjcmVhdGU6IG92ZXJyaWRlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiByZWdpc3RlcicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiYmFzZTY0VXJsVG9VaW50OEFycmF5IiwiYnl0ZXNUb0Jhc2U2NFVSTCIsIkF1dGhFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJpc0F1dGhFcnJvciIsImlzQnJvd3NlciIsImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciIsImlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IiLCJpc1dlYkF1dGhuRXJyb3IiLCJXZWJBdXRobkVycm9yIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJXZWJBdXRobkFib3J0U2VydmljZSIsImNyZWF0ZU5ld0Fib3J0U2lnbmFsIiwiY29udHJvbGxlciIsImFib3J0RXJyb3IiLCJFcnJvciIsIm5hbWUiLCJhYm9ydCIsIm5ld0NvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJjYW5jZWxDZXJlbW9ueSIsInVuZGVmaW5lZCIsIndlYkF1dGhuQWJvcnRTZXJ2aWNlIiwiZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwib3B0aW9ucyIsIlB1YmxpY0tleUNyZWRlbnRpYWwiLCJwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlU3RyIiwidXNlciIsInVzZXJPcHRzIiwiZXhjbHVkZUNyZWRlbnRpYWxzIiwicmVzdE9wdGlvbnMiLCJidWZmZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJpZCIsInJlc3VsdCIsImxlbmd0aCIsIkFycmF5IiwiaSIsImNyZWQiLCJ0eXBlIiwidHJhbnNwb3J0cyIsImRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwicGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIiwiYWxsb3dDcmVkZW50aWFscyIsInNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlIiwiY3JlZGVudGlhbCIsIl9hIiwidG9KU09OIiwiY3JlZGVudGlhbFdpdGhBdHRhY2htZW50IiwicmF3SWQiLCJyZXNwb25zZSIsImF0dGVzdGF0aW9uT2JqZWN0IiwiVWludDhBcnJheSIsImNsaWVudERhdGFKU09OIiwiY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyIsImdldENsaWVudEV4dGVuc2lvblJlc3VsdHMiLCJhdXRoZW50aWNhdG9yQXR0YWNobWVudCIsInNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UiLCJhc3NlcnRpb25SZXNwb25zZSIsImF1dGhlbnRpY2F0b3JEYXRhIiwic2lnbmF0dXJlIiwidXNlckhhbmRsZSIsImlzVmFsaWREb21haW4iLCJob3N0bmFtZSIsInRlc3QiLCJicm93c2VyU3VwcG9ydHNXZWJBdXRobiIsIl9iIiwid2luZG93IiwibmF2aWdhdG9yIiwiY3JlZGVudGlhbHMiLCJjcmVhdGUiLCJnZXQiLCJjcmVhdGVDcmVkZW50aWFsIiwiZGF0YSIsImVycm9yIiwiZXJyIiwiZ2V0Q3JlZGVudGlhbCIsIkRFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUyIsImhpbnRzIiwiYXV0aGVudGljYXRvclNlbGVjdGlvbiIsInJlcXVpcmVSZXNpZGVudEtleSIsInVzZXJWZXJpZmljYXRpb24iLCJyZXNpZGVudEtleSIsImF0dGVzdGF0aW9uIiwiREVGQVVMVF9SRVFVRVNUX09QVElPTlMiLCJkZWVwTWVyZ2UiLCJzb3VyY2VzIiwiaXNPYmplY3QiLCJ2YWwiLCJpc0FycmF5IiwiaXNBcnJheUJ1ZmZlckxpa2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInNvdXJjZSIsImtleSIsInZhbHVlIiwiZXhpc3RpbmciLCJtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMiLCJiYXNlT3B0aW9ucyIsIm92ZXJyaWRlcyIsIm1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwiV2ViQXV0aG5BcGkiLCJfZW5yb2xsIiwicGFyYW1zIiwiY2xpZW50IiwibWZhIiwiZW5yb2xsIiwiZmFjdG9yVHlwZSIsIl9jaGFsbGVuZ2UiLCJmYWN0b3JJZCIsIndlYmF1dGhuIiwiZnJpZW5kbHlOYW1lIiwiY2hhbGxlbmdlUmVzcG9uc2UiLCJjaGFsbGVuZ2VFcnJvciIsImFib3J0U2lnbmFsIiwiY3JlZGVudGlhbF9vcHRpb25zIiwicHVibGljS2V5IiwibmFtZVRvVXNlIiwiY3VycmVudFVzZXIiLCJnZXRVc2VyIiwidXNlckRhdGEiLCJmYWxsYmFja05hbWUiLCJ1c2VyX21ldGFkYXRhIiwiZW1haWwiLCJkaXNwbGF5TmFtZSIsImNoYWxsZW5nZUlkIiwiY3JlZGVudGlhbF9yZXNwb25zZSIsInJlcXVlc3QiLCJfdmVyaWZ5IiwidmVyaWZ5IiwiX2F1dGhlbnRpY2F0ZSIsInJwSWQiLCJsb2NhdGlvbiIsInJwT3JpZ2lucyIsIm9yaWdpbiIsIl9yZWdpc3RlciIsImZhY3RvciIsImVucm9sbEVycm9yIiwibGlzdEZhY3RvcnMiLCJ0aGVuIiwiZmFjdG9ycyIsImFsbCIsImZpbmQiLCJ2IiwiZmFjdG9yX3R5cGUiLCJmcmllbmRseV9uYW1lIiwic3RhdHVzIiwidW5lbnJvbGwiLCJjb25zdHJ1Y3RvciIsImJpbmQiLCJhdXRoZW50aWNhdGUiLCJyZWdpc3RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: function() { return /* binding */ FunctionsClient; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n\n\n\n/**\n * Client for invoking Supabase Edge Functions.\n */ class FunctionsClient {\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     * @example\n     * ```ts\n     * functions.setAuth(session.access_token)\n     * ```\n     */ setAuth(token) {\n        this.headers.Authorization = \"Bearer \".concat(token);\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     * @example\n     * ```ts\n     * const { data, error } = await functions.invoke('hello-world', {\n     *   body: { name: 'Ada' },\n     * })\n     * ```\n     */ invoke(functionName_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, arguments, void 0, function*(functionName) {\n            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            var _a;\n            let timeoutId;\n            let timeoutController;\n            try {\n                const { headers, method, body: functionArgs, signal, timeout } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(\"\".concat(this.url, \"/\").concat(functionName));\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                    url.searchParams.set(\"forceFunctionRegion\", region);\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                } else {\n                    if (functionArgs && typeof functionArgs !== \"string\" && !(typeof Blob !== \"undefined\" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== \"undefined\" && functionArgs instanceof FormData)) {\n                        body = JSON.stringify(functionArgs);\n                    } else {\n                        body = functionArgs;\n                    }\n                }\n                // Handle timeout by creating an AbortController\n                let effectiveSignal = signal;\n                if (timeout) {\n                    timeoutController = new AbortController();\n                    timeoutId = setTimeout(()=>timeoutController.abort(), timeout);\n                    // If user provided their own signal, we need to respect both\n                    if (signal) {\n                        effectiveSignal = timeoutController.signal;\n                        // If the user's signal is aborted, abort our timeout controller too\n                        signal.addEventListener(\"abort\", ()=>timeoutController.abort());\n                    } else {\n                        effectiveSignal = timeoutController.signal;\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal: effectiveSignal\n                }).catch((fetchError)=>{\n                    throw new _types__WEBPACK_IMPORTED_MODULE_1__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_1__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_1__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\" || responseType === \"application/pdf\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null,\n                    response\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof _types__WEBPACK_IMPORTED_MODULE_1__.FunctionsHttpError || error instanceof _types__WEBPACK_IMPORTED_MODULE_1__.FunctionsRelayError ? error.context : undefined\n                };\n            } finally{\n                // Clear the timeout if it was set\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n            }\n        });\n    }\n    /**\n     * Creates a new Functions client bound to an Edge Functions URL.\n     *\n     * @example\n     * ```ts\n     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'\n     *\n     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {\n     *   headers: { apikey: 'public-anon-key' },\n     *   region: FunctionRegion.UsEast1,\n     * })\n     * ```\n     */ constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_1__.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_2__.resolveFetch)(customFetch);\n    }\n} //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ007QUFDZ0U7QUFDeEc7O0NBRUMsR0FDTSxNQUFNTTtJQW9CVDs7Ozs7OztLQU9DLEdBQ0RDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxhQUFhLEdBQUcsVUFBZ0IsT0FBTkY7SUFDM0M7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0RHLE9BQU9DLGNBQWMsRUFBRTtRQUNuQixPQUFPWixnREFBU0EsQ0FBQyxJQUFJLEVBQUVhLFdBQVcsS0FBSyxHQUFHLFVBQVdDLFlBQVk7Z0JBQUVDLFVBQUFBLGlFQUFVLENBQUM7WUFDMUUsSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSTtnQkFDQSxNQUFNLEVBQUVULE9BQU8sRUFBRVUsTUFBTSxFQUFFQyxNQUFNQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdSO2dCQUNqRSxJQUFJUyxXQUFXLENBQUM7Z0JBQ2hCLElBQUksRUFBRUMsTUFBTSxFQUFFLEdBQUdWO2dCQUNqQixJQUFJLENBQUNVLFFBQVE7b0JBQ1RBLFNBQVMsSUFBSSxDQUFDQSxNQUFNO2dCQUN4QjtnQkFDQSw4Q0FBOEM7Z0JBQzlDLE1BQU1DLE1BQU0sSUFBSUMsSUFBSSxHQUFlYixPQUFaLElBQUksQ0FBQ1ksR0FBRyxFQUFDLEtBQWdCLE9BQWJaO2dCQUNuQyxJQUFJVyxVQUFVQSxXQUFXLE9BQU87b0JBQzVCRCxRQUFRLENBQUMsV0FBVyxHQUFHQztvQkFDdkJDLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLHVCQUF1Qko7Z0JBQ2hEO2dCQUNBLElBQUlMO2dCQUNKLElBQUlDLGdCQUNDLFlBQVksQ0FBQ1MsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUks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QUM5QixPQUNLLElBQUlMLGlCQUFpQixxQkFBcUI7b0JBQzNDRyxPQUFPWjtnQkFDWCxPQUNLLElBQUlTLGlCQUFpQix1QkFBdUI7b0JBQzdDRyxPQUFPLE1BQU1aLFNBQVNlLFFBQVE7Z0JBQ2xDLE9BQ0s7b0JBQ0Qsa0JBQWtCO29CQUNsQkgsT0FBTyxNQUFNWixTQUFTZ0IsSUFBSTtnQkFDOUI7Z0JBQ0EsT0FBTztvQkFBRUo7b0JBQU1LLE9BQU87b0JBQU1qQjtnQkFBUztZQUN6QyxFQUNBLE9BQU9pQixPQUFPO2dCQUNWLE9BQU87b0JBQ0hMLE1BQU07b0JBQ05LO29CQUNBakIsVUFBVWlCLGlCQUFpQnpELHNEQUFrQkEsSUFBSXlELGlCQUFpQnhELHVEQUFtQkEsR0FDL0V3RCxNQUFNQyxPQUFPLEdBQ2JDO2dCQUNWO1lBQ0osU0FDUTtnQkFDSixrQ0FBa0M7Z0JBQ2xDLElBQUk5QyxXQUFXO29CQUNYK0MsYUFBYS9DO2dCQUNqQjtZQUNKO1FBQ0o7SUFDSjtJQXhLQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRGdELFlBQVl2QyxHQUFHLEVBQUUsRUFBRWpCLFVBQVUsQ0FBQyxDQUFDLEVBQUV5RCxXQUFXLEVBQUV6QyxTQUFTdkIsa0RBQWNBLENBQUNpRSxHQUFHLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUMvRSxJQUFJLENBQUN6QyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDakIsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ2dCLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNvQixLQUFLLEdBQUc1QyxxREFBWUEsQ0FBQ2lFO0lBQzlCO0FBdUpKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcz81YzM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgRnVuY3Rpb25SZWdpb24sIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciwgfSBmcm9tICcuL3R5cGVzJztcbi8qKlxuICogQ2xpZW50IGZvciBpbnZva2luZyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0NsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGdW5jdGlvbnMgY2xpZW50IGJvdW5kIHRvIGFuIEVkZ2UgRnVuY3Rpb25zIFVSTC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBGdW5jdGlvbnNDbGllbnQsIEZ1bmN0aW9uUmVnaW9uIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGZ1bmN0aW9ucyA9IG5ldyBGdW5jdGlvbnNDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9mdW5jdGlvbnMvdjEnLCB7XG4gICAgICogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICAgKiAgIHJlZ2lvbjogRnVuY3Rpb25SZWdpb24uVXNFYXN0MSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIGN1c3RvbUZldGNoLCByZWdpb24gPSBGdW5jdGlvblJlZ2lvbi5BbnksIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGZ1bmN0aW9ucy5zZXRBdXRoKHNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldEF1dGgodG9rZW4pIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGZ1bmN0aW9ucy5pbnZva2UoJ2hlbGxvLXdvcmxkJywge1xuICAgICAqICAgYm9keTogeyBuYW1lOiAnQWRhJyB9LFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgaW52b2tlKGZ1bmN0aW9uTmFtZV8xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgICAgICBsZXQgdGltZW91dENvbnRyb2xsZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kLCBib2R5OiBmdW5jdGlvbkFyZ3MsIHNpZ25hbCwgdGltZW91dCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBsZXQgX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWdpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5yZWdpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWdpb24gYXMgcXVlcnkgcGFyYW1ldGVyIHVzaW5nIFVSTCBBUElcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMudXJsfS8ke2Z1bmN0aW9uTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9uICYmIHJlZ2lvbiAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ3gtcmVnaW9uJ10gPSByZWdpb247XG4gICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmb3JjZUZ1bmN0aW9uUmVnaW9uJywgcmVnaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAgICAgICAgICAgICAoKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykpIHx8ICFoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgd29yayBmb3IgRmlsZSBhcyBGaWxlIGluaGVyaXRzIEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIEFycmF5QnVmZmVyIGFzIGl0IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgc3RydWN0dXJlIGFzIGEgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlIHJpZ2h0IGJvdW5kYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCwgYXNzdW1lIHRoaXMgaXMgSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmdW5jdGlvbkFyZ3MgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGltZW91dCBieSBjcmVhdGluZyBhbiBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICBsZXQgZWZmZWN0aXZlU2lnbmFsID0gc2lnbmFsO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHRpbWVvdXRDb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIHByb3ZpZGVkIHRoZWlyIG93biBzaWduYWwsIHdlIG5lZWQgdG8gcmVzcGVjdCBib3RoXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNpZ25hbCA9IHRpbWVvdXRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyJ3Mgc2lnbmFsIGlzIGFib3J0ZWQsIGFib3J0IG91ciB0aW1lb3V0IGNvbnRyb2xsZXIgdG9vXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aW1lb3V0Q29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNpZ25hbCA9IHRpbWVvdXRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMpLCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBlZmZlY3RpdmVTaWduYWwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZmV0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWxheUVycm9yID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVsYXktZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zSHR0cEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9ICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vcGRmJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCwgcmVzcG9uc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNIdHRwRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNSZWxheUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZW91dCBpZiBpdCB3YXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uc0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwicmVzb2x2ZUZldGNoIiwiRnVuY3Rpb25SZWdpb24iLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uc0NsaWVudCIsInNldEF1dGgiLCJ0b2tlbiIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiaW52b2tlIiwiZnVuY3Rpb25OYW1lXzEiLCJhcmd1bWVudHMiLCJmdW5jdGlvbk5hbWUiLCJvcHRpb25zIiwiX2EiLCJ0aW1lb3V0SWQiLCJ0aW1lb3V0Q29udHJvbGxlciIsIm1ldGhvZCIsImJvZHkiLCJmdW5jdGlvbkFyZ3MiLCJzaWduYWwiLCJ0aW1lb3V0IiwiX2hlYWRlcnMiLCJyZWdpb24iLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJCbG9iIiwiQXJyYXlCdWZmZXIiLCJGb3JtRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlZmZlY3RpdmVTaWduYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVzcG9uc2UiLCJmZXRjaCIsInRvU3RyaW5nIiwiYXNzaWduIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwiaXNSZWxheUVycm9yIiwiZ2V0Iiwib2siLCJyZXNwb25zZVR5cGUiLCJzcGxpdCIsInRyaW0iLCJkYXRhIiwianNvbiIsImJsb2IiLCJmb3JtRGF0YSIsInRleHQiLCJlcnJvciIsImNvbnRleHQiLCJ1bmRlZmluZWQiLCJjbGVhclRpbWVvdXQiLCJjb25zdHJ1Y3RvciIsImN1c3RvbUZldGNoIiwiQW55Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: function() { return /* binding */ resolveFetch; }\n/* harmony export */ });\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return customFetch(...args);\n        };\n    }\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return fetch(...args);\n    };\n}; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsZUFBZSxDQUFDQztJQUN6QixJQUFJQSxhQUFhO1FBQ2IsT0FBTzs2Q0FBSUM7Z0JBQUFBOzttQkFBU0QsZUFBZUM7O0lBQ3ZDO0lBQ0EsT0FBTzt5Q0FBSUE7WUFBQUE7O2VBQVNDLFNBQVNEOztBQUNqQyxFQUFFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcz9iNjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: function() { return /* binding */ FunctionRegion; },\n/* harmony export */   FunctionsError: function() { return /* binding */ FunctionsError; },\n/* harmony export */   FunctionsFetchError: function() { return /* binding */ FunctionsFetchError; },\n/* harmony export */   FunctionsHttpError: function() { return /* binding */ FunctionsHttpError; },\n/* harmony export */   FunctionsRelayError: function() { return /* binding */ FunctionsRelayError; }\n/* harmony export */ });\n/**\n * Base error for Supabase Edge Function invocations.\n *\n * @example\n * ```ts\n * import { FunctionsError } from '@supabase/functions-js'\n *\n * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {\n *   requestId: 'abc123',\n * })\n * ```\n */ class FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\n/**\n * Error thrown when the network request to an Edge Function fails.\n *\n * @example\n * ```ts\n * import { FunctionsFetchError } from '@supabase/functions-js'\n *\n * throw new FunctionsFetchError({ requestId: 'abc123' })\n * ```\n */ class FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\n/**\n * Error thrown when the Supabase relay cannot reach the Edge Function.\n *\n * @example\n * ```ts\n * import { FunctionsRelayError } from '@supabase/functions-js'\n *\n * throw new FunctionsRelayError({ region: 'us-east-1' })\n * ```\n */ class FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\n/**\n * Error thrown when the Edge Function returns a non-2xx status code.\n *\n * @example\n * ```ts\n * import { FunctionsHttpError } from '@supabase/functions-js'\n *\n * throw new FunctionsHttpError({ status: 500 })\n * ```\n */ class FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxNQUFNQSx1QkFBdUJDO0lBQ2hDQyxZQUFZQyxPQUFPLEVBQUVDLE9BQU8sZ0JBQWdCLEVBQUVDLE9BQU8sQ0FBRTtRQUNuRCxLQUFLLENBQUNGO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ25CO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyw0QkFBNEJOO0lBQ3JDRSxZQUFZRyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLGlEQUFpRCx1QkFBdUJBO0lBQ2xGO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNRSw0QkFBNEJQO0lBQ3JDRSxZQUFZRyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLDBDQUEwQyx1QkFBdUJBO0lBQzNFO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNRywyQkFBMkJSO0lBQ3BDRSxZQUFZRyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLGdEQUFnRCxzQkFBc0JBO0lBQ2hGO0FBQ0o7QUFDQSw0Q0FBNEM7QUFDckMsSUFBSUksZUFBZTtBQUN6QixVQUFVQSxjQUFjO0lBQ3JCQSxjQUFjLENBQUMsTUFBTSxHQUFHO0lBQ3hCQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsV0FBVyxHQUFHO0lBQzdCQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsYUFBYSxHQUFHO0lBQy9CQSxjQUFjLENBQUMsYUFBYSxHQUFHO0lBQy9CQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0FBQ2hDLEdBQUdBLGtCQUFtQkEsQ0FBQUEsaUJBQWlCLENBQUMsS0FDeEMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzPzY4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlIGVycm9yIGZvciBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIGludm9jYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNFcnJvcignVW5leHBlY3RlZCBlcnJvciBpbnZva2luZyBmdW5jdGlvbicsICdGdW5jdGlvbnNFcnJvcicsIHtcbiAqICAgcmVxdWVzdElkOiAnYWJjMTIzJyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUgPSAnRnVuY3Rpb25zRXJyb3InLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgcmVxdWVzdCB0byBhbiBFZGdlIEZ1bmN0aW9uIGZhaWxzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zRmV0Y2hFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoeyByZXF1ZXN0SWQ6ICdhYmMxMjMnIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBTdXBhYmFzZSByZWxheSBjYW5ub3QgcmVhY2ggdGhlIEVkZ2UgRnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBGdW5jdGlvbnNSZWxheUVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zUmVsYXlFcnJvcih7IHJlZ2lvbjogJ3VzLWVhc3QtMScgfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zUmVsYXlFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgRWRnZSBGdW5jdGlvbiByZXR1cm5zIGEgbm9uLTJ4eCBzdGF0dXMgY29kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0h0dHBFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcih7IHN0YXR1czogNTAwIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0h0dHBFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdFZGdlIEZ1bmN0aW9uIHJldHVybmVkIGEgbm9uLTJ4eCBzdGF0dXMgY29kZScsICdGdW5jdGlvbnNIdHRwRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG4vLyBEZWZpbmUgdGhlIGVudW0gZm9yIHRoZSAncmVnaW9uJyBwcm9wZXJ0eVxuZXhwb3J0IHZhciBGdW5jdGlvblJlZ2lvbjtcbihmdW5jdGlvbiAoRnVuY3Rpb25SZWdpb24pIHtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFueVwiXSA9IFwiYW55XCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDFcIl0gPSBcImFwLW5vcnRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDJcIl0gPSBcImFwLW5vcnRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoMVwiXSA9IFwiYXAtc291dGgtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QxXCJdID0gXCJhcC1zb3V0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QyXCJdID0gXCJhcC1zb3V0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQ2FDZW50cmFsMVwiXSA9IFwiY2EtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdUNlbnRyYWwxXCJdID0gXCJldS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDFcIl0gPSBcImV1LXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MlwiXSA9IFwiZXUtd2VzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QzXCJdID0gXCJldS13ZXN0LTNcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlNhRWFzdDFcIl0gPSBcInNhLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNFYXN0MVwiXSA9IFwidXMtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QxXCJdID0gXCJ1cy13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDJcIl0gPSBcInVzLXdlc3QtMlwiO1xufSkoRnVuY3Rpb25SZWdpb24gfHwgKEZ1bmN0aW9uUmVnaW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJGdW5jdGlvbnNFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsImNvbnRleHQiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsIkZ1bmN0aW9uUmVnaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: function() { return /* binding */ REALTIME_CHANNEL_STATES; },\n/* harmony export */   REALTIME_LISTEN_TYPES: function() { return /* binding */ REALTIME_LISTEN_TYPES; },\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: function() { return /* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT; },\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: function() { return /* binding */ REALTIME_SUBSCRIBE_STATES; },\n/* harmony export */   \"default\": function() { return /* binding */ RealtimeChannel; }\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\nclass RealtimeChannel {\n    /** Subscribe registers your client with the server */ subscribe(callback) {\n        let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.timeout;\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), {\n                    enabled: presence_enabled\n                }),\n                postgres_changes,\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async (param)=>{\n                let { postgres_changes } = param;\n                var _a;\n                // Only refresh auth if using callback-based tokens\n                if (!this.socket._isManualToken()) {\n                    this.socket.setAuth();\n                }\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    /**\n     * Returns the current presence state for this channel.\n     *\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\n     * tracked metadata for that user.\n     */ presenceState() {\n        return this.presence.state;\n    }\n    /**\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\n     */ async track(payload) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    /**\n     * Removes the current presence state for this client.\n     */ async untrack() {\n        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log(\"channel\", \"resubscribe to \".concat(this.topic, \" due to change in presence callbacks on joined channel\"));\n            this.unsubscribe().then(async ()=>await this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */ async httpSend(event, payload) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var _a;\n        if (payload === undefined || payload === null) {\n            return Promise.reject(\"Payload is required for httpSend()\");\n        }\n        const headers = {\n            apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n            \"Content-Type\": \"application/json\"\n        };\n        if (this.socket.accessTokenValue) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.socket.accessTokenValue);\n        }\n        const options = {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private\n                    }\n                ]\n            })\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return {\n                success: true\n            };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        } catch (_b) {}\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            console.warn(\"Realtime send() is automatically falling back to REST API. \" + \"This behavior will be deprecated in the future. \" + \"Please use httpSend() explicitly for REST delivery.\");\n            const { event, payload: endpoint_payload } = args;\n            const headers = {\n                apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                \"Content-Type\": \"application/json\"\n            };\n            if (this.socket.accessTokenValue) {\n                headers[\"Authorization\"] = \"Bearer \".concat(this.socket.accessTokenValue);\n            }\n            const options = {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    /**\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\n     * Useful for rotating access tokens or updating config without re-creating the channel.\n     */ updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe() {\n        let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.timeout;\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", \"leave \".concat(this.topic));\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve)=>{\n            leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        }).finally(()=>{\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */ teardown() {\n        this.pushBuffer.forEach((push)=>push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.timeout;\n        if (!this.joinedOnce) {\n            throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */ _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > _lib_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log(\"channel\", \"discarded push due to buffer overflow: \".concat(removedPush.event), removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n                    } else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return \"chan_reply_\".concat(ref);\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compares two optional filter values for equality.\n     * Treats undefined, null, and empty string as equivalent empty values.\n     * @internal\n     */ static isFilterValueEqual(serverValue, clientValue) {\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n        return normalizedServer === normalizedClient;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin() {\n        let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.timeout;\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n    /**\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\n     *\n     * The topic determines which realtime stream you are subscribing to. Config options let you\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\n     *\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\n     * ```\n     */ constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\",\n                enabled: false\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", \"close \".concat(this.topic, \" \").concat(this._joinRef()));\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", \"error \".concat(this.topic), reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", \"timeout \".concat(this.topic), this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"error\", (reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", \"error \".concat(this.topic), reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw \"tried to use replay on public channel '\".concat(this.topic, \"'. It must be a private channel.\");\n        }\n    }\n} //# sourceMappingURL=RealtimeChannel.js.map\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDaGFubmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUY7QUFDekQ7QUFDRTtBQUNrQjtBQUNDO0FBQ0U7QUFDOUMsSUFBSVEsdUNBQXVDO0FBQ2pELFVBQVVBLHNDQUFzQztJQUM3Q0Esc0NBQXNDLENBQUMsTUFBTSxHQUFHO0lBQ2hEQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7SUFDbkRBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztJQUNuREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0FBQ3ZELEdBQUdBLDBDQUEyQ0EsQ0FBQUEseUNBQXlDLENBQUM7QUFDakYsSUFBSUMsc0JBQXNCO0FBQ2hDLFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUMsWUFBWSxHQUFHO0lBQ3JDQSxxQkFBcUIsQ0FBQyxXQUFXLEdBQUc7SUFDcENBLHFCQUFxQixDQUFDLG1CQUFtQixHQUFHO0lBQzVDQSxxQkFBcUIsQ0FBQyxTQUFTLEdBQUc7QUFDdEMsR0FBR0EseUJBQTBCQSxDQUFBQSx3QkFBd0IsQ0FBQztBQUMvQyxJQUFJQywwQkFBMEI7QUFDcEMsVUFBVUEseUJBQXlCO0lBQ2hDQSx5QkFBeUIsQ0FBQyxhQUFhLEdBQUc7SUFDMUNBLHlCQUF5QixDQUFDLFlBQVksR0FBRztJQUN6Q0EseUJBQXlCLENBQUMsU0FBUyxHQUFHO0lBQ3RDQSx5QkFBeUIsQ0FBQyxnQkFBZ0IsR0FBRztBQUNqRCxHQUFHQSw2QkFBOEJBLENBQUFBLDRCQUE0QixDQUFDO0FBQ3ZELE1BQU1DLDBCQUEwQlYsMERBQWNBLENBQUM7QUFNdkMsTUFBTVc7SUFtRmpCLG9EQUFvRCxHQUNwREMsVUFBVUMsUUFBUSxFQUEwQjtZQUF4QkMsVUFBQUEsaUVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQ3RDLElBQUlDLElBQUlDLElBQUlDO1FBQ1osSUFBSSxD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LElBQUk7UUFDekMsSUFBSSxDQUFDb0csb0JBQW9CLEdBQUdsRyxrRUFBZUEsQ0FBQyxJQUFJLENBQUNZLE1BQU0sQ0FBQ21NLFFBQVE7UUFDaEUsSUFBSSxDQUFDM0wsT0FBTyxHQUFHLElBQUksQ0FBQ0UsTUFBTSxDQUFDTCxNQUFNLENBQUNHLE9BQU8sSUFBSTtRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDQSxPQUFPLElBQUssRUFBQ1YsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ2EsTUFBTSxDQUFDTCxNQUFNLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUyxTQUFTLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHc00sTUFBTSxHQUFHO1lBQ3RKLE1BQU0sMENBQXFELE9BQVgsSUFBSSxDQUFDOUgsS0FBSyxFQUFDO1FBQy9EO0lBQ0o7QUEwZ0JKLEVBQ0EsMkNBQTJDO0FBbG1CM0M7Ozs7Q0FJQyxHQTZsQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNoYW5uZWwuanM/ZWM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMsIE1BWF9QVVNIX0JVRkZFUl9TSVpFIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlIGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiU1VCU0NSSUJFRFwiXSA9IFwiU1VCU0NSSUJFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJUSU1FRF9PVVRcIl0gPSBcIlRJTUVEX09VVFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDSEFOTkVMX0VSUk9SXCJdID0gXCJDSEFOTkVMX0VSUk9SXCI7XG59KShSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHx8IChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTO1xuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoYW5uZWwgdGhhdCBjYW4gYnJvYWRjYXN0IG1lc3NhZ2VzLCBzeW5jIHByZXNlbmNlLCBhbmQgbGlzdGVuIHRvIFBvc3RncmVzIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdG9waWMgZGV0ZXJtaW5lcyB3aGljaCByZWFsdGltZSBzdHJlYW0geW91IGFyZSBzdWJzY3JpYmluZyB0by4gQ29uZmlnIG9wdGlvbnMgbGV0IHlvdVxuICAgICAqIGVuYWJsZSBhY2tub3dsZWRnZW1lbnQgZm9yIGJyb2FkY2FzdHMsIHByZXNlbmNlIHRyYWNraW5nLCBvciBwcml2YXRlIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZWFsdGltZS92MScsIHtcbiAgICAgKiAgIHBhcmFtczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogfSlcbiAgICAgKiBjb25zdCBjaGFubmVsID0gbmV3IFJlYWx0aW1lQ2hhbm5lbCgncmVhbHRpbWU6cHVibGljOm1lc3NhZ2VzJywgeyBjb25maWc6IHt9IH0sIGNsaWVudClcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICB0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0sIHNvY2tldCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgICAgIHByZXNlbmNlOiB7IGtleTogJycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcml2YXRlOiBmYWxzZSxcbiAgICAgICAgfSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpLCB0aGlzLnNvY2tldC5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuX2pvaW5SZWYoKX1gKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25FcnJvcigocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnZXJyb3InLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCB7fSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcih0aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZSh0aGlzKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCA9IGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCk7XG4gICAgICAgIHRoaXMucHJpdmF0ZSA9IHRoaXMucGFyYW1zLmNvbmZpZy5wcml2YXRlIHx8IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZSAmJiAoKF9iID0gKF9hID0gdGhpcy5wYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnJvYWRjYXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGF5KSkge1xuICAgICAgICAgICAgdGhyb3cgYHRyaWVkIHRvIHVzZSByZXBsYXkgb24gcHVibGljIGNoYW5uZWwgJyR7dGhpcy50b3BpY30nLiBJdCBtdXN0IGJlIGEgcHJpdmF0ZSBjaGFubmVsLmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiB7IGJyb2FkY2FzdCwgcHJlc2VuY2UsIHByaXZhdGU6IGlzUHJpdmF0ZSB9LCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc19jaGFuZ2VzID0gKF9iID0gKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChyKSA9PiByLmZpbHRlcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VfZW5hYmxlZCA9ICghIXRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXS5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgICAgICgoX2MgPSB0aGlzLnBhcmFtcy5jb25maWcucHJlc2VuY2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbmFibGVkKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZW5jZSksIHsgZW5hYmxlZDogcHJlc2VuY2VfZW5hYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHByaXZhdGU6IGlzUHJpdmF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuUGF5bG9hZC5hY2Nlc3NfdG9rZW4gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25FcnJvcigoZSkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgZSkpO1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DTE9TRUQpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoT2JqZWN0LmFzc2lnbih7IGNvbmZpZyB9LCBhY2Nlc3NUb2tlblBheWxvYWQpKTtcbiAgICAgICAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4odGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmpvaW5QdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgYXN5bmMgKHsgcG9zdGdyZXNfY2hhbmdlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVmcmVzaCBhdXRoIGlmIHVzaW5nIGNhbGxiYWNrLWJhc2VkIHRva2Vuc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQuX2lzTWFudWFsVG9rZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3N0Z3Jlc19jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzTGVuID0gKF9hID0gY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gbnVsbCB8fCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zdGdyZXNCaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZyA9IGNsaWVudFBvc3RncmVzQmluZGluZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbHRlcjogeyBldmVudCwgc2NoZW1hLCB0YWJsZSwgZmlsdGVyIH0sIH0gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9IHBvc3RncmVzX2NoYW5nZXMgJiYgcG9zdGdyZXNfY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmV2ZW50ID09PSBldmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hLCBzY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSwgdGFibGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIsIGZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3N0Z3Jlc0JpbmRpbmdzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcpLCB7IGlkOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5pZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgbmV3IEVycm9yKCdtaXNtYXRjaCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IGJpbmRpbmdzIGZvciBwb3N0Z3JlcyBjaGFuZ2VzJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMgPSBuZXdQb3N0Z3Jlc0JpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LnZhbHVlcyhlcnJvcikuam9pbignLCAnKSB8fCAnZXJyb3InKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuVElNRURfT1VUKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwcmVzZW5jZSBzdGF0ZSBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqXG4gICAgICogVGhlIHNoYXBlIGlzIGEgbWFwIGtleWVkIGJ5IHByZXNlbmNlIGtleSAoZm9yIGV4YW1wbGUgYSB1c2VyIGlkKSB3aGVyZSBlYWNoIGVudHJ5IGNvbnRhaW5zIHRoZVxuICAgICAqIHRyYWNrZWQgbWV0YWRhdGEgZm9yIHRoYXQgdXNlci5cbiAgICAgKi9cbiAgICBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHN1cHBsaWVkIHBheWxvYWQgdG8gdGhlIHByZXNlbmNlIHRyYWNrZXIgc28gb3RoZXIgc3Vic2NyaWJlcnMgY2FuIHNlZSB0aGF0IHRoaXNcbiAgICAgKiBjbGllbnQgaXMgb25saW5lLiBVc2UgYHVudHJhY2tgIHRvIHN0b3AgYnJvYWRjYXN0aW5nIHByZXNlbmNlIGZvciB0aGUgc2FtZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgdHJhY2socGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgcHJlc2VuY2Ugc3RhdGUgZm9yIHRoaXMgY2xpZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHVudHJhY2sob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgJiYgdHlwZSA9PT0gUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgcmVzdWJzY3JpYmUgdG8gJHt0aGlzLnRvcGljfSBkdWUgdG8gY2hhbmdlIGluIHByZXNlbmNlIGNhbGxiYWNrcyBvbiBqb2luZWQgY2hhbm5lbGApO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpLnRoZW4oYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGJyb2FkY2FzdCBtZXNzYWdlIGV4cGxpY2l0bHkgdmlhIFJFU1QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWx3YXlzIHVzZXMgdGhlIFJFU1QgQVBJIGVuZHBvaW50IHJlZ2FyZGxlc3Mgb2YgV2ViU29ja2V0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICogVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZ3VhcmFudGVlIFJFU1QgZGVsaXZlcnkgb3Igd2hlbiBncmFkdWFsbHkgbWlncmF0aW5nIGZyb20gaW1wbGljaXQgUkVTVCBmYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgbmFtZSBvZiB0aGUgYnJvYWRjYXN0IGV2ZW50XG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50IChyZXF1aXJlZClcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIGluY2x1ZGluZyB0aW1lb3V0XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMsIGFuZCBlcnJvciBkZXRhaWxzIGlmIGZhaWxlZFxuICAgICAqL1xuICAgIGFzeW5jIGh0dHBTZW5kKGV2ZW50LCBwYXlsb2FkLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnUGF5bG9hZCBpcyByZXF1aXJlZCBmb3IgaHR0cFNlbmQoKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dCh0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLCBvcHRpb25zLCAoX2EgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JCb2R5LmVycm9yIHx8IGVycm9yQm9keS5tZXNzYWdlIHx8IGVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHsgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChhcmdzLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZWFsdGltZSBzZW5kKCkgaXMgYXV0b21hdGljYWxseSBmYWxsaW5nIGJhY2sgdG8gUkVTVCBBUEkuICcgK1xuICAgICAgICAgICAgICAgICdUaGlzIGJlaGF2aW9yIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwU2VuZCgpIGV4cGxpY2l0bHkgZm9yIFJFU1QgZGVsaXZlcnkuJyk7XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuY2VsKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vayA/ICdvaycgOiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWVkIG91dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoID0gdGhpcy5fcHVzaChhcmdzLnR5cGUsIGFyZ3MsIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5icm9hZGNhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGF5bG9hZCB0aGF0IHdpbGwgYmUgc2VudCB0aGUgbmV4dCB0aW1lIHRoZSBjaGFubmVsIGpvaW5zIChyZWNvbm5lY3RzKS5cbiAgICAgKiBVc2VmdWwgZm9yIHJvdGF0aW5nIGFjY2VzcyB0b2tlbnMgb3IgdXBkYXRpbmcgY29uZmlnIHdpdGhvdXQgcmUtY3JlYXRpbmcgdGhlIGNoYW5uZWwuXG4gICAgICovXG4gICAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICAgKlxuICAgICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgbGV0IGxlYXZlUHVzaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGxlYXZlUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmVQdXNoLnNlbmQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGxlYXZlUHVzaCA9PT0gbnVsbCB8fCBsZWF2ZVB1c2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWFyZG93biB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIERlc3Ryb3lzIGFuZCBzdG9wcyByZWxhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2gpID0+IHB1c2guZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9mZXRjaFdpdGhUaW1lb3V0KHVybCwgb3B0aW9ucywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNvY2tldC5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QdXNoQnVmZmVyKHB1c2hFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1c2hFdmVudDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hZGRUb1B1c2hCdWZmZXIocHVzaEV2ZW50KSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgICAgLy8gRW5mb3JjZSBidWZmZXIgc2l6ZSBsaW1pdFxuICAgICAgICBpZiAodGhpcy5wdXNoQnVmZmVyLmxlbmd0aCA+IE1BWF9QVVNIX0JVRkZFUl9TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHVzaCA9IHRoaXMucHVzaEJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRQdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFB1c2guZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBkaXNjYXJkZWQgcHVzaCBkdWUgdG8gYnVmZmVyIG92ZXJmbG93OiAke3JlbW92ZWRQdXNoLmV2ZW50fWAsIHJlbW92ZWRQdXNoLnBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNNZW1iZXIodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2pvaW5SZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyKHR5cGUsIHBheWxvYWQsIHJlZikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHsgY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbiB9ID0gQ0hBTk5FTF9FVkVOVFM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXTtcbiAgICAgICAgaWYgKHJlZiAmJiBldmVudHMuaW5kZXhPZih0eXBlTG93ZXIpID49IDAgJiYgcmVmICE9PSB0aGlzLl9qb2luUmVmKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLl9vbk1lc3NhZ2UodHlwZUxvd2VyLCBwYXlsb2FkLCByZWYpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbJ2luc2VydCcsICd1cGRhdGUnLCAnZGVsZXRlJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50KSA9PT0gJyonIHx8ICgoX2MgPSAoX2IgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBwYXlsb2FkLmlkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKGJpbmRJZCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09IG51bGwgfHwgYmluZEV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kRXZlbnQudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09ICgoX2MgPSBwYXlsb2FkLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSAoX2UgPSAoX2QgPSBiaW5kID09PSBudWxsIHx8IGJpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXZlbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRFdmVudCA9PT0gJyonIHx8IGJpbmRFdmVudCA9PT0gKChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5ldmVudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5tYXAoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZWRQYXlsb2FkID09PSAnb2JqZWN0JyAmJiAnaWRzJyBpbiBoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc0NoYW5nZXMgPSBoYW5kbGVkUGF5bG9hZC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgdGFibGUsIGNvbW1pdF90aW1lc3RhbXAsIHR5cGUsIGVycm9ycyB9ID0gcG9zdGdyZXNDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnJpY2hlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdF90aW1lc3RhbXA6IGNvbW1pdF90aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXc6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW5yaWNoZWRQYXlsb2FkKSwgdGhpcy5fZ2V0UGF5bG9hZFJlY29yZHMocG9zdGdyZXNDaGFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzSm9pbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzSm9pbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNMZWF2aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZXBseUV2ZW50TmFtZShyZWYpIHtcbiAgICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLnB1c2goYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSBbYmluZGluZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb2ZmKHR5cGUsIGZpbHRlcikge1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoKChfYSA9IGJpbmQudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRXF1YWwoYmluZC5maWx0ZXIsIGZpbHRlcikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgayBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAob2JqMVtrXSAhPT0gb2JqMltrXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIG9wdGlvbmFsIGZpbHRlciB2YWx1ZXMgZm9yIGVxdWFsaXR5LlxuICAgICAqIFRyZWF0cyB1bmRlZmluZWQsIG51bGwsIGFuZCBlbXB0eSBzdHJpbmcgYXMgZXF1aXZhbGVudCBlbXB0eSB2YWx1ZXMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNlcnZlciA9IHNlcnZlclZhbHVlICE9PSBudWxsICYmIHNlcnZlclZhbHVlICE9PSB2b2lkIDAgPyBzZXJ2ZXJWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENsaWVudCA9IGNsaWVudFZhbHVlICE9PSBudWxsICYmIGNsaWVudFZhbHVlICE9PSB2b2lkIDAgPyBjbGllbnRWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRTZXJ2ZXIgPT09IG5vcm1hbGl6ZWRDbGllbnQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luVW50aWxDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBjbG9zZXMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwge30sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgZW5jb3VudGVyZXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBhbmQgdGhlIGNoYW5uZWwgaGFzIGJlZW4gam9pbmVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NhblB1c2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuX2lzSm9pbmVkKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZWNvcmRzID0ge1xuICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdJTlNFUlQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMubmV3ID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5yZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnIHx8IHBheWxvYWQudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMub2xkID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5vbGRfcmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIkNIQU5ORUxfRVZFTlRTIiwiQ0hBTk5FTF9TVEFURVMiLCJNQVhfUFVTSF9CVUZGRVJfU0laRSIsIlB1c2giLCJUaW1lciIsIlJlYWx0aW1lUHJlc2VuY2UiLCJUcmFuc2Zvcm1lcnMiLCJodHRwRW5kcG9pbnRVUkwiLCJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCJSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyIsIlJlYWx0aW1lQ2hhbm5lbCIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwidGltZW91dCIsIl9hIiwiX2IiLCJfYyIsInNvY2tldCIsImlzQ29ubmVjdGVkIiwiY29ubmVjdCIsInN0YXRlIiwiY2xvc2VkIiwiY29uZmlnIiwiYnJvYWRjYXN0IiwicHJlc2VuY2UiLCJwcml2YXRlIiwiaXNQcml2YXRlIiwicGFyYW1zIiwicG9zdGdyZXNfY2hhbmdlcyIsImJpbmRpbmdzIiwibWFwIiwiciIsImZpbHRlciIsInByZXNlbmNlX2VuYWJsZWQiLCJQUkVTRU5DRSIsImxlbmd0aCIsImVuYWJsZWQiLCJhY2Nlc3NUb2tlblBheWxvYWQiLCJPYmplY3QiLCJhc3NpZ24iLCJhY2Nlc3NUb2tlblZhbHVlIiwiYWNjZXNzX3Rva2VuIiwiX29uRXJyb3IiLCJlIiwiQ0hBTk5FTF9FUlJPUiIsIl9vbkNsb3NlIiwiQ0xPU0VEIiwidXBkYXRlSm9pblBheWxvYWQiLCJqb2luZWRPbmNlIiwiX3Jlam9pbiIsImpvaW5QdXNoIiwicmVjZWl2ZSIsIl9pc01hbnVhbFRva2VuIiwic2V0QXV0aCIsInVuZGVmaW5lZCIsIlNVQlNDUklCRUQiLCJjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzIiwiYmluZGluZ3NMZW4iLCJuZXdQb3N0Z3Jlc0JpbmRpbmdzIiwiaSIsImNsaWVudFBvc3RncmVzQmluZGluZyIsImV2ZW50Iiwic2NoZW1hIiwidGFibGUiLCJzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciIsImlzRmlsdGVyVmFsdWVFcXVhbCIsInB1c2giLCJpZCIsInVuc3Vic2NyaWJlIiwiZXJyb3JlZCIsIkVycm9yIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidmFsdWVzIiwiam9pbiIsIlRJTUVEX09VVCIsInByZXNlbmNlU3RhdGUiLCJ0cmFjayIsInBheWxvYWQiLCJvcHRzIiwic2VuZCIsInR5cGUiLCJ1bnRyYWNrIiwib24iLCJqb2luZWQiLCJsb2ciLCJ0b3BpYyIsInRoZW4iLCJfb24iLCJodHRwU2VuZCIsIlByb21pc2UiLCJyZWplY3QiLCJoZWFkZXJzIiwiYXBpa2V5IiwiYXBpS2V5Iiwib3B0aW9ucyIsIm1ldGhvZCIsImJvZHkiLCJtZXNzYWdlcyIsInN1YlRvcGljIiwicmVzcG9uc2UiLCJfZmV0Y2hXaXRoVGltZW91dCIsImJyb2FkY2FzdEVuZHBvaW50VVJMIiwic3RhdHVzIiwic3VjY2VzcyIsImVycm9yTWVzc2FnZSIsInN0YXR1c1RleHQiLCJlcnJvckJvZHkiLCJqc29uIiwibWVzc2FnZSIsImFyZ3MiLCJfY2FuUHVzaCIsImNvbnNvbGUiLCJ3YXJuIiwiZW5kcG9pbnRfcGF5bG9hZCIsImNhbmNlbCIsIm9rIiwibmFtZSIsInJlc29sdmUiLCJfcHVzaCIsImFjayIsInVwZGF0ZVBheWxvYWQiLCJsZWF2aW5nIiwib25DbG9zZSIsIl90cmlnZ2VyIiwiY2xvc2UiLCJfam9pblJlZiIsImRlc3Ryb3kiLCJsZWF2ZVB1c2giLCJsZWF2ZSIsInRyaWdnZXIiLCJmaW5hbGx5IiwidGVhcmRvd24iLCJwdXNoQnVmZmVyIiwiZm9yRWFjaCIsInJlam9pblRpbWVyIiwicmVzZXQiLCJ1cmwiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiZmV0Y2giLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJwdXNoRXZlbnQiLCJfYWRkVG9QdXNoQnVmZmVyIiwic3RhcnRUaW1lb3V0IiwicmVtb3ZlZFB1c2giLCJzaGlmdCIsIl9vbk1lc3NhZ2UiLCJfZXZlbnQiLCJfcmVmIiwiX2lzTWVtYmVyIiwicmVmIiwidHlwZUxvd2VyIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJldmVudHMiLCJpbmRleE9mIiwiaGFuZGxlZFBheWxvYWQiLCJpbmNsdWRlcyIsImJpbmQiLCJfZCIsIl9lIiwiX2YiLCJiaW5kSWQiLCJiaW5kRXZlbnQiLCJpZHMiLCJkYXRhIiwicG9zdGdyZXNDaGFuZ2VzIiwiY29tbWl0X3RpbWVzdGFtcCIsImVycm9ycyIsImVucmljaGVkUGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm9sZCIsIl9nZXRQYXlsb2FkUmVjb3JkcyIsIl9pc0Nsb3NlZCIsIl9pc0pvaW5lZCIsIl9pc0pvaW5pbmciLCJqb2luaW5nIiwiX2lzTGVhdmluZyIsIl9yZXBseUV2ZW50TmFtZSIsImJpbmRpbmciLCJfb2ZmIiwiaXNFcXVhbCIsIm9iajEiLCJvYmoyIiwia2V5cyIsImsiLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZFNlcnZlciIsIm5vcm1hbGl6ZWRDbGllbnQiLCJfcmVqb2luVW50aWxDb25uZWN0ZWQiLCJzY2hlZHVsZVRpbWVvdXQiLCJyZWFzb24iLCJfbGVhdmVPcGVuVG9waWMiLCJyZXNlbmQiLCJyZWNvcmRzIiwiY29udmVydENoYW5nZURhdGEiLCJjb2x1bW5zIiwicmVjb3JkIiwib2xkX3JlY29yZCIsImNvbnN0cnVjdG9yIiwicmVwbGFjZSIsInNlbGYiLCJrZXkiLCJyZWNvbm5lY3RBZnRlck1zIiwiX3JlbW92ZSIsInJlcGx5IiwiZW5kUG9pbnQiLCJyZXBsYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RealtimeClient; }\n/* harmony export */ });\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/serializer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\n\nconst noop = ()=>{};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [\n    1000,\n    2000,\n    5000,\n    10000\n];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = '\\n  addEventListener(\"message\", (e) => {\\n    if (e.data.event === \"start\") {\\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\\n    }\\n  });';\nclass RealtimeClient {\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n            return;\n        }\n        this._setConnectionState(\"connecting\");\n        // Trigger auth if needed and not already in progress\n        // This ensures auth is called for standalone RealtimeClient usage\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\n        if (this.accessToken && !this._authPromise) {\n            this._setAuthSafely(\"connect\");\n        }\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        } else {\n            // Try to use native WebSocket\n            try {\n                this.conn = _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createWebSocket(this.endpointURL());\n            } catch (error) {\n                this._setConnectionState(\"disconnected\");\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes(\"Node.js\")) {\n                    throw new Error(\"\".concat(errorMessage, \"\\n\\n\") + \"To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n\" + \"Option 1: Use Node.js 22+ which has native WebSocket support\\n\" + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + \"  npm install ws\\n\\n\" + '  import ws from \"ws\"\\n' + \"  const client = new RealtimeClient(url, {\\n\" + \"    ...options,\\n\" + \"    transport: ws\\n\" + \"  })\");\n                }\n                throw new Error(\"WebSocket not available: \".concat(errorMessage));\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: this.vsn\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState(\"disconnecting\", true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(()=>{\n                this._setConnectionState(\"disconnected\");\n            }, 100);\n            this.conn.onclose = ()=>{\n                clearTimeout(fallbackTimer);\n                this._setConnectionState(\"disconnected\");\n            };\n            // Close the WebSocket connection if close method exists\n            if (typeof this.conn.close === \"function\") {\n                if (code) {\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n                } else {\n                    this.conn.close();\n                }\n            }\n            this._teardownConnection();\n        } else {\n            this._setConnectionState(\"disconnected\");\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        // Only remove from channels list if unsubscribe was successful\n        if (status === \"ok\") {\n            this._remove(channel);\n        }\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */ isConnecting() {\n        return this._connectionState === \"connecting\";\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */ isDisconnecting() {\n        return this._connectionState === \"disconnecting\";\n    }\n    /**\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\n     *\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\n     * If a channel with the same topic already exists it will be returned instead of creating\n     * a duplicate connection.\n     */ channel(topic) {\n        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            config: {}\n        };\n        const realtimeTopic = \"realtime:\".concat(topic);\n        const exists = this.getChannels().find((c)=>c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\"realtime:\".concat(topic), params, this);\n            this.channels.push(chan);\n            return chan;\n        } else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * When a token is explicitly provided, it will be preserved across channel operations\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\n     * invoked until `setAuth()` is called without arguments.\n     *\n     * @param token A JWT string to override the token set on the client.\n     *\n     * @example\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\n     * client.realtime.setAuth('my-custom-jwt')\n     *\n     * // Switch back to using the accessToken callback\n     * client.realtime.setAuth()\n     */ async setAuth() {\n        let token = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        } finally{\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Returns true if the current access token was explicitly set via setAuth(token),\n     * false if it was obtained via the accessToken callback.\n     * @internal\n     */ _isManualToken() {\n        return this._manuallySetToken;\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback(\"disconnected\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this._heartbeatSentAt = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            try {\n                this.heartbeatCallback(\"timeout\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CLOSE_NORMAL, \"heartbeat timeout\");\n            setTimeout(()=>{\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this._heartbeatSentAt = Date.now();\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        try {\n            this.heartbeatCallback(\"sent\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n        this._setAuthSafely(\"heartbeat\");\n    }\n    /**\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\n     */ onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", 'leaving duplicate topic \"'.concat(topic, '\"'));\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c.topic !== channel.topic);\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            // Handle heartbeat responses\n            if (msg.topic === \"phoenix\" && msg.event === \"phx_reply\" && msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n                try {\n                    this.heartbeatCallback(msg.payload.status === \"ok\" ? \"ok\" : \"error\", latency);\n                } catch (e) {\n                    this.log(\"error\", \"error in heartbeat callback\", e);\n                }\n                this._heartbeatSentAt = null;\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? \"(\".concat(ref, \")\") : \"\";\n            const status = payload.status || \"\";\n            this.log(\"receive\", \"\".concat(status, \" \").concat(topic, \" \").concat(event, \" \").concat(refString).trim(), payload);\n            // Route message to appropriate channels\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks(\"message\", msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */ _clearTimer(timer) {\n        var _a;\n        if (timer === \"heartbeat\" && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        } else if (timer === \"reconnect\") {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */ _clearAllTimers() {\n        this._clearTimer(\"heartbeat\");\n        this._clearTimer(\"reconnect\");\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */ _setupConnectionHandlers() {\n        if (!this.conn) return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if (\"binaryType\" in this.conn) {\n            ;\n            this.conn.binaryType = \"arraybuffer\";\n        }\n        this.conn.onopen = ()=>this._onConnOpen();\n        this.conn.onerror = (error)=>this._onConnError(error);\n        this.conn.onmessage = (event)=>this._onConnMessage(event);\n        this.conn.onclose = (event)=>this._onConnClose(event);\n        if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open) {\n            this._onConnOpen();\n        }\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */ _teardownConnection() {\n        if (this.conn) {\n            if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open || this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting) {\n                try {\n                    this.conn.close();\n                } catch (e) {\n                    this.log(\"error\", \"Error closing connection\", e);\n                }\n            }\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this._terminateWorker();\n        this.channels.forEach((channel)=>channel.teardown());\n    }\n    /** @internal */ _onConnOpen() {\n        this._setConnectionState(\"connected\");\n        this.log(\"transport\", \"connected to \".concat(this.endpointURL()));\n        // Wait for any pending auth operations before flushing send buffer\n        // This ensures channel join messages include the correct access token\n        const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n        authPromise.then(()=>{\n            this.flushSendBuffer();\n        }).catch((e)=>{\n            this.log(\"error\", \"error waiting for auth on connect\", e);\n            // Proceed anyway to avoid hanging connections\n            this.flushSendBuffer();\n        });\n        this._clearTimer(\"reconnect\");\n        if (!this.worker) {\n            this._startHeartbeat();\n        } else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks(\"open\");\n    }\n    /** @internal */ _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */ _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log(\"worker\", \"starting worker for from \".concat(this.workerUrl));\n        } else {\n            this.log(\"worker\", \"starting default worker\");\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error)=>{\n            this.log(\"worker\", \"worker error\", error.message);\n            this._terminateWorker();\n        };\n        this.workerRef.onmessage = (event)=>{\n            if (event.data.event === \"keepAlive\") {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: \"start\",\n            interval: this.heartbeatIntervalMs\n        });\n    }\n    /**\n     * Terminate the Web Worker and clear the reference\n     * @internal\n     */ _terminateWorker() {\n        if (this.workerRef) {\n            this.log(\"worker\", \"terminating worker\");\n            this.workerRef.terminate();\n            this.workerRef = undefined;\n        }\n    }\n    /** @internal */ _onConnClose(event) {\n        var _a;\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this._clearTimer(\"heartbeat\");\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks(\"close\", event);\n    }\n    /** @internal */ _onConnError(error) {\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"\".concat(error));\n        this._triggerChanError();\n        this._triggerStateCallbacks(\"error\", error);\n        try {\n            this.heartbeatCallback(\"error\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return \"\".concat(url).concat(prefix).concat(query);\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */ _setConnectionState(state) {\n        let manual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        this._connectionState = state;\n        if (state === \"connecting\") {\n            this._wasManualDisconnect = false;\n        } else if (state === \"disconnecting\") {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */ async _performAuth() {\n        let token = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        let tokenToSend;\n        let isManualToken = false;\n        if (token) {\n            tokenToSend = token;\n            // Track if this is a manually-provided token\n            isManualToken = true;\n        } else if (this.accessToken) {\n            // Call the accessToken callback to get fresh token\n            try {\n                tokenToSend = await this.accessToken();\n            } catch (e) {\n                this.log(\"error\", \"Error fetching access token from callback\", e);\n                // Fall back to cached value if callback fails\n                tokenToSend = this.accessTokenValue;\n            }\n        } else {\n            tokenToSend = this.accessTokenValue;\n        }\n        // Track whether this token was manually set or fetched via callback\n        if (isManualToken) {\n            this._manuallySetToken = true;\n        } else if (this.accessToken) {\n            // If we used the callback, clear the manual flag\n            this._manuallySetToken = false;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                const payload = {\n                    access_token: tokenToSend,\n                    version: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VERSION\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */ async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */ _setAuthSafely() {\n        let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"general\";\n        // Only refresh auth if using callback-based tokens\n        if (!this._isManualToken()) {\n            this.setAuth().catch((e)=>{\n                this.log(\"error\", \"Error setting auth in \".concat(context), e);\n            });\n        }\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */ _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (e) {\n                    this.log(\"error\", \"error in \".concat(event, \" callback\"), e);\n                }\n            });\n        } catch (e) {\n            this.log(\"error\", \"error triggering \".concat(event, \" callbacks\"), e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */ _setupReconnectionTimer() {\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](async ()=>{\n            setTimeout(async ()=>{\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */ _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), {\n                log_level: this.logLevel\n            });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : (tries)=>{\n            return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n        };\n        switch(this.vsn){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_1_0_0:\n                this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback)=>{\n                    return callback(JSON.stringify(payload));\n                };\n                this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback)=>{\n                    return callback(JSON.parse(payload));\n                };\n                break;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_2_0_0:\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n                break;\n            default:\n                throw new Error(\"Unsupported serializer version: \".concat(this.vsn));\n        }\n        // Handle worker setup\n        if (this.worker) {\n            if ( true && !window.Worker) {\n                throw new Error(\"Web Worker is not supported\");\n            }\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * client.connect()\n     * ```\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this._manuallySetToken = false;\n        this.channels = new Array();\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.vsn = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        this._connectionState = \"disconnected\";\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        this._heartbeatSentAt = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            if (customFetch) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    return customFetch(...args);\n                };\n            }\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return fetch(...args);\n            };\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error(\"API key is required to connect to Realtime\");\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = \"\".concat(endPoint, \"/\").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.TRANSPORTS.websocket);\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n} //# sourceMappingURL=RealtimeClient.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1RDtBQUM4SDtBQUMzSTtBQUNWO0FBQ3FCO0FBQ0w7QUFDaEQsTUFBTWUsT0FBTyxLQUFRO0FBQ3JCLCtCQUErQjtBQUMvQixNQUFNQyxzQkFBc0I7SUFDeEJDLG9CQUFvQjtJQUNwQkMsaUJBQWlCO0lBQ2pCQyw0QkFBNEI7QUFDaEM7QUFDQSxNQUFNQyxzQkFBc0I7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFNO0FBQ3JELE1BQU1DLDZCQUE2QjtBQUNuQyxNQUFNQyxnQkFBaUI7QUFNUixNQUFNQztJQXdGakI7O0tBRUMsR0FDREMsVUFBVTtRQUNOLDBEQUEwRDtRQUMxRCxJQUFJLElBQUksQ0FBQ0MsWUFBWSxNQUNqQixJQUFJLENBQUNDLGVBQWUsTUFDbkIsSUFBSSxDQUFDQyxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUNDLFdBQVcsSUFBSztZQUM1QztRQUNKO1FBQ0EsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQztRQUN6QixxREFBcUQ7UUFDckQsa0VBQWtFO1FBQ2xFLDhFQUE4RTtRQUM5RSxJQUFJLElBQUksQ0FBQ0MsV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDQyxZQUFZLEVBQUU7WUFDeEMsSUFBSSxDQUFDQyxjQUFjLENBQUM7UUFDeEI7UUFDQSxpQ0FBaUM7UUFDakMsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNoQixtQ0FBbUM7WUFDbkMsSUFBSSxDQUFDTixJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUNNLFNBQVMsQ0FBQyxJQUFJLENBQUNDLFdBQVc7UUFDbkQsT0FDSztZQUNELDhCQUE4QjtZQUM5QixJQUFJO2dCQUNBLElBQUksQ0FBQ1AsSUFBSSxHQUFHM0IsOERBQWdCQSxDQUFDbUMsZUFBZSxDQUFDLElBQUksQ0FBQ0QsV0FBVztZQUNq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WUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFROEIsS0FBSztJQUNuRztBQTR0QkosRUFDQSwwQ0FBMEM7QUFEekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNsaWVudC5qcz82YjZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJTb2NrZXRGYWN0b3J5IGZyb20gJy4vbGliL3dlYnNvY2tldC1mYWN0b3J5JztcbmltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDT05ORUNUSU9OX1NUQVRFLCBERUZBVUxUX1ZFUlNJT04sIERFRkFVTFRfVElNRU9VVCwgU09DS0VUX1NUQVRFUywgVFJBTlNQT1JUUywgREVGQVVMVF9WU04sIFZTTl8xXzBfMCwgVlNOXzJfMF8wLCBXU19DTE9TRV9OT1JNQUwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vLyBDb25uZWN0aW9uLXJlbGF0ZWQgY29uc3RhbnRzXG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVRTID0ge1xuICAgIEhFQVJUQkVBVF9JTlRFUlZBTDogMjUwMDAsXG4gICAgUkVDT05ORUNUX0RFTEFZOiAxMCxcbiAgICBIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSzogMTAwLFxufTtcbmNvbnN0IFJFQ09OTkVDVF9JTlRFUlZBTFMgPSBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdO1xuY29uc3QgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0sgPSAxMDAwMDtcbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZFBvaW50IFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiLCBcIndzczovL2V4YW1wbGUuY29tXCIsIFwiL3NvY2tldFwiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LiBUaGlzIGNhbiBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQgVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgRGVwcmVjYXRlZDogaGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIHdlYnNvY2tldCBjb25uZWN0aW9ucyBhbmQgdGhpcyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcyBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBoYW5kbGUgaGVhcnRiZWF0IHN0YXR1cyBhbmQgbGF0ZW5jeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nTGV2ZWwgU2V0cyB0aGUgbG9nIGxldmVsIGZvciBSZWFsdGltZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZzbiBUaGUgcHJvdG9jb2wgdmVyc2lvbiB0byB1c2Ugd2hlbiBjb25uZWN0aW5nLiBTdXBwb3J0ZWQgdmVyc2lvbnMgYXJlIFwiMS4wLjBcIiBhbmQgXCIyLjAuMFwiLiBEZWZhdWx0cyB0byBcIjIuMC4wXCIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZWFsdGltZS92MScsIHtcbiAgICAgKiAgIHBhcmFtczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogfSlcbiAgICAgKiBjbGllbnQuY29ubmVjdCgpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hbnVhbGx5U2V0VG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gJyc7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gJyc7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBoZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gd2Vic29ja2V0IGNvbm5lY3Rpb25zICovXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfSU5URVJWQUw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSBub29wO1xuICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnZzbiA9IERFRkFVTFRfVlNOO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG5vb3A7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcigpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb3BlbjogW10sXG4gICAgICAgICAgICBjbG9zZTogW10sXG4gICAgICAgICAgICBlcnJvcjogW10sXG4gICAgICAgICAgICBtZXNzYWdlOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBlaXRoZXIgY3VzdG9tIGZldGNoLCBpZiBwcm92aWRlZCwgb3IgZGVmYXVsdCBmZXRjaCB0byBtYWtlIEhUVFAgcmVxdWVzdHNcbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgICAgIGlmICghKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcGlrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBrZXkgaXMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byBSZWFsdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucy5wYXJhbXMuYXBpa2V5O1xuICAgICAgICAvLyBJbml0aWFsaXplIGVuZHBvaW50IFVSTHNcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWA7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gaHR0cEVuZHBvaW50VVJMKGVuZFBvaW50KTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwUmVjb25uZWN0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGNvbm5lY3RpbmcsIGRpc2Nvbm5lY3RpbmcsIG9yIGNvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29ubiAhPT0gbnVsbCAmJiB0aGlzLmlzQ29ubmVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIC8vIFRyaWdnZXIgYXV0aCBpZiBuZWVkZWQgYW5kIG5vdCBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBhdXRoIGlzIGNhbGxlZCBmb3Igc3RhbmRhbG9uZSBSZWFsdGltZUNsaWVudCB1c2FnZVxuICAgICAgICAvLyB3aGlsZSBhdm9pZGluZyByYWNlIGNvbmRpdGlvbnMgd2l0aCBTdXBhYmFzZUNsaWVudCdzIGltbWVkaWF0ZSBzZXRBdXRoIGNhbGxcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSB0cmFuc3BvcnQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubiA9IFdlYlNvY2tldEZhY3RvcnkuY3JlYXRlV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdOb2RlLmpzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX1cXG5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdUbyB1c2UgUmVhbHRpbWUgaW4gTm9kZS5qcywgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbjpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMTogVXNlIE5vZGUuanMgMjIrIHdoaWNoIGhhcyBuYXRpdmUgV2ViU29ja2V0IHN1cHBvcnRcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMjogSW5zdGFsbCBhbmQgcHJvdmlkZSB0aGUgXCJ3c1wiIHBhY2thZ2U6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBucG0gaW5zdGFsbCB3c1xcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgaW1wb3J0IHdzIGZyb20gXCJ3c1wiXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIC4uLm9wdGlvbnMsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIHRyYW5zcG9ydDogd3NcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIH0pJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViU29ja2V0IG5vdCBhdmFpbGFibGU6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgICAqIEByZXR1cm5zIHN0cmluZyBUaGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICovXG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiB0aGlzLnZzbiB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZSBBIG51bWVyaWMgc3RhdHVzIGNvZGUgdG8gc2VuZCBvbiBkaXNjb25uZWN0LlxuICAgICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2Nvbm5lY3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGluZycsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgICAvLyBTZXR1cCBmYWxsYmFjayB0aW1lciB0byBwcmV2ZW50IGhhbmdpbmcgaW4gZGlzY29ubmVjdGluZyBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGZhbGxiYWNrVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlmIGNsb3NlIG1ldGhvZCBleGlzdHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25uLmNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiAhPT0gbnVsbCAmJiByZWFzb24gIT09IHZvaWQgMCA/IHJlYXNvbiA6ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RlYXJkb3duQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjcmVhdGVkIGNoYW5uZWxzXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYSBzaW5nbGUgY2hhbm5lbFxuICAgICAqIEBwYXJhbSBjaGFubmVsIEEgUmVhbHRpbWVDaGFubmVsIGluc3RhbmNlXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gT25seSByZW1vdmUgZnJvbSBjaGFubmVscyBsaXN0IGlmIHVuc3Vic2NyaWJlIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZShjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC51bnN1YnNjcmliZSgpKSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNfMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEZvciBjdXN0b21pemVkIGxvZ2dpbmcsIGB0aGlzLmxvZ2dlcmAgY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgbG9nKGtpbmQsIG1zZywgZGF0YSkge1xuICAgICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICovXG4gICAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZztcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLk9wZW47XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGNvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNDb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBkaXNjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIGlzRGlzY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIChvciByZXVzZXMpIGEge0BsaW5rIFJlYWx0aW1lQ2hhbm5lbH0gZm9yIHRoZSBwcm92aWRlZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIFRvcGljcyBhcmUgYXV0b21hdGljYWxseSBwcmVmaXhlZCB3aXRoIGByZWFsdGltZTpgIHRvIG1hdGNoIHRoZSBSZWFsdGltZSBzZXJ2aWNlLlxuICAgICAqIElmIGEgY2hhbm5lbCB3aXRoIHRoZSBzYW1lIHRvcGljIGFscmVhZHkgZXhpc3RzIGl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAgICAqIGEgZHVwbGljYXRlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgY2hhbm5lbCh0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0pIHtcbiAgICAgICAgY29uc3QgcmVhbHRpbWVUb3BpYyA9IGByZWFsdGltZToke3RvcGljfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHRoaXMuZ2V0Q2hhbm5lbHMoKS5maW5kKChjKSA9PiBjLnRvcGljID09PSByZWFsdGltZVRvcGljKTtcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICAgICAgICByZXR1cm4gY2hhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaCBvdXQgYSBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCB0aGUgbWVzc2FnZSBnZXRzIGVucXVldWVkIHdpdGhpbiBhIGxvY2FsIGJ1ZmZlciwgYW5kIHNlbnQgb3V0IHdoZW4gYSBjb25uZWN0aW9uIGlzIG5leHQgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNvbm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coJ3B1c2gnLCBgJHt0b3BpY30gJHtldmVudH0gKCR7cmVmfSlgLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBKV1QgYWNjZXNzIHRva2VuIHVzZWQgZm9yIGNoYW5uZWwgc3Vic2NyaXB0aW9uIGF1dGhvcml6YXRpb24gYW5kIFJlYWx0aW1lIFJMUy5cbiAgICAgKlxuICAgICAqIElmIHBhcmFtIGlzIG51bGwgaXQgd2lsbCB1c2UgdGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgZnVuY3Rpb24gb3IgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogT24gY2FsbGJhY2sgdXNlZCwgaXQgd2lsbCBzZXQgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbnRlcm5hbCB0byB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogV2hlbiBhIHRva2VuIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcHJlc2VydmVkIGFjcm9zcyBjaGFubmVsIG9wZXJhdGlvbnNcbiAgICAgKiAoaW5jbHVkaW5nIHJlbW92ZUNoYW5uZWwgYW5kIHJlc3Vic2NyaWJlKS4gVGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgd2lsbCBub3QgYmVcbiAgICAgKiBpbnZva2VkIHVudGlsIGBzZXRBdXRoKClgIGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVc2UgYSBtYW51YWwgdG9rZW4gKHByZXNlcnZlZCBhY3Jvc3MgcmVzdWJzY3JpYmVzLCBpZ25vcmVzIGFjY2Vzc1Rva2VuIGNhbGxiYWNrKVxuICAgICAqIGNsaWVudC5yZWFsdGltZS5zZXRBdXRoKCdteS1jdXN0b20tand0JylcbiAgICAgKlxuICAgICAqIC8vIFN3aXRjaCBiYWNrIHRvIHVzaW5nIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFja1xuICAgICAqIGNsaWVudC5yZWFsdGltZS5zZXRBdXRoKClcbiAgICAgKi9cbiAgICBhc3luYyBzZXRBdXRoKHRva2VuID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IHRoaXMuX3BlcmZvcm1BdXRoKHRva2VuKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1dGhQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4gd2FzIGV4cGxpY2l0bHkgc2V0IHZpYSBzZXRBdXRoKHRva2VuKSxcbiAgICAgKiBmYWxzZSBpZiBpdCB3YXMgb2J0YWluZWQgdmlhIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjay5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaXNNYW51YWxUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbGx5U2V0VG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgaGVhcnRiZWF0IG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBoZWFydGJlYXQgdGltZW91dCBhbmQgZm9yY2UgcmVjb25uZWN0aW9uIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjaygndGltZW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3JjZSByZWNvbm5lY3Rpb24gYWZ0ZXIgaGVhcnRiZWF0IHRpbWVvdXRcbiAgICAgICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJ0YmVhdCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWNvbm5lY3RUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVFMuSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgaGVhcnRiZWF0IG1lc3NhZ2UgdG8gc2VydmVyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiAncGhvZW5peCcsXG4gICAgICAgICAgICBldmVudDogJ2hlYXJ0YmVhdCcsXG4gICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ3NlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEF1dGhTYWZlbHkoJ2hlYXJ0YmVhdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyBsaWZlY3ljbGUgZXZlbnRzIGZvciBpbnRlcm5hbCBoZWFydGJlYXQgbWVzc2FnZXMuXG4gICAgICogVXNlZnVsIGZvciBpbnN0cnVtZW50aW5nIGNvbm5lY3Rpb24gaGVhbHRoIChlLmcuIHNlbnQvb2svdGltZW91dC9kaXNjb25uZWN0ZWQpLlxuICAgICAqL1xuICAgIG9uSGVhcnRiZWF0KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBzZW5kIGJ1ZmZlclxuICAgICAqL1xuICAgIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbWFrZVJlZigpIHtcbiAgICAgICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMTtcbiAgICAgICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gbmV3UmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGNoYW5uZWxzIHdpdGggdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9sZWF2ZU9wZW5Ub3BpYyh0b3BpYykge1xuICAgICAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZCgoYykgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuX2lzSm9pbmVkKCkgfHwgYy5faXNKb2luaW5nKCkpKTtcbiAgICAgICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYCk7XG4gICAgICAgICAgICBkdXBDaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBBbiBvcGVuIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9yZW1vdmUoY2hhbm5lbCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoKGMpID0+IGMudG9waWMgIT09IGNoYW5uZWwudG9waWMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIChtc2cpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBoZWFydGJlYXQgcmVzcG9uc2VzXG4gICAgICAgICAgICBpZiAobXNnLnRvcGljID09PSAncGhvZW5peCcgJiZcbiAgICAgICAgICAgICAgICBtc2cuZXZlbnQgPT09ICdwaHhfcmVwbHknICYmXG4gICAgICAgICAgICAgICAgbXNnLnJlZiAmJlxuICAgICAgICAgICAgICAgIG1zZy5yZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLl9oZWFydGJlYXRTZW50QXQgPyBEYXRlLm5vdygpIC0gdGhpcy5faGVhcnRiZWF0U2VudEF0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sobXNnLnBheWxvYWQuc3RhdHVzID09PSAnb2snID8gJ29rJyA6ICdlcnJvcicsIGxhdGVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvZyBpbmNvbWluZyBtZXNzYWdlXG4gICAgICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2c7XG4gICAgICAgICAgICBjb25zdCByZWZTdHJpbmcgPSByZWYgPyBgKCR7cmVmfSlgIDogJyc7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBwYXlsb2FkLnN0YXR1cyB8fCAnJztcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZWNlaXZlJywgYCR7c3RhdHVzfSAke3RvcGljfSAke2V2ZW50fSAke3JlZlN0cmluZ31gLnRyaW0oKSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAvLyBSb3V0ZSBtZXNzYWdlIHRvIGFwcHJvcHJpYXRlIGNoYW5uZWxzXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY2hhbm5lbCkgPT4gY2hhbm5lbC5faXNNZW1iZXIodG9waWMpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBzcGVjaWZpYyB0aW1lclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jbGVhclRpbWVyKHRpbWVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRpbWVyID09PSAnaGVhcnRiZWF0JyAmJiB0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aW1lciA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCB0aW1lcnNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xlYXJBbGxUaW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ2hlYXJ0YmVhdCcpO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdyZWNvbm5lY3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgY29ubmVjdGlvbiBoYW5kbGVycyBmb3IgV2ViU29ja2V0IGV2ZW50c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXR1cENvbm5lY3Rpb25IYW5kbGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNldCBiaW5hcnkgdHlwZSBpZiBzdXBwb3J0ZWQgKGJyb3dzZXJzIGFuZCBtb3N0IFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbnMpXG4gICAgICAgIGlmICgnYmluYXJ5VHlwZScgaW4gdGhpcy5jb25uKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSAoZXJyb3IpID0+IHRoaXMuX29uQ29ubkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudCk7XG4gICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVhcmRvd24gY29ubmVjdGlvbiBhbmQgY2xlYW51cCByZXNvdXJjZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdGVhcmRvd25Db25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ0Vycm9yIGNsb3NpbmcgY29ubmVjdGlvbicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyQWxsVGltZXJzKCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwudGVhcmRvd24oKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uT3BlbigpIHtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZHBvaW50VVJMKCl9YCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBwZW5kaW5nIGF1dGggb3BlcmF0aW9ucyBiZWZvcmUgZmx1c2hpbmcgc2VuZCBidWZmZXJcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGNoYW5uZWwgam9pbiBtZXNzYWdlcyBpbmNsdWRlIHRoZSBjb3JyZWN0IGFjY2VzcyB0b2tlblxuICAgICAgICBjb25zdCBhdXRoUHJvbWlzZSA9IHRoaXMuX2F1dGhQcm9taXNlIHx8XG4gICAgICAgICAgICAodGhpcy5hY2Nlc3NUb2tlbiAmJiAhdGhpcy5hY2Nlc3NUb2tlblZhbHVlID8gdGhpcy5zZXRBdXRoKCkgOiBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgIGF1dGhQcm9taXNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3Igd2FpdGluZyBmb3IgYXV0aCBvbiBjb25uZWN0JywgZSk7XG4gICAgICAgICAgICAvLyBQcm9jZWVkIGFueXdheSB0byBhdm9pZCBoYW5naW5nIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRXb3JrZXJIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zdGFydEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3RhcnRXb3JrZXJIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwpO1xuICAgICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgdGhlIFdlYiBXb3JrZXIgYW5kIGNsZWFyIHRoZSByZWZlcmVuY2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdGVybWluYXRlV29ya2VyKCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJSZWYpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAndGVybWluYXRpbmcgd29ya2VyJyk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZi50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2Nsb3NlJywgZXZlbnQpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ2hlYXJ0YmVhdCcpO1xuICAgICAgICAvLyBPbmx5IHNjaGVkdWxlIHJlY29ubmVjdGlvbiBpZiBpdCB3YXNuJ3QgYSBtYW51YWwgZGlzY29ubmVjdFxuICAgICAgICBpZiAoIXRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ2Nsb3NlJywgZXZlbnQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgJHtlcnJvcn1gKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjaygnZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nO1xuICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3F1ZXJ5fWA7XG4gICAgfVxuICAgIF93b3JrZXJPYmplY3RVcmwodXJsKSB7XG4gICAgICAgIGxldCByZXN1bHRfdXJsO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICByZXN1bHRfdXJsID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtXT1JLRVJfU0NSSVBUXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gICAgICAgICAgICByZXN1bHRfdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0X3VybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGNvbm5lY3Rpb24gc3RhdGUgd2l0aCBwcm9wZXIgc3RhdGUgbWFuYWdlbWVudFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRDb25uZWN0aW9uU3RhdGUoc3RhdGUsIG1hbnVhbCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBtYW51YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIGF1dGggb3BlcmF0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm1BdXRoKHRva2VuID0gbnVsbCkge1xuICAgICAgICBsZXQgdG9rZW5Ub1NlbmQ7XG4gICAgICAgIGxldCBpc01hbnVhbFRva2VuID0gZmFsc2U7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSB0b2tlbjtcbiAgICAgICAgICAgIC8vIFRyYWNrIGlmIHRoaXMgaXMgYSBtYW51YWxseS1wcm92aWRlZCB0b2tlblxuICAgICAgICAgICAgaXNNYW51YWxUb2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgYWNjZXNzVG9rZW4gY2FsbGJhY2sgdG8gZ2V0IGZyZXNoIHRva2VuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRva2VuVG9TZW5kID0gYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnRXJyb3IgZmV0Y2hpbmcgYWNjZXNzIHRva2VuIGZyb20gY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gY2FjaGVkIHZhbHVlIGlmIGNhbGxiYWNrIGZhaWxzXG4gICAgICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSB0aGlzLmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRoaXMuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoaXMgdG9rZW4gd2FzIG1hbnVhbGx5IHNldCBvciBmZXRjaGVkIHZpYSBjYWxsYmFja1xuICAgICAgICBpZiAoaXNNYW51YWxUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5fbWFudWFsbHlTZXRUb2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gSWYgd2UgdXNlZCB0aGUgY2FsbGJhY2ssIGNsZWFyIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgICAgdGhpcy5fbWFudWFsbHlTZXRUb2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgIT0gdG9rZW5Ub1NlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IHRva2VuVG9TZW5kO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogREVGQVVMVF9WRVJTSU9OLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9rZW5Ub1NlbmQgJiYgY2hhbm5lbC51cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5fcHVzaChDSEFOTkVMX0VWRU5UUy5hY2Nlc3NfdG9rZW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIGFueSBpbi1mbGlnaHQgYXV0aCBvcGVyYXRpb25zIHRvIGNvbXBsZXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRGb3JBdXRoSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdXRoUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0aFByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FmZWx5IGNhbGwgc2V0QXV0aCB3aXRoIHN0YW5kYXJkaXplZCBlcnJvciBoYW5kbGluZ1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRBdXRoU2FmZWx5KGNvbnRleHQgPSAnZ2VuZXJhbCcpIHtcbiAgICAgICAgLy8gT25seSByZWZyZXNoIGF1dGggaWYgdXNpbmcgY2FsbGJhY2stYmFzZWQgdG9rZW5zXG4gICAgICAgIGlmICghdGhpcy5faXNNYW51YWxUb2tlbigpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dGgoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGBFcnJvciBzZXR0aW5nIGF1dGggaW4gJHtjb250ZXh0fWAsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBzdGF0ZSBjaGFuZ2UgY2FsbGJhY2tzIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcyhldmVudCwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1tldmVudF0uZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIGluICR7ZXZlbnR9IGNhbGxiYWNrYCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGBlcnJvciB0cmlnZ2VyaW5nICR7ZXZlbnR9IGNhbGxiYWNrc2AsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIHJlY29ubmVjdGlvbiB0aW1lciB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldHVwUmVjb25uZWN0aW9uVGltZXIoKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fd2FpdEZvckF1dGhJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVFMuUkVDT05ORUNUX0RFTEFZKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjbGllbnQgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2luaXRpYWxpemVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIC8vIFNldCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc3BvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfSU5URVJWQUw7XG4gICAgICAgIHRoaXMud29ya2VyID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWNjZXNzVG9rZW4pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0Q2FsbGJhY2spICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG5vb3A7XG4gICAgICAgIHRoaXMudnNuID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZzbikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogREVGQVVMVF9WU047XG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dnZXIpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dMZXZlbCkgfHwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dfbGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0xldmVsID0gb3B0aW9ucy5sb2dMZXZlbCB8fCBvcHRpb25zLmxvZ19sZXZlbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcyksIHsgbG9nX2xldmVsOiB0aGlzLmxvZ0xldmVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB1cCBmdW5jdGlvbnMgd2l0aCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPVxuICAgICAgICAgICAgKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICgodHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUkVDT05ORUNUX0lOVEVSVkFMU1t0cmllcyAtIDFdIHx8IERFRkFVTFRfUkVDT05ORUNUX0ZBTExCQUNLO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy52c24pIHtcbiAgICAgICAgICAgIGNhc2UgVlNOXzFfMF8wOlxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlID1cbiAgICAgICAgICAgICAgICAgICAgKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogKChwYXlsb2FkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAoX2sgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAoKHBheWxvYWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBWU05fMl8wXzA6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmNvZGUgPSAoX2wgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW5jb2RlKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiB0aGlzLnNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IChfbSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWNvZGUpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNlcmlhbGl6ZXIgdmVyc2lvbjogJHt0aGlzLnZzbn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgd29ya2VyIHNldHVwXG4gICAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlclVybDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWx0aW1lQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRGYWN0b3J5IiwiQ0hBTk5FTF9FVkVOVFMiLCJDT05ORUNUSU9OX1NUQVRFIiwiREVGQVVMVF9WRVJTSU9OIiwiREVGQVVMVF9USU1FT1VUIiwiU09DS0VUX1NUQVRFUyIsIlRSQU5TUE9SVFMiLCJERUZBVUxUX1ZTTiIsIlZTTl8xXzBfMCIsIlZTTl8yXzBfMCIsIldTX0NMT1NFX05PUk1BTCIsIlNlcmlhbGl6ZXIiLCJUaW1lciIsImh0dHBFbmRwb2ludFVSTCIsIlJlYWx0aW1lQ2hhbm5lbCIsIm5vb3AiLCJDT05ORUNUSU9OX1RJTUVPVVRTIiwiSEVBUlRCRUFUX0lOVEVSVkFMIiwiUkVDT05ORUNUX0RFTEFZIiwiSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0siLCJSRUNPTk5FQ1RfSU5URVJWQUxTIiwiREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0siLCJXT1JLRVJfU0NSSVBUIiwiUmVhbHRpbWVDbGllbnQiLCJjb25uZWN0IiwiaXNDb25uZWN0aW5nIiwiaXNEaXNjb25uZWN0aW5nIiwiY29ubiIsImlzQ29ubmVjdGVkIiwiX3NldENvbm5lY3Rpb25TdGF0ZSIsImFjY2Vzc1Rva2VuIiwiX2F1dGhQcm9taXNlIiwiX3NldEF1dGhTYWZlbHkiLCJ0cmFuc3BvcnQiLCJlbmRwb2ludFVSTCIsImNyZWF0ZVdlYlNvY2tldCIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiRXJyb3IiLCJfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMiLCJfYXBwZW5kUGFyYW1zIiwiZW5kUG9pbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJwYXJhbXMiLCJ2c24iLCJkaXNjb25uZWN0IiwiY29kZSIsInJlYXNvbiIsImZhbGxiYWNrVGltZXIiLCJzZXRUaW1lb3V0Iiwib25jbG9zZSIsImNsZWFyVGltZW91dCIsImNsb3NlIiwiX3RlYXJkb3duQ29ubmVjdGlvbiIsImdldENoYW5uZWxzIiwiY2hhbm5lbHMiLCJyZW1vdmVDaGFubmVsIiwiY2hhbm5lbCIsInN0YXR1cyIsInVuc3Vic2NyaWJlIiwiX3JlbW92ZSIsImxlbmd0aCIsInJlbW92ZUFsbENoYW5uZWxzIiwidmFsdWVzXzEiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibG9nIiwia2luZCIsIm1zZyIsImRhdGEiLCJsb2dnZXIiLCJjb25uZWN0aW9uU3RhdGUiLCJyZWFkeVN0YXRlIiwiY29ubmVjdGluZyIsIkNvbm5lY3RpbmciLCJvcGVuIiwiT3BlbiIsImNsb3NpbmciLCJDbG9zaW5nIiwiQ2xvc2VkIiwiX2Nvbm5lY3Rpb25TdGF0ZSIsInRvcGljIiwiY29uZmlnIiwicmVhbHRpbWVUb3BpYyIsImV4aXN0cyIsImZpbmQiLCJjIiwiY2hhbiIsInB1c2giLCJldmVudCIsInBheWxvYWQiLCJyZWYiLCJjYWxsYmFjayIsImVuY29kZSIsInJlc3VsdCIsIl9hIiwic2VuZCIsInNlbmRCdWZmZXIiLCJzZXRBdXRoIiwidG9rZW4iLCJfcGVyZm9ybUF1dGgiLCJfaXNNYW51YWxUb2tlbiIsIl9tYW51YWxseVNldFRva2VuIiwic2VuZEhlYXJ0YmVhdCIsImhlYXJ0YmVhdENhbGxiYWNrIiwiZSIsInBlbmRpbmdIZWFydGJlYXRSZWYiLCJfaGVhcnRiZWF0U2VudEF0IiwiX3dhc01hbnVhbERpc2Nvbm5lY3QiLCJyZWNvbm5lY3RUaW1lciIsInNjaGVkdWxlVGltZW91dCIsIkRhdGUiLCJub3ciLCJfbWFrZVJlZiIsIm9uSGVhcnRiZWF0IiwiZmx1c2hTZW5kQnVmZmVyIiwiZm9yRWFjaCIsIm5ld1JlZiIsInRvU3RyaW5nIiwiX2xlYXZlT3BlblRvcGljIiwiZHVwQ2hhbm5lbCIsIl9pc0pvaW5lZCIsIl9pc0pvaW5pbmciLCJmaWx0ZXIiLCJfb25Db25uTWVzc2FnZSIsInJhd01lc3NhZ2UiLCJkZWNvZGUiLCJsYXRlbmN5IiwidW5kZWZpbmVkIiwicmVmU3RyaW5nIiwidHJpbSIsIl9pc01lbWJlciIsIl90cmlnZ2VyIiwiX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcyIsIl9jbGVhclRpbWVyIiwidGltZXIiLCJoZWFydGJlYXRUaW1lciIsImNsZWFySW50ZXJ2YWwiLCJyZXNldCIsIl9jbGVhckFsbFRpbWVycyIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJfb25Db25uT3BlbiIsIm9uZXJyb3IiLCJfb25Db25uRXJyb3IiLCJvbm1lc3NhZ2UiLCJfb25Db25uQ2xvc2UiLCJfdGVybWluYXRlV29ya2VyIiwidGVhcmRvd24iLCJhdXRoUHJvbWlzZSIsImFjY2Vzc1Rva2VuVmFsdWUiLCJyZXNvbHZlIiwidGhlbiIsImNhdGNoIiwid29ya2VyIiwiX3N0YXJ0SGVhcnRiZWF0Iiwid29ya2VyUmVmIiwiX3N0YXJ0V29ya2VySGVhcnRiZWF0Iiwic2V0SW50ZXJ2YWwiLCJoZWFydGJlYXRJbnRlcnZhbE1zIiwid29ya2VyVXJsIiwib2JqZWN0VXJsIiwiX3dvcmtlck9iamVjdFVybCIsIldvcmtlciIsInBvc3RNZXNzYWdlIiwiaW50ZXJ2YWwiLCJ0ZXJtaW5hdGUiLCJfdHJpZ2dlckNoYW5FcnJvciIsInVybCIsImtleXMiLCJwcmVmaXgiLCJtYXRjaCIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwicmVzdWx0X3VybCIsImJsb2IiLCJCbG9iIiwidHlwZSIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInN0YXRlIiwibWFudWFsIiwidG9rZW5Ub1NlbmQiLCJpc01hbnVhbFRva2VuIiwiYWNjZXNzX3Rva2VuIiwidmVyc2lvbiIsInVwZGF0ZUpvaW5QYXlsb2FkIiwiam9pbmVkT25jZSIsIl9wdXNoIiwiX3dhaXRGb3JBdXRoSWZOZWVkZWQiLCJjb250ZXh0Iiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJfc2V0dXBSZWNvbm5lY3Rpb25UaW1lciIsInJlY29ubmVjdEFmdGVyTXMiLCJfaW5pdGlhbGl6ZU9wdGlvbnMiLCJvcHRpb25zIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJfbSIsInRpbWVvdXQiLCJsb2dMZXZlbCIsImxvZ19sZXZlbCIsInRyaWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwic2VyaWFsaXplciIsImJpbmQiLCJ3aW5kb3ciLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsIkFycmF5IiwiaHR0cEVuZHBvaW50IiwiaGVhZGVycyIsIl9yZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsImFwaWtleSIsIndlYnNvY2tldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: function() { return /* binding */ REALTIME_PRESENCE_LISTEN_EVENTS; },\n/* harmony export */   \"default\": function() { return /* binding */ RealtimePresence; }\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n    /**\n     * Creates a Presence helper that keeps the local presence state in sync with the server.\n     *\n     * @param channel - The realtime channel to bind to.\n     * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.\n     *\n     * @example\n     * ```ts\n     * const presence = new RealtimePresence(channel)\n     *\n     * channel.on('presence', ({ event, key }) => {\n     *   console.log(`Presence ${event} on ${key}`)\n     * })\n     * ```\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n} //# sourceMappingURL=RealtimePresence.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVQcmVzZW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7QUFHQSxHQUNPLElBQUlBLGdDQUFnQztBQUMxQyxVQUFVQSwrQkFBK0I7SUFDdENBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsT0FBTyxHQUFHO0lBQzFDQSwrQkFBK0IsQ0FBQyxRQUFRLEdBQUc7QUFDL0MsR0FBR0EsbUNBQW9DQSxDQUFBQSxrQ0FBa0MsQ0FBQztBQUMzRCxNQUFNQztJQXVFakI7Ozs7Ozs7OztLQVNDLEdBQ0QsT0FBT0MsVUFBVUMsWUFBWSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO1FBQ3RELE1BQU1DLFFBQVEsSUFBSSxDQUFDQyxTQUFTLENBQUNMO1FBQzdCLE1BQU1NLG1CQUFtQixJQUFJLENBQUNDLGNBQWMsQ0FBQ047UUFDN0MsTUFBTU8sUUFBUSxDQUFDO1FBQ2YsTUFBTUMsU0FBUyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxDQUFDTixPQUFPLENBQUNPLEtBQUtDO1lBQ2xCLElBQUksQ0FBQ04sZ0JBQWdCLENBQUNLLElBQUksRUFBRTtnQkFDeEJGLE1BQU0sQ0FBQ0UsSUFBSSxHQUFHQztZQUNsQjtRQUNKO1FBQ0EsSUFBSSxDQUFDRixHQUFHLENBQUNKLGtCQUFrQixDQUFDSyxLQUFLRTtZQUM3QixNQUFNQyxtQkFBbUJWLEtBQUssQ0FBQ08sSUFBSTtZQUNuQyxJQUFJRyxrQkFBa0I7Z0JBQ2xCLE1BQU1DLGtCQUFrQkYsYUFBYUgsR0FBRyxDQUFDLENBQUNNLElBQU1BLEVBQUVDLFlBQVk7Z0JBQzlELE1BQU1DLGtCQUFrQkosaUJBQWlCSixHQUFHLENBQUMsQ0FBQ00sSUFBTUEsRUFBRUMsWUFBWTtnQkFDbEUsTUFBTUUsa0JBQWtCTixhQUFhTyxNQUFNLENB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QUksQ0FBQ0QsTUFBTTtZQUMvQyxJQUFJLElBQUksQ0FBQ0Usa0JBQWtCLElBQUk7Z0JBQzNCLElBQUksQ0FBQ00sWUFBWSxDQUFDSyxJQUFJLENBQUM5QjtZQUMzQixPQUNLO2dCQUNELElBQUksQ0FBQ3JCLEtBQUssR0FBR04saUJBQWlCMEIsUUFBUSxDQUFDLElBQUksQ0FBQ3BCLEtBQUssRUFBRXFCLE1BQU12QixRQUFRQztnQkFDakV3QztZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUN6QyxNQUFNLENBQUMsQ0FBQ1MsS0FBS0csa0JBQWtCRDtZQUNoQyxJQUFJLENBQUNpQyxPQUFPLENBQUNVLFFBQVEsQ0FBQyxZQUFZO2dCQUM5QkMsT0FBTztnQkFDUDlDO2dCQUNBRztnQkFDQUQ7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUMsQ0FBQ1EsS0FBS0csa0JBQWtCUTtZQUNqQyxJQUFJLENBQUN3QixPQUFPLENBQUNVLFFBQVEsQ0FBQyxZQUFZO2dCQUM5QkMsT0FBTztnQkFDUDlDO2dCQUNBRztnQkFDQVE7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDcUIsTUFBTSxDQUFDO1lBQ1IsSUFBSSxDQUFDRyxPQUFPLENBQUNVLFFBQVEsQ0FBQyxZQUFZO2dCQUFFQyxPQUFPO1lBQU87UUFDdEQ7SUFDSjtBQXVKSixFQUNBLDRDQUE0QztBQUQzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanM/Y2VjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5leHBvcnQgdmFyIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMpIHtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiU1lOQ1wiXSA9IFwic3luY1wiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJKT0lOXCJdID0gXCJqb2luXCI7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIkxFQVZFXCJdID0gXCJsZWF2ZVwiO1xufSkoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyB8fCAoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUHJlc2VuY2UgaGVscGVyIHRoYXQga2VlcHMgdGhlIGxvY2FsIHByZXNlbmNlIHN0YXRlIGluIHN5bmMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgcmVhbHRpbWUgY2hhbm5lbCB0byBiaW5kIHRvLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uYWwgY3VzdG9tIGV2ZW50IG5hbWVzLCBlLmcuIGB7IGV2ZW50czogeyBzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnIH0gfWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZShjaGFubmVsKVxuICAgICAqXG4gICAgICogY2hhbm5lbC5vbigncHJlc2VuY2UnLCAoeyBldmVudCwga2V5IH0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBQcmVzZW5jZSAke2V2ZW50fSBvbiAke2tleX1gKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cykge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgICAgICAgIG9uSm9pbjogKCkgPT4geyB9LFxuICAgICAgICAgICAgb25MZWF2ZTogKCkgPT4geyB9LFxuICAgICAgICAgICAgb25TeW5jOiAoKSA9PiB7IH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZXZlbnRzKSB8fCB7XG4gICAgICAgICAgICBzdGF0ZTogJ3ByZXNlbmNlX3N0YXRlJyxcbiAgICAgICAgICAgIGRpZmY6ICdwcmVzZW5jZV9kaWZmJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuc3RhdGUsIHt9LCAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLl9qb2luUmVmKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jU3RhdGUodGhpcy5zdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgICAgICAgIG9uU3luYygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuZGlmZiwge30sIChkaWZmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uSm9pbigoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdqb2luJyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgICAgICAgICBuZXdQcmVzZW5jZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25MZWF2ZSgoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnbGVhdmUnLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIGxlZnRQcmVzZW5jZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25TeW5jKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7IGV2ZW50OiAnc3luYycgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXIgd2l0aCB0aGVcbiAgICAgKiBjbGllbnQncyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIHRvXG4gICAgICogcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jbG9uZURlZXAoY3VycmVudFN0YXRlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdGF0ZSA9IHRoaXMudHJhbnNmb3JtU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBjb25zdCBqb2lucyA9IHt9O1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZFN0YXRlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwKHRyYW5zZm9ybWVkU3RhdGUsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ByZXNlbmNlUmVmcyA9IG5ld1ByZXNlbmNlcy5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZVJlZnMgPSBjdXJyZW50UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlcyA9IG5ld1ByZXNlbmNlcy5maWx0ZXIoKG0pID0+IGN1clByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gbmV3UHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5lZFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGpvaW5zW2tleV0gPSBqb2luZWRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVzW2tleV0gPSBsZWZ0UHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwgeyBqb2lucywgbGVhdmVzIH0sIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmUgZXZlbnRzIGZyb20gdGhlXG4gICAgICogc2VydmVyLCBhcyB0aGV5IGhhcHBlbi5cbiAgICAgKlxuICAgICAqIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmAgYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmRcbiAgICAgKiBgb25MZWF2ZWAgY2FsbGJhY2tzIHRvIHJlYWN0IHRvIGEgdXNlciBqb2luaW5nIG9yIGxlYXZpbmcgZnJvbSBhXG4gICAgICogZGV2aWNlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNEaWZmKHN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3QgeyBqb2lucywgbGVhdmVzIH0gPSB7XG4gICAgICAgICAgICBqb2luczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmpvaW5zKSxcbiAgICAgICAgICAgIGxlYXZlczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmxlYXZlcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgICAgICBvbkpvaW4gPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgICAgICBvbkxlYXZlID0gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXMgPSAoX2EgPSBzdGF0ZVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lRGVlcChuZXdQcmVzZW5jZXMpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlUmVmcyA9IHN0YXRlW2tleV0ubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IGpvaW5lZFByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgICAgIHN0YXRlW2tleV0udW5zaGlmdCguLi5jdXJQcmVzZW5jZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJlc2VuY2VzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlUmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlcy5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gcHJlc2VuY2VSZWZzVG9SZW1vdmUuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSBjdXJyZW50UHJlc2VuY2VzO1xuICAgICAgICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIG1hcChvYmosIGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgJ21ldGFzJyBrZXlcbiAgICAgKiBDaGFuZ2UgJ3BoeF9yZWYnIHRvICdwcmVzZW5jZV9yZWYnXG4gICAgICogUmVtb3ZlICdwaHhfcmVmJyBhbmQgJ3BoeF9yZWZfcHJldidcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJucyB7XG4gICAgICogIGFiYzEyMzogW1xuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMicsIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgXVxuICAgICAqIH1cbiAgICAgKiBSZWFsdGltZVByZXNlbmNlLnRyYW5zZm9ybVN0YXRlKHtcbiAgICAgKiAgYWJjMTIzOiB7XG4gICAgICogICAgbWV0YXM6IFtcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzInLCBwaHhfcmVmX3ByZXY6ICcxJyB1c2VyX2lkOiAxIH0sXG4gICAgICogICAgICB7IHBoeF9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAgICogICAgXVxuICAgICAqICB9XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlKS5yZWR1Y2UoKG5ld1N0YXRlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoJ21ldGFzJyBpbiBwcmVzZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzLm1ldGFzLm1hcCgocHJlc2VuY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VbJ3ByZXNlbmNlX3JlZiddID0gcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZl9wcmV2J107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBjbG9uZURlZXAob2JqKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25Kb2luKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25MZWF2ZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvblN5bmMoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8IHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLl9qb2luUmVmKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVQcmVzZW5jZS5qcy5tYXAiXSwibmFtZXMiOlsiUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyIsIlJlYWx0aW1lUHJlc2VuY2UiLCJzeW5jU3RhdGUiLCJjdXJyZW50U3RhdGUiLCJuZXdTdGF0ZSIsIm9uSm9pbiIsIm9uTGVhdmUiLCJzdGF0ZSIsImNsb25lRGVlcCIsInRyYW5zZm9ybWVkU3RhdGUiLCJ0cmFuc2Zvcm1TdGF0ZSIsImpvaW5zIiwibGVhdmVzIiwibWFwIiwia2V5IiwicHJlc2VuY2VzIiwibmV3UHJlc2VuY2VzIiwiY3VycmVudFByZXNlbmNlcyIsIm5ld1ByZXNlbmNlUmVmcyIsIm0iLCJwcmVzZW5jZV9yZWYiLCJjdXJQcmVzZW5jZVJlZnMiLCJqb2luZWRQcmVzZW5jZXMiLCJmaWx0ZXIiLCJpbmRleE9mIiwibGVmdFByZXNlbmNlcyIsImxlbmd0aCIsInN5bmNEaWZmIiwiZGlmZiIsIl9hIiwiam9pbmVkUHJlc2VuY2VSZWZzIiwiY3VyUHJlc2VuY2VzIiwidW5zaGlmdCIsInByZXNlbmNlUmVmc1RvUmVtb3ZlIiwib2JqIiwiZnVuYyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJtZXRhcyIsInByZXNlbmNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY2FsbGJhY2siLCJjYWxsZXIiLCJvblN5bmMiLCJpblBlbmRpbmdTeW5jU3RhdGUiLCJqb2luUmVmIiwiY2hhbm5lbCIsIl9qb2luUmVmIiwiY29uc3RydWN0b3IiLCJvcHRzIiwicGVuZGluZ0RpZmZzIiwiZW5hYmxlZCIsImV2ZW50cyIsIl9vbiIsImZvckVhY2giLCJwdXNoIiwiX3RyaWdnZXIiLCJldmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: function() { return /* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES; },\n/* harmony export */   REALTIME_LISTEN_TYPES: function() { return /* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES; },\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: function() { return /* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT; },\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: function() { return /* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS; },\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: function() { return /* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES; },\n/* harmony export */   RealtimeChannel: function() { return /* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   RealtimeClient: function() { return /* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   RealtimePresence: function() { return /* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   WebSocketFactory: function() { return /* reexport safe */ _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUMwSDtBQUNoRjtBQUNqQztBQUM2SyxDQUNwTyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9pbmRleC5qcz81NTVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICcuL1JlYWx0aW1lQ2xpZW50JztcbmltcG9ydCBSZWFsdGltZUNoYW5uZWwsIHsgUkVBTFRJTUVfTElTVEVOX1RZUEVTLCBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCwgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMsIH0gZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnO1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UsIHsgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUywgfSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnO1xuaW1wb3J0IFdlYlNvY2tldEZhY3RvcnkgZnJvbSAnLi9saWIvd2Vic29ja2V0LWZhY3RvcnknO1xuZXhwb3J0IHsgUmVhbHRpbWVQcmVzZW5jZSwgUmVhbHRpbWVDaGFubmVsLCBSZWFsdGltZUNsaWVudCwgUkVBTFRJTUVfTElTVEVOX1RZUEVTLCBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCwgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUywgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMsIFdlYlNvY2tldEZhY3RvcnksIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiUmVhbHRpbWVDbGllbnQiLCJSZWFsdGltZUNoYW5uZWwiLCJSRUFMVElNRV9MSVNURU5fVFlQRVMiLCJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCJSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyIsIlJlYWx0aW1lUHJlc2VuY2UiLCJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIiwiV2ViU29ja2V0RmFjdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: function() { return /* binding */ CHANNEL_EVENTS; },\n/* harmony export */   CHANNEL_STATES: function() { return /* binding */ CHANNEL_STATES; },\n/* harmony export */   CONNECTION_STATE: function() { return /* binding */ CONNECTION_STATE; },\n/* harmony export */   DEFAULT_TIMEOUT: function() { return /* binding */ DEFAULT_TIMEOUT; },\n/* harmony export */   DEFAULT_VERSION: function() { return /* binding */ DEFAULT_VERSION; },\n/* harmony export */   DEFAULT_VSN: function() { return /* binding */ DEFAULT_VSN; },\n/* harmony export */   MAX_PUSH_BUFFER_SIZE: function() { return /* binding */ MAX_PUSH_BUFFER_SIZE; },\n/* harmony export */   SOCKET_STATES: function() { return /* binding */ SOCKET_STATES; },\n/* harmony export */   TRANSPORTS: function() { return /* binding */ TRANSPORTS; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   VSN_1_0_0: function() { return /* binding */ VSN_1_0_0; },\n/* harmony export */   VSN_2_0_0: function() { return /* binding */ VSN_2_0_0; },\n/* harmony export */   WS_CLOSE_NORMAL: function() { return /* binding */ WS_CLOSE_NORMAL; }\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_VERSION = \"realtime-js/\".concat(_version__WEBPACK_IMPORTED_MODULE_0__.version);\nconst VSN_1_0_0 = \"1.0.0\";\nconst VSN_2_0_0 = \"2.0.0\";\nconst DEFAULT_VSN = VSN_2_0_0;\nconst VERSION = _version__WEBPACK_IMPORTED_MODULE_0__.version;\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUM3QixNQUFNQyxrQkFBa0IsZUFBdUIsT0FBUkQsNkNBQU9BLEVBQUc7QUFDakQsTUFBTUUsWUFBWSxRQUFRO0FBQzFCLE1BQU1DLFlBQVksUUFBUTtBQUMxQixNQUFNQyxjQUFjRCxVQUFVO0FBQzlCLE1BQU1FLFVBQVVMLDZDQUFPQSxDQUFDO0FBQ3hCLE1BQU1NLGtCQUFrQixNQUFNO0FBQzlCLE1BQU1DLGtCQUFrQixLQUFLO0FBQzdCLE1BQU1DLHVCQUF1QixJQUFJO0FBQ2pDLElBQUlDLGNBQWM7QUFDeEIsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUNqREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNqRCxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQy9CLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLE9BQU8sR0FBRztJQUN6QkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLGVBQWUsR0FBRztBQUNyQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLFdBQVc7QUFDckIsVUFBVUEsVUFBVTtJQUNqQkEsVUFBVSxDQUFDLFlBQVksR0FBRztBQUM5QixHQUFHQSxjQUFlQSxDQUFBQSxhQUFhLENBQUM7QUFDekIsSUFBSUMsaUJBQWlCO0FBQzNCLFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsYUFBYSxHQUFHO0lBQ2pDQSxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUc7SUFDM0JBLGdCQUFnQixDQUFDLFVBQVUsR0FBRztJQUM5QkEsZ0JBQWdCLENBQUMsU0FBUyxHQUFHO0FBQ2pDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUMsS0FDNUMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcz9hYzEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVkVSU0lPTiA9IGByZWFsdGltZS1qcy8ke3ZlcnNpb259YDtcbmV4cG9ydCBjb25zdCBWU05fMV8wXzAgPSAnMS4wLjAnO1xuZXhwb3J0IGNvbnN0IFZTTl8yXzBfMCA9ICcyLjAuMCc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9WU04gPSBWU05fMl8wXzA7XG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHZlcnNpb247XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMDtcbmV4cG9ydCBjb25zdCBNQVhfUFVTSF9CVUZGRVJfU0laRSA9IDEwMDtcbmV4cG9ydCB2YXIgU09DS0VUX1NUQVRFUztcbihmdW5jdGlvbiAoU09DS0VUX1NUQVRFUykge1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcIm9wZW5cIl0gPSAxXSA9IFwib3BlblwiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NpbmdcIl0gPSAyXSA9IFwiY2xvc2luZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NlZFwiXSA9IDNdID0gXCJjbG9zZWRcIjtcbn0pKFNPQ0tFVF9TVEFURVMgfHwgKFNPQ0tFVF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX1NUQVRFUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9TVEFURVMpIHtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJlcnJvcmVkXCJdID0gXCJlcnJvcmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luZWRcIl0gPSBcImpvaW5lZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wibGVhdmluZ1wiXSA9IFwibGVhdmluZ1wiO1xufSkoQ0hBTk5FTF9TVEFURVMgfHwgKENIQU5ORUxfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJjbG9zZVwiXSA9IFwicGh4X2Nsb3NlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJlcnJvclwiXSA9IFwicGh4X2Vycm9yXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wicmVwbHlcIl0gPSBcInBoeF9yZXBseVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wibGVhdmVcIl0gPSBcInBoeF9sZWF2ZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTIHx8IChDSEFOTkVMX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgdmFyIFRSQU5TUE9SVFM7XG4oZnVuY3Rpb24gKFRSQU5TUE9SVFMpIHtcbiAgICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgfHwgKFRSQU5TUE9SVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBDT05ORUNUSU9OX1NUQVRFO1xuKGZ1bmN0aW9uIChDT05ORUNUSU9OX1NUQVRFKSB7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiT3BlblwiXSA9IFwib3BlblwiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG59KShDT05ORUNUSU9OX1NUQVRFIHx8IChDT05ORUNUSU9OX1NUQVRFID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkRFRkFVTFRfVkVSU0lPTiIsIlZTTl8xXzBfMCIsIlZTTl8yXzBfMCIsIkRFRkFVTFRfVlNOIiwiVkVSU0lPTiIsIkRFRkFVTFRfVElNRU9VVCIsIldTX0NMT1NFX05PUk1BTCIsIk1BWF9QVVNIX0JVRkZFUl9TSVpFIiwiU09DS0VUX1NUQVRFUyIsIkNIQU5ORUxfU1RBVEVTIiwiQ0hBTk5FTF9FVkVOVFMiLCJUUkFOU1BPUlRTIiwiQ09OTkVDVElPTl9TVEFURSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Push; }\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive(param) {\n        let { status, response } = param;\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n} //# sourceMappingURL=push.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUQ7QUFDcEMsTUFBTUM7SUFxQmpCQyxPQUFPQyxPQUFPLEVBQUU7UUFDWixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLGVBQWU7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSTtJQUNiO0lBQ0FBLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0MsWUFBWSxDQUFDLFlBQVk7WUFDOUI7UUFDSjtRQUNBLElBQUksQ0FBQ0MsWUFBWTtRQUNqQixJQUFJLENBQUNILElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0ksT0FBTyxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FBQztZQUNyQkMsT0FBTyxJQUFJLENBQUNILE9BQU8sQ0FBQ0csS0FBSztZQUN6QkMsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCWixLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiYSxVQUFVLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxRQUFRO1FBQ25DO0lBQ0o7SUFDQUMsY0FBY0gsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHSSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO0lBQ2xFO0lBQ0FNLFFBQVFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNoQixZQUFZLENBQUNjLFNBQVM7WUFDM0JDLFNBQVMsQ0FBQ0MsS0FBSyxJQUFJLENBQUNuQixZQUFZLE1BQU0sUUFBUW1CLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0MsUUFBUTtRQUN0RjtRQUNBLElBQUksQ0FBQ0MsUUFBUSxDQUFDZCxJQUFJLENBQUM7WUFBRVU7WUFBUUM7UUFBUztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBZCxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNrQixZQUFZLEVBQUU7WUFDbkI7UUFDSjtRQUNBLElBQUksQ0FBQ3hCLEdBQUcsR0FBRyxJQUFJLENBQUNPLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDaUIsUUFBUTtRQUN2QyxJQUFJLENBQUN4QixRQUFRLEdBQUcsSUFBSSxDQUFDTSxPQUFPLENBQUNtQixlQUFlLENBQUMsSUFBSSxDQUFDMUIsR0FBRztRQUNyRCxNQUFNb0IsV0FBVyxDQUFDUjtZQUNkLElBQUksQ0FBQ2IsZUFBZTtZQUNwQixJQUFJLENBQUM0QixjQUFjO1lBQ25CLElBQUksQ0FBQ3pCLFlBQVksR0FBR1U7WUFDcEIsSUFBSSxDQUFDZ0IsYUFBYSxDQUFDaEI7UUFDdkI7UUFDQSxJQUFJLENBQUNMLE9BQU8sQ0FBQ3NCLEdBQUcsQ0FBQyxJQUFJLENBQUM1QixRQUFRLEVBQUUsQ0FBQyxHQUFHbUI7UUFDcEMsSUFBSSxDQUFDSSxZQUFZLEdBQUdNLFdBQVc7WUFDM0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsV0FBVyxDQUFDO1FBQzdCLEdBQUcsSUFBSSxDQUFDakMsT0FBTztJQUNuQjtJQUNBaUMsUUFBUVosTUFBTSxFQUFFRyxRQUFRLEVBQUU7UUFDdEIsSUFBSSxJQUFJLENBQUNyQixRQUFRLEVBQ2IsSUFBSSxDQUFDTSxPQUFPLENBQUN5QixRQUFRLENBQUMsSUFBSSxDQUFDL0IsUUFBUSxFQUFFO1lBQUVrQjtZQUFRRztRQUFTO0lBQ2hFO0lBQ0FXLFVBQVU7UUFDTixJQUFJLENBQUNsQyxlQUFlO1FBQ3BCLElBQUksQ0FBQzRCLGNBQWM7SUFDdkI7SUFDQTVCLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNFLFFBQVEsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDTSxPQUFPLENBQUMyQixJQUFJLENBQUMsSUFBSSxDQUFDakMsUUFBUSxFQUFFLENBQUM7SUFDdEM7SUFDQTBCLGlCQUFpQjtRQUNiUSxhQUFhLElBQUksQ0FBQ1gsWUFBWTtRQUM5QixJQUFJLENBQUNBLFlBQVksR0FBR1k7SUFDeEI7SUFDQVIsY0FBYyxLQUFvQixFQUFFO1lBQXRCLEVBQUVULE1BQU0sRUFBRUcsUUFBUSxFQUFFLEdBQXBCO1FBQ1YsSUFBSSxDQUFDQyxRQUFRLENBQUNjLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFbkIsTUFBTSxLQUFLQSxRQUFRb0IsT0FBTyxDQUFDLENBQUNELElBQU1BLEVBQUVsQixRQUFRLENBQUNFO0lBQy9FO0lBQ0FqQixhQUFhYyxNQUFNLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNqQixZQUFZLElBQUksSUFBSSxDQUFDQSxZQUFZLENBQUNpQixNQUFNLEtBQUtBO0lBQzdEO0lBOUZBOzs7Ozs7O0tBT0MsR0FDRHFCLFlBQVlqQyxPQUFPLEVBQUVJLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRWQsVUFBVUgsMkRBQWUsQ0FBRTtRQUNqRSxJQUFJLENBQUNZLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNJLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNkLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3FCLFlBQVksR0FBR1k7UUFDcEIsSUFBSSxDQUFDcEMsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDRSxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDcUIsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDdEIsUUFBUSxHQUFHO0lBQ3BCO0FBNEVKLEVBQ0EsZ0NBQWdDO0FBRC9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanM/NDQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX1RJTUVPVVQgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkID0ge30sIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVmID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNIb29rcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcmVzZW5kKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXlsb2FkKSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygoX2EgPSB0aGlzLnJlY2VpdmVkUmVzcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5fcmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkO1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKHRoaXMucmVmRXZlbnQsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSk7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZFdmVudClcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSk7XG4gICAgfVxuICAgIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX21hdGNoUmVjZWl2ZSh7IHN0YXR1cywgcmVzcG9uc2UgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBfaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJERUZBVUxUX1RJTUVPVVQiLCJQdXNoIiwicmVzZW5kIiwidGltZW91dCIsIl9jYW5jZWxSZWZFdmVudCIsInJlZiIsInJlZkV2ZW50IiwicmVjZWl2ZWRSZXNwIiwic2VudCIsInNlbmQiLCJfaGFzUmVjZWl2ZWQiLCJzdGFydFRpbWVvdXQiLCJjaGFubmVsIiwic29ja2V0IiwicHVzaCIsInRvcGljIiwiZXZlbnQiLCJwYXlsb2FkIiwiam9pbl9yZWYiLCJfam9pblJlZiIsInVwZGF0ZVBheWxvYWQiLCJPYmplY3QiLCJhc3NpZ24iLCJyZWNlaXZlIiwic3RhdHVzIiwiY2FsbGJhY2siLCJfYSIsInJlc3BvbnNlIiwicmVjSG9va3MiLCJ0aW1lb3V0VGltZXIiLCJfbWFrZVJlZiIsIl9yZXBseUV2ZW50TmFtZSIsIl9jYW5jZWxUaW1lb3V0IiwiX21hdGNoUmVjZWl2ZSIsIl9vbiIsInNldFRpbWVvdXQiLCJ0cmlnZ2VyIiwiX3RyaWdnZXIiLCJkZXN0cm95IiwiX29mZiIsImNsZWFyVGltZW91dCIsInVuZGVmaW5lZCIsImZpbHRlciIsImgiLCJmb3JFYWNoIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Serializer; }\n/* harmony export */ });\nclass Serializer {\n    encode(msg, callback) {\n        if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === \"string\") {\n            return callback(this._binaryEncodeUserBroadcastPush(msg));\n        }\n        let payload = [\n            msg.join_ref,\n            msg.ref,\n            msg.topic,\n            msg.event,\n            msg.payload\n        ];\n        return callback(JSON.stringify(payload));\n    }\n    _binaryEncodeUserBroadcastPush(message) {\n        var _a;\n        if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {\n            return this._encodeBinaryUserBroadcastPush(message);\n        } else {\n            return this._encodeJsonUserBroadcastPush(message);\n        }\n    }\n    _encodeBinaryUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);\n        return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);\n    }\n    _encodeJsonUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};\n        const encoder = new TextEncoder();\n        const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;\n        return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);\n    }\n    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {\n        var _a, _b;\n        const topic = message.topic;\n        const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : \"\";\n        const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : \"\";\n        const userEvent = message.payload.event;\n        // Filter metadata based on allowed keys\n        const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};\n        const metadata = Object.keys(rest).length === 0 ? \"\" : JSON.stringify(rest);\n        // Validate lengths don't exceed uint8 max value (255)\n        if (joinRef.length > 255) {\n            throw new Error(\"joinRef length \".concat(joinRef.length, \" exceeds maximum of 255\"));\n        }\n        if (ref.length > 255) {\n            throw new Error(\"ref length \".concat(ref.length, \" exceeds maximum of 255\"));\n        }\n        if (topic.length > 255) {\n            throw new Error(\"topic length \".concat(topic.length, \" exceeds maximum of 255\"));\n        }\n        if (userEvent.length > 255) {\n            throw new Error(\"userEvent length \".concat(userEvent.length, \" exceeds maximum of 255\"));\n        }\n        if (metadata.length > 255) {\n            throw new Error(\"metadata length \".concat(metadata.length, \" exceeds maximum of 255\"));\n        }\n        const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;\n        const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n        let view = new DataView(header);\n        let offset = 0;\n        view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind\n        view.setUint8(offset++, joinRef.length);\n        view.setUint8(offset++, ref.length);\n        view.setUint8(offset++, topic.length);\n        view.setUint8(offset++, userEvent.length);\n        view.setUint8(offset++, metadata.length);\n        view.setUint8(offset++, encodingType);\n        Array.from(joinRef, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(ref, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(topic, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(userEvent, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(metadata, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);\n        combined.set(new Uint8Array(header), 0);\n        combined.set(new Uint8Array(encodedPayload), header.byteLength);\n        return combined.buffer;\n    }\n    decode(rawPayload, callback) {\n        if (this._isArrayBuffer(rawPayload)) {\n            let result = this._binaryDecode(rawPayload);\n            return callback(result);\n        }\n        if (typeof rawPayload === \"string\") {\n            const jsonPayload = JSON.parse(rawPayload);\n            const [join_ref, ref, topic, event, payload] = jsonPayload;\n            return callback({\n                join_ref,\n                ref,\n                topic,\n                event,\n                payload\n            });\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const kind = view.getUint8(0);\n        const decoder = new TextDecoder();\n        switch(kind){\n            case this.KINDS.userBroadcast:\n                return this._decodeUserBroadcast(buffer, view, decoder);\n        }\n    }\n    _decodeUserBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const userEventSize = view.getUint8(2);\n        const metadataSize = view.getUint8(3);\n        const payloadEncoding = view.getUint8(4);\n        let offset = this.HEADER_LENGTH + 4;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));\n        offset = offset + userEventSize;\n        const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));\n        offset = offset + metadataSize;\n        const payload = buffer.slice(offset, buffer.byteLength);\n        const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;\n        const data = {\n            type: this.BROADCAST_EVENT,\n            event: userEvent,\n            payload: parsedPayload\n        };\n        // Metadata is optional and always JSON encoded\n        if (metadataSize > 0) {\n            data[\"meta\"] = JSON.parse(metadata);\n        }\n        return {\n            join_ref: null,\n            ref: null,\n            topic: topic,\n            event: this.BROADCAST_EVENT,\n            payload: data\n        };\n    }\n    _isArrayBuffer(buffer) {\n        var _a;\n        return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"ArrayBuffer\";\n    }\n    _pick(obj, keys) {\n        if (!obj || typeof obj !== \"object\") {\n            return {};\n        }\n        return Object.fromEntries(Object.entries(obj).filter((param)=>{\n            let [key] = param;\n            return keys.includes(key);\n        }));\n    }\n    constructor(allowedMetadataKeys){\n        this.HEADER_LENGTH = 1;\n        this.USER_BROADCAST_PUSH_META_LENGTH = 6;\n        this.KINDS = {\n            userBroadcastPush: 3,\n            userBroadcast: 4\n        };\n        this.BINARY_ENCODING = 0;\n        this.JSON_ENCODING = 1;\n        this.BROADCAST_EVENT = \"broadcast\";\n        this.allowedMetadataKeys = [];\n        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];\n    }\n} //# sourceMappingURL=serializer.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLE1BQU1BO0lBV2pCQyxPQUFPQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUNsQixJQUFJRCxJQUFJRSxLQUFLLEtBQUssSUFBSSxDQUFDQyxlQUFlLElBQ2xDLENBQUVILENBQUFBLElBQUlJLE9BQU8sWUFBWUMsV0FBVSxLQUNuQyxPQUFPTCxJQUFJSSxPQUFPLENBQUNGLEtBQUssS0FBSyxVQUFVO1lBQ3ZDLE9BQU9ELFNBQVMsSUFBSSxDQUFDSyw4QkFBOEIsQ0FBQ047UUFDeEQ7UUFDQSxJQUFJSSxVQUFVO1lBQUNKLElBQUlPLFFBQVE7WUFBRVAsSUFBSVEsR0FBRztZQUFFUixJQUFJUyxLQUFLO1lBQUVULElBQUlFLEtBQUs7WUFBRUYsSUFBSUksT0FBTztTQUFDO1FBQ3hFLE9BQU9ILFNBQVNTLEtBQUtDLFNBQVMsQ0FBQ1A7SUFDbkM7SUFDQUUsK0JBQStCTSxPQUFPLEVBQUU7UUFDcEMsSUFBSUM7UUFDSixJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDLENBQUNELEtBQUtELFFBQVFSLE9BQU8sTUFBTSxRQUFRUyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdULE9BQU8sR0FBRztZQUM3RixPQUFPLElBQUksQ0FBQ1csOEJBQThCLENBQUNIO1FBQy9DLE9BQ0s7WUFDRCxPQUFPLElBQUksQ0FBQ0ksNEJBQTRCLENBQUNKO1FBQzdDO0lBQ0o7SUFDQUcsK0JBQStCSCxPQUFPLEVBQUU7UUFDcEMsSUFBSUMsSUFBSUk7UUFDUixNQUFNQyxjQUFjLENBQUNELEtBQUssQ0FBQ0osS0FBS0QsUUFBUVIsT0FBTyxNQUFNLFFBQVFTLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1QsT0FBTyxNQUFNLFFBQVFhLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElB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bUI7WUFBR21CLGVBQWU7UUFBRTtRQUN0RCxJQUFJLENBQUM5QyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDSyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDdEIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQzRCLG1CQUFtQixHQUFHLEVBQUU7UUFDN0IsSUFBSSxDQUFDQSxtQkFBbUIsR0FBR0Esd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUlBLHNCQUFzQixFQUFFO0lBQ3hIO0FBNElKLEVBQ0Esc0NBQXNDO0FBRHJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanM/ODFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkTWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gICAgICAgIHRoaXMuVVNFUl9CUk9BRENBU1RfUFVTSF9NRVRBX0xFTkdUSCA9IDY7XG4gICAgICAgIHRoaXMuS0lORFMgPSB7IHVzZXJCcm9hZGNhc3RQdXNoOiAzLCB1c2VyQnJvYWRjYXN0OiA0IH07XG4gICAgICAgIHRoaXMuQklOQVJZX0VOQ09ESU5HID0gMDtcbiAgICAgICAgdGhpcy5KU09OX0VOQ09ESU5HID0gMTtcbiAgICAgICAgdGhpcy5CUk9BRENBU1RfRVZFTlQgPSAnYnJvYWRjYXN0JztcbiAgICAgICAgdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzID0gW107XG4gICAgICAgIHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5cyA9IGFsbG93ZWRNZXRhZGF0YUtleXMgIT09IG51bGwgJiYgYWxsb3dlZE1ldGFkYXRhS2V5cyAhPT0gdm9pZCAwID8gYWxsb3dlZE1ldGFkYXRhS2V5cyA6IFtdO1xuICAgIH1cbiAgICBlbmNvZGUobXNnLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobXNnLmV2ZW50ID09PSB0aGlzLkJST0FEQ0FTVF9FVkVOVCAmJlxuICAgICAgICAgICAgIShtc2cucGF5bG9hZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG1zZy5wYXlsb2FkLmV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmFyeUVuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgX2JpbmFyeUVuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5faXNBcnJheUJ1ZmZlcigoX2EgPSBtZXNzYWdlLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXlsb2FkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jb2RlQmluYXJ5VXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VyUGF5bG9hZCA9IChfYiA9IChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UsIHRoaXMuQklOQVJZX0VOQ09ESU5HLCB1c2VyUGF5bG9hZCk7XG4gICAgfVxuICAgIF9lbmNvZGVKc29uVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VyUGF5bG9hZCA9IChfYiA9IChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRVc2VyUGF5bG9hZCA9IGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHVzZXJQYXlsb2FkKSkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgdGhpcy5KU09OX0VOQ09ESU5HLCBlbmNvZGVkVXNlclBheWxvYWQpO1xuICAgIH1cbiAgICBfZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgZW5jb2RpbmdUeXBlLCBlbmNvZGVkUGF5bG9hZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG1lc3NhZ2UudG9waWM7XG4gICAgICAgIGNvbnN0IHJlZiA9IChfYSA9IG1lc3NhZ2UucmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3Qgam9pblJlZiA9IChfYiA9IG1lc3NhZ2Uuam9pbl9yZWYpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICBjb25zdCB1c2VyRXZlbnQgPSBtZXNzYWdlLnBheWxvYWQuZXZlbnQ7XG4gICAgICAgIC8vIEZpbHRlciBtZXRhZGF0YSBiYXNlZCBvbiBhbGxvd2VkIGtleXNcbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5c1xuICAgICAgICAgICAgPyB0aGlzLl9waWNrKG1lc3NhZ2UucGF5bG9hZCwgdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzKVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBPYmplY3Qua2V5cyhyZXN0KS5sZW5ndGggPT09IDAgPyAnJyA6IEpTT04uc3RyaW5naWZ5KHJlc3QpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBsZW5ndGhzIGRvbid0IGV4Y2VlZCB1aW50OCBtYXggdmFsdWUgKDI1NSlcbiAgICAgICAgaWYgKGpvaW5SZWYubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW5SZWYgbGVuZ3RoICR7am9pblJlZi5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWYgbGVuZ3RoICR7cmVmLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpYy5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdG9waWMgbGVuZ3RoICR7dG9waWMubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJFdmVudC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlckV2ZW50IGxlbmd0aCAke3VzZXJFdmVudC5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1ldGFkYXRhIGxlbmd0aCAke21ldGFkYXRhLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFMZW5ndGggPSB0aGlzLlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEggK1xuICAgICAgICAgICAgam9pblJlZi5sZW5ndGggK1xuICAgICAgICAgICAgcmVmLmxlbmd0aCArXG4gICAgICAgICAgICB0b3BpYy5sZW5ndGggK1xuICAgICAgICAgICAgdXNlckV2ZW50Lmxlbmd0aCArXG4gICAgICAgICAgICBtZXRhZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMudXNlckJyb2FkY2FzdFB1c2gpOyAvLyBraW5kXG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5SZWYubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHVzZXJFdmVudC5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBtZXRhZGF0YS5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBlbmNvZGluZ1R5cGUpO1xuICAgICAgICBBcnJheS5mcm9tKGpvaW5SZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbShyZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0b3BpYywgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKHVzZXJFdmVudCwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKG1ldGFkYXRhLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgZW5jb2RlZFBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKTtcbiAgICAgICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZWRQYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyO1xuICAgIH1cbiAgICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXJyYXlCdWZmZXIocmF3UGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uUGF5bG9hZCA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IGpzb25QYXlsb2FkO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHsgam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7fSk7XG4gICAgfVxuICAgIF9iaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgY29uc3Qga2luZCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuS0lORFMudXNlckJyb2FkY2FzdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlVXNlckJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kZWNvZGVVc2VyQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICBjb25zdCB1c2VyRXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTaXplID0gdmlldy5nZXRVaW50OCgzKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZEVuY29kaW5nID0gdmlldy5nZXRVaW50OCg0KTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDQ7XG4gICAgICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgICAgY29uc3QgdXNlckV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdXNlckV2ZW50U2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyB1c2VyRXZlbnRTaXplO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIG1ldGFkYXRhU2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBtZXRhZGF0YVNpemU7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPSBwYXlsb2FkRW5jb2RpbmcgPT09IHRoaXMuSlNPTl9FTkNPRElORyA/IEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUocGF5bG9hZCkpIDogcGF5bG9hZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuQlJPQURDQVNUX0VWRU5ULFxuICAgICAgICAgICAgZXZlbnQ6IHVzZXJFdmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBhcnNlZFBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ldGFkYXRhIGlzIG9wdGlvbmFsIGFuZCBhbHdheXMgSlNPTiBlbmNvZGVkXG4gICAgICAgIGlmIChtZXRhZGF0YVNpemUgPiAwKSB7XG4gICAgICAgICAgICBkYXRhWydtZXRhJ10gPSBKU09OLnBhcnNlKG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiB0aGlzLkJST0FEQ0FTVF9FVkVOVCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgICBfaXNBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgKChfYSA9IGJ1ZmZlciA9PT0gbnVsbCB8fCBidWZmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1ZmZlci5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnQXJyYXlCdWZmZXInO1xuICAgIH1cbiAgICBfcGljayhvYmosIGtleXMpIHtcbiAgICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChba2V5XSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiXSwibmFtZXMiOlsiU2VyaWFsaXplciIsImVuY29kZSIsIm1zZyIsImNhbGxiYWNrIiwiZXZlbnQiLCJCUk9BRENBU1RfRVZFTlQiLCJwYXlsb2FkIiwiQXJyYXlCdWZmZXIiLCJfYmluYXJ5RW5jb2RlVXNlckJyb2FkY2FzdFB1c2giLCJqb2luX3JlZiIsInJlZiIsInRvcGljIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJfYSIsIl9pc0FycmF5QnVmZmVyIiwiX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoIiwiX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaCIsIl9iIiwidXNlclBheWxvYWQiLCJfZW5jb2RlVXNlckJyb2FkY2FzdFB1c2giLCJCSU5BUllfRU5DT0RJTkciLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkVXNlclBheWxvYWQiLCJidWZmZXIiLCJKU09OX0VOQ09ESU5HIiwiZW5jb2RpbmdUeXBlIiwiZW5jb2RlZFBheWxvYWQiLCJqb2luUmVmIiwidXNlckV2ZW50IiwicmVzdCIsImFsbG93ZWRNZXRhZGF0YUtleXMiLCJfcGljayIsIm1ldGFkYXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIkVycm9yIiwibWV0YUxlbmd0aCIsIlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEgiLCJoZWFkZXIiLCJIRUFERVJfTEVOR1RIIiwidmlldyIsIkRhdGFWaWV3Iiwib2Zmc2V0Iiwic2V0VWludDgiLCJLSU5EUyIsInVzZXJCcm9hZGNhc3RQdXNoIiwiQXJyYXkiLCJmcm9tIiwiY2hhciIsImNoYXJDb2RlQXQiLCJjb21iaW5lZCIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwic2V0IiwiZGVjb2RlIiwicmF3UGF5bG9hZCIsInJlc3VsdCIsIl9iaW5hcnlEZWNvZGUiLCJqc29uUGF5bG9hZCIsInBhcnNlIiwia2luZCIsImdldFVpbnQ4IiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwidXNlckJyb2FkY2FzdCIsIl9kZWNvZGVVc2VyQnJvYWRjYXN0IiwidG9waWNTaXplIiwidXNlckV2ZW50U2l6ZSIsIm1ldGFkYXRhU2l6ZSIsInBheWxvYWRFbmNvZGluZyIsInNsaWNlIiwicGFyc2VkUGF5bG9hZCIsImRhdGEiLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwib2JqIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiZmlsdGVyIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Timer; }\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n} //# sourceMappingURL=timer.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNjLE1BQU1BO0lBU2pCQyxRQUFRO1FBQ0osSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYkMsYUFBYSxJQUFJLENBQUNDLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdDO0lBQ2pCO0lBQ0EsOERBQThEO0lBQzlEQyxrQkFBa0I7UUFDZEgsYUFBYSxJQUFJLENBQUNDLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdHLFdBQVc7WUFDcEIsSUFBSSxDQUFDTCxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUc7WUFDMUIsSUFBSSxDQUFDTSxRQUFRO1FBQ2pCLEdBQUcsSUFBSSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDUCxLQUFLLEdBQUc7SUFDbkM7SUFwQkFRLFlBQVlGLFFBQVEsRUFBRUMsU0FBUyxDQUFFO1FBQzdCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDTCxLQUFLLEdBQUdDO1FBQ2IsSUFBSSxDQUFDSCxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNNLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0FBY0osRUFDQSxpQ0FBaUM7QUFEaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdGltZXIuanM/MTE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiXSwibmFtZXMiOlsiVGltZXIiLCJyZXNldCIsInRyaWVzIiwiY2xlYXJUaW1lb3V0IiwidGltZXIiLCJ1bmRlZmluZWQiLCJzY2hlZHVsZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FsbGJhY2siLCJ0aW1lckNhbGMiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: function() { return /* binding */ PostgresTypes; },\n/* harmony export */   convertCell: function() { return /* binding */ convertCell; },\n/* harmony export */   convertChangeData: function() { return /* binding */ convertChangeData; },\n/* harmony export */   convertColumn: function() { return /* binding */ convertColumn; },\n/* harmony export */   httpEndpointURL: function() { return /* binding */ httpEndpointURL; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   toBoolean: function() { return /* binding */ toBoolean; },\n/* harmony export */   toJson: function() { return /* binding */ toJson; },\n/* harmony export */   toNumber: function() { return /* binding */ toNumber; },\n/* harmony export */   toTimestampString: function() { return /* binding */ toTimestampString; }\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = function(columns, record) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (_a) {\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl)=>{\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, \"http\");\n    wsUrl.pathname = wsUrl.pathname.replace(/\\/+$/, \"\") // remove all trailing slashes\n    .replace(/\\/socket\\/websocket$/i, \"\") // remove the socket/websocket path\n    .replace(/\\/socket$/i, \"\") // remove the socket path\n    .replace(/\\/websocket$/i, \"\"); // remove the websocket path\n    if (wsUrl.pathname === \"\" || wsUrl.pathname === \"/\") {\n        wsUrl.pathname = \"/api/broadcast\";\n    } else {\n        wsUrl.pathname = wsUrl.pathname + \"/api/broadcast\";\n    }\n    return wsUrl.href;\n}; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RyYW5zZm9ybWVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDRCwwRUFBMEU7QUFDMUUseUZBQXlGO0FBQ2xGLElBQUlBLGNBQWM7QUFDeEIsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQkEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6QkEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6QkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE1BQU0sR0FBRztJQUN2QkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLGNBQWMsR0FBRztJQUMvQkEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLFlBQVksR0FBRztBQUNqQyxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQ3RDOzs7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b0QsT0FBTyxDQUFDLEtBQUs7SUFDOUI7SUFDQSxPQUFPcEQ7QUFDWCxFQUFFO0FBQ0ssTUFBTXFELGtCQUFrQixDQUFDQztJQUM1QixNQUFNQyxRQUFRLElBQUlDLElBQUlGO0lBQ3RCQyxNQUFNRSxRQUFRLEdBQUdGLE1BQU1FLFFBQVEsQ0FBQ0wsT0FBTyxDQUFDLFFBQVE7SUFDaERHLE1BQU1HLFFBQVEsR0FBR0gsTUFBTUcsUUFBUSxDQUMxQk4sT0FBTyxDQUFDLFFBQVEsSUFBSSw4QkFBOEI7S0FDbERBLE9BQU8sQ0FBQyx5QkFBeUIsSUFBSSxtQ0FBbUM7S0FDeEVBLE9BQU8sQ0FBQyxjQUFjLElBQUkseUJBQXlCO0tBQ25EQSxPQUFPLENBQUMsaUJBQWlCLEtBQUssNEJBQTRCO0lBQy9ELElBQUlHLE1BQU1HLFFBQVEsS0FBSyxNQUFNSCxNQUFNRyxRQUFRLEtBQUssS0FBSztRQUNqREgsTUFBTUcsUUFBUSxHQUFHO0lBQ3JCLE9BQ0s7UUFDREgsTUFBTUcsUUFBUSxHQUFHSCxNQUFNRyxRQUFRLEdBQUc7SUFDdEM7SUFDQSxPQUFPSCxNQUFNSSxJQUFJO0FBQ3JCLEVBQUUsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdHJhbnNmb3JtZXJzLmpzPzNmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcbmV4cG9ydCB2YXIgUG9zdGdyZXNUeXBlcztcbihmdW5jdGlvbiAoUG9zdGdyZXNUeXBlcykge1xuICAgIFBvc3RncmVzVHlwZXNbXCJhYnN0aW1lXCJdID0gXCJhYnN0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImJvb2xcIl0gPSBcImJvb2xcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZVwiXSA9IFwiZGF0ZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlcmFuZ2VcIl0gPSBcImRhdGVyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDRcIl0gPSBcImZsb2F0NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDhcIl0gPSBcImZsb2F0OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQyXCJdID0gXCJpbnQyXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRcIl0gPSBcImludDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NHJhbmdlXCJdID0gXCJpbnQ0cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OFwiXSA9IFwiaW50OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4cmFuZ2VcIl0gPSBcImludDhyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25iXCJdID0gXCJqc29uYlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJtb25leVwiXSA9IFwibW9uZXlcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibnVtZXJpY1wiXSA9IFwibnVtZXJpY1wiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJvaWRcIl0gPSBcIm9pZFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJyZWx0aW1lXCJdID0gXCJyZWx0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRleHRcIl0gPSBcInRleHRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZVwiXSA9IFwidGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXBcIl0gPSBcInRpbWVzdGFtcFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXB0elwiXSA9IFwidGltZXN0YW1wdHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXR6XCJdID0gXCJ0aW1ldHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHNyYW5nZVwiXSA9IFwidHNyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3R6cmFuZ2VcIl0gPSBcInRzdHpyYW5nZVwiO1xufSkoUG9zdGdyZXNUeXBlcyB8fCAoUG9zdGdyZXNUeXBlcyA9IHt9KSk7XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKGNvbHVtbnMsIHJlY29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRoZSB2YWx1ZSBvZiBhbiBpbmRpdmlkdWFsIGNvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uTmFtZSBUaGUgY29sdW1uIHRoYXQgeW91IHdhbnQgdG8gY29udmVydFxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnMgQWxsIG9mIHRoZSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIFRoZSBtYXAgb2Ygc3RyaW5nIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheX0gc2tpcFR5cGVzIEFuIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge29iamVjdH0gVXNlbGVzcyBpbmZvcm1hdGlvblxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbXSlcbiAqIC8vPT4gMzNcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbJ2ludDQnXSlcbiAqIC8vPT4gXCIzM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q29sdW1uID0gKGNvbHVtbk5hbWUsIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4udHlwZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXTtcbiAgICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Q2VsbChjb2xUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBub29wKHZhbHVlKTtcbn07XG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBpcyBgbnVsbGAsIHJldHVybnMgbnVsbC5cbiAqIE90aGVyd2lzZSBjb252ZXJ0cyB0aGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHBvc3RncmVzIGNvbHVtbiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNlbGwgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnYm9vbCcsICd0JylcbiAqIC8vPT4gdHJ1ZVxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2ludDgnLCAnMTAnKVxuICogLy89PiAxMFxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ19pbnQ0JywgJ3sxLDIsMyw0fScpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENlbGwgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgICBpZiAodHlwZS5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGUuc2xpY2UoMSwgdHlwZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdG9BcnJheSh2YWx1ZSwgZGF0YVR5cGUpO1xuICAgIH1cbiAgICAvLyBJZiBub3QgbnVsbCwgY29udmVydCB0byBjb3JyZWN0IHR5cGUuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5ib29sOlxuICAgICAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgICAgICAgIHJldHVybiB0b0pzb24odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wOlxuICAgICAgICAgICAgcmV0dXJuIHRvVGltZXN0YW1wU3RyaW5nKHZhbHVlKTsgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmFic3RpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDRyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMucmVsdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcHR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3R6cmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3Qgbm9vcCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Cb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgY29uc3Qgd3NVcmwgPSBuZXcgVVJMKHNvY2tldFVybCk7XG4gICAgd3NVcmwucHJvdG9jb2wgPSB3c1VybC5wcm90b2NvbC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKTtcbiAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lXG4gICAgICAgIC5yZXBsYWNlKC9cXC8rJC8sICcnKSAvLyByZW1vdmUgYWxsIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoL1xcL3NvY2tldFxcL3dlYnNvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0L3dlYnNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC9zb2NrZXQkL2ksICcnKSAvLyByZW1vdmUgdGhlIHNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC93ZWJzb2NrZXQkL2ksICcnKTsgLy8gcmVtb3ZlIHRoZSB3ZWJzb2NrZXQgcGF0aFxuICAgIGlmICh3c1VybC5wYXRobmFtZSA9PT0gJycgfHwgd3NVcmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9ICcvYXBpL2Jyb2FkY2FzdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lICsgJy9hcGkvYnJvYWRjYXN0JztcbiAgICB9XG4gICAgcmV0dXJuIHdzVXJsLmhyZWY7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJQb3N0Z3Jlc1R5cGVzIiwiY29udmVydENoYW5nZURhdGEiLCJjb2x1bW5zIiwicmVjb3JkIiwib3B0aW9ucyIsIl9hIiwic2tpcFR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsInJlY19rZXkiLCJjb252ZXJ0Q29sdW1uIiwiY29sdW1uTmFtZSIsImNvbHVtbiIsImZpbmQiLCJ4IiwibmFtZSIsImNvbFR5cGUiLCJ0eXBlIiwidmFsdWUiLCJpbmNsdWRlcyIsImNvbnZlcnRDZWxsIiwibm9vcCIsImNoYXJBdCIsImRhdGFUeXBlIiwic2xpY2UiLCJsZW5ndGgiLCJ0b0FycmF5IiwiYm9vbCIsInRvQm9vbGVhbiIsImZsb2F0NCIsImZsb2F0OCIsImludDIiLCJpbnQ0IiwiaW50OCIsIm51bWVyaWMiLCJvaWQiLCJ0b051bWJlciIsImpzb24iLCJqc29uYiIsInRvSnNvbiIsInRpbWVzdGFtcCIsInRvVGltZXN0YW1wU3RyaW5nIiwiYWJzdGltZSIsImRhdGUiLCJkYXRlcmFuZ2UiLCJpbnQ0cmFuZ2UiLCJpbnQ4cmFuZ2UiLCJtb25leSIsInJlbHRpbWUiLCJ0ZXh0IiwidGltZSIsInRpbWVzdGFtcHR6IiwidGltZXR6IiwidHNyYW5nZSIsInRzdHpyYW5nZSIsInBhcnNlZFZhbHVlIiwicGFyc2VGbG9hdCIsIk51bWJlciIsImlzTmFOIiwiSlNPTiIsInBhcnNlIiwibGFzdElkeCIsImNsb3NlQnJhY2UiLCJvcGVuQnJhY2UiLCJhcnIiLCJ2YWxUcmltIiwiXyIsInNwbGl0IiwibWFwIiwidmFsIiwicmVwbGFjZSIsImh0dHBFbmRwb2ludFVSTCIsInNvY2tldFVybCIsIndzVXJsIiwiVVJMIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.95.3\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZFQUE2RTtBQUM3RSxnRUFBZ0U7QUFDaEUsdUVBQXVFO0FBQ3ZFLGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQzFELE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz8xZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuOTUuMyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketFactory: function() { return /* binding */ WebSocketFactory; }\n/* harmony export */ });\n/**\n * Utilities for creating WebSocket instances across runtimes.\n */ class WebSocketFactory {\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: globalThis.WebSocket\n            };\n        }\n        if (typeof __webpack_require__.g !== \"undefined\" && typeof __webpack_require__.g.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: __webpack_require__.g.WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocketPair !== \"undefined\" && typeof globalThis.WebSocket === \"undefined\") {\n            return {\n                type: \"cloudflare\",\n                error: \"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.\",\n                workaround: \"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.\"\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.EdgeRuntime || typeof navigator !== \"undefined\" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes(\"Vercel-Edge\"))) {\n            return {\n                type: \"unsupported\",\n                error: \"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.\",\n                workaround: \"Use serverless functions or a different deployment target for WebSocket functionality.\"\n            };\n        }\n        // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n        const _process = globalThis[\"process\"];\n        if (_process) {\n            const processVersions = _process[\"versions\"];\n            if (processVersions && processVersions[\"node\"]) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions[\"node\"];\n                const nodeVersion = parseInt(versionString.replace(/^v/, \"\").split(\".\")[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== \"undefined\") {\n                        return {\n                            type: \"native\",\n                            constructor: globalThis.WebSocket\n                        };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: \"unsupported\",\n                        error: \"Node.js \".concat(nodeVersion, \" detected but native WebSocket not found.\"),\n                        workaround: \"Provide a WebSocket implementation via the transport option.\"\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: \"unsupported\",\n                    error: \"Node.js \".concat(nodeVersion, \" detected without native WebSocket support.\"),\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' + 'import ws from \"ws\"\\n' + \"new RealtimeClient(url, { transport: ws })\"\n                };\n            }\n        }\n        return {\n            type: \"unsupported\",\n            error: \"Unknown JavaScript runtime without WebSocket support.\",\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\"\n        };\n    }\n    /**\n     * Returns the best available WebSocket constructor for the current runtime.\n     *\n     * @example\n     * ```ts\n     * const WS = WebSocketFactory.getWebSocketConstructor()\n     * const socket = new WS('wss://realtime.supabase.co/socket')\n     * ```\n     */ static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || \"WebSocket not supported in this environment.\";\n        if (env.workaround) {\n            errorMessage += \"\\n\\nSuggested solution: \".concat(env.workaround);\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Creates a WebSocket using the detected constructor.\n     *\n     * @example\n     * ```ts\n     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')\n     * ```\n     */ static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    /**\n     * Detects whether the runtime can establish WebSocket connections.\n     *\n     * @example\n     * ```ts\n     * if (!WebSocketFactory.isWebSocketSupported()) {\n     *   console.warn('Falling back to long polling')\n     * }\n     * ```\n     */ static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === \"native\" || env.type === \"ws\";\n        } catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Static-only utility  prevent instantiation.\n     */ constructor(){}\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (WebSocketFactory); //# sourceMappingURL=websocket-factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3dlYnNvY2tldC1mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNNLE1BQU1BO0lBS1QsT0FBT0Msb0JBQW9CO1FBQ3ZCLElBQUlDO1FBQ0osSUFBSSxPQUFPQyxjQUFjLGFBQWE7WUFDbEMsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUMsYUFBYUY7WUFBVTtRQUNwRDtRQUNBLElBQUksT0FBT0csZUFBZSxlQUFlLE9BQU9BLFdBQVdILFNBQVMsS0FBSyxhQUFhO1lBQ2xGLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVDLGFBQWFDLFdBQVdILFNBQVM7WUFBQztRQUMvRDtRQUNBLElBQUksT0FBT0kscUJBQU1BLEtBQUssZUFBZSxPQUFPQSxxQkFBTUEsQ0FBQ0osU0FBUyxLQUFLLGFBQWE7WUFDMUUsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUMsYUFBYUUscUJBQU1BLENBQUNKLFNBQVM7WUFBQztRQUMzRDtRQUNBLElBQUksT0FBT0csZUFBZSxlQUN0QixPQUFPQSxXQUFXRSxhQUFhLEtBQUssZUFDcEMsT0FBT0YsV0FBV0gsU0FBUyxLQUFLLGFBQWE7WUFDN0MsT0FBTztnQkFDSEMsTUFBTTtnQkFDTkssT0FBTztnQkFDUEMsWUFBWTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxPQUFRSixlQUFlLGVBQWVBLFdBQVdLLFdBQVcsSUFDM0QsT0FBT0MsY0FBYyxlQUFnQixFQUFDVixLQUFLVSxVQUFVQyxTQUFTLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHWSxRQUFRLENBQUMsY0FBYSxHQUFLO1lBQ3BJLE9BQU87Z0JBQ0hWLE1BQU07Z0JBQ05LLE9BQU87Z0JBQ1BDLFlBQVk7WUFDaEI7UUFDSjtRQUNBLHFGQUFxRjtRQUNyRixNQUFNSyxXQUFXVCxVQUFVLENBQUMsVUFBVTtRQUN0QyxJQUFJUyxVQUFVO1lBQ1YsTUFBTUMsa0JBQWtCRCxRQUFRLENBQUMsV0FBVztZQUM1QyxJQUFJQyxtQkFBbUJBLGVBQWUsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVDLDJEQUEyRDtnQkFDM0QsTUFBTUMsZ0JBQWdCRCxlQUFlLENBQUMsT0FBTztnQkFDN0MsTUFBTUUsY0FBY0MsU0FBU0YsY0FBY0csT0FBTyxDQUFDLE1BQU0sSUFBSUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxRSwyQ0FBMkM7Z0JBQzNDLElBQUlILGVBQWUsSUFBSTtvQkFDbkIsb0VBQW9FO29CQUNwRSxJQUFJLE9BQU9aLFdBQVdILFNBQVMsS0FBSyxhQUFhO3dCQUM3QyxPQUFPOzRCQUFFQyxNQUFNOzRCQUFVQyxhQUFhQyxXQUFXSCxTQUFTO3dCQUFDO29CQUMvRDtvQkFDQSw2Q0FBNkM7b0JBQzdDLE9BQU87d0JBQ0hDLE1BQU07d0JBQ05LLE9BQU8sV0FBdUIsT0FBWlMsYUFBWTt3QkFDOUJSLFlBQVk7b0JBQ2hCO2dCQUNKO2dCQUNBLDZDQUE2QztnQkFDN0MsT0FBTztvQkFDSE4sTUFBTTtvQkFDTkssT0FBTyxXQUF1QixPQUFaUyxhQUFZO29CQUM5QlIsWUFBWSxzRkFDUiwwQkFDQTtnQkFDUjtZQUNKO1FBQ0o7UUFDQSxPQUFPO1lBQ0hOLE1BQU07WUFDTkssT0FBTztZQUNQQyxZQUFZO1FBQ2hCO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE9BQU9ZLDBCQUEwQjtRQUM3QixNQUFNQyxNQUFNLElBQUksQ0FBQ3RCLGlCQUFpQjtRQUNsQyxJQUFJc0IsSUFBSWxCLFdBQVcsRUFBRTtZQUNqQixPQUFPa0IsSUFBSWxCLFdBQVc7UUFDMUI7UUFDQSxJQUFJbUIsZUFBZUQsSUFBSWQsS0FBSyxJQUFJO1FBQ2hDLElBQUljLElBQUliLFVBQVUsRUFBRTtZQUNoQmMsZ0JBQWdCLDJCQUEwQyxPQUFmRCxJQUFJYixVQUFVO1FBQzdEO1FBQ0EsTUFBTSxJQUFJZSxNQUFNRDtJQUNwQjtJQUNBOzs7Ozs7O0tBT0MsR0FDRCxPQUFPRSxnQkFBZ0JDLEdBQUcsRUFBRUMsU0FBUyxFQUFFO1FBQ25DLE1BQU1DLEtBQUssSUFBSSxDQUFDUCx1QkFBdUI7UUFDdkMsT0FBTyxJQUFJTyxHQUFHRixLQUFLQztJQUN2QjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE9BQU9FLHVCQUF1QjtRQUMxQixJQUFJO1lBQ0EsTUFBTVAsTUFBTSxJQUFJLENBQUN0QixpQkFBaUI7WUFDbEMsT0FBT3NCLElBQUluQixJQUFJLEtBQUssWUFBWW1CLElBQUluQixJQUFJLEtBQUs7UUFDakQsRUFDQSxPQUFPRixJQUFJO1lBQ1AsT0FBTztRQUNYO0lBQ0o7SUF2SEE7O0tBRUMsR0FDREcsYUFBYyxDQUFFO0FBcUhwQjtBQUNBLCtEQUFlTCxnQkFBZ0JBLEVBQUMsQ0FDaEMsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3dlYnNvY2tldC1mYWN0b3J5LmpzP2E1YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGNyZWF0aW5nIFdlYlNvY2tldCBpbnN0YW5jZXMgYWNyb3NzIHJ1bnRpbWVzLlxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogU3RhdGljLW9ubHkgdXRpbGl0eSDigJMgcHJldmVudCBpbnN0YW50aWF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgc3RhdGljIGRldGVjdEVudmlyb25tZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBXZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbC5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXRQYWlyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xvdWRmbGFyZScsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDbG91ZGZsYXJlIFdvcmtlcnMgZGV0ZWN0ZWQuIFdlYlNvY2tldCBjbGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIENsb3VkZmxhcmUgV29ya2Vycy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2UgQ2xvdWRmbGFyZSBXb3JrZXJzIFdlYlNvY2tldCBBUEkgZm9yIHNlcnZlci1zaWRlIFdlYlNvY2tldCBoYW5kbGluZywgb3IgZGVwbG95IHRvIGEgZGlmZmVyZW50IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5FZGdlUnVudGltZSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdWZXJjZWwtRWRnZScpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0VkZ2UgcnVudGltZSBkZXRlY3RlZCAoVmVyY2VsIEVkZ2UvTmV0bGlmeSBFZGdlKS4gV2ViU29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBlZGdlIGZ1bmN0aW9ucy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2Ugc2VydmVybGVzcyBmdW5jdGlvbnMgb3IgYSBkaWZmZXJlbnQgZGVwbG95bWVudCB0YXJnZXQgZm9yIFdlYlNvY2tldCBmdW5jdGlvbmFsaXR5LicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICAgICAgY29uc3QgX3Byb2Nlc3MgPSBnbG9iYWxUaGlzWydwcm9jZXNzJ107XG4gICAgICAgIGlmIChfcHJvY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc1ZlcnNpb25zID0gX3Byb2Nlc3NbJ3ZlcnNpb25zJ107XG4gICAgICAgICAgICBpZiAocHJvY2Vzc1ZlcnNpb25zICYmIHByb2Nlc3NWZXJzaW9uc1snbm9kZSddKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlICd2JyBwcmVmaXggaWYgcHJlc2VudCBhbmQgcGFyc2UgdGhlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gcHJvY2Vzc1ZlcnNpb25zWydub2RlJ107XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLnJlcGxhY2UoL152LywgJycpLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMjIrIHNob3VsZCBoYXZlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVZlcnNpb24gPj0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmF0aXZlIFdlYlNvY2tldCBpcyBhdmFpbGFibGUgKHNob3VsZCBiZSBpbiBOb2RlLmpzIDIyKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYXZhaWxhYmxlLCB1c2VyIG5lZWRzIHRvIHByb3ZpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYE5vZGUuanMgJHtub2RlVmVyc2lvbn0gZGV0ZWN0ZWQgYnV0IG5hdGl2ZSBXZWJTb2NrZXQgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnUHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiB2aWEgdGhlIHRyYW5zcG9ydCBvcHRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyA8IDIyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIHdpdGhvdXQgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0LmAsXG4gICAgICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdGb3IgTm9kZS5qcyA8IDIyLCBpbnN0YWxsIFwid3NcIiBwYWNrYWdlIGFuZCBwcm92aWRlIGl0IHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7IHRyYW5zcG9ydDogd3MgfSknLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICBlcnJvcjogJ1Vua25vd24gSmF2YVNjcmlwdCBydW50aW1lIHdpdGhvdXQgV2ViU29ja2V0IHN1cHBvcnQuJyxcbiAgICAgICAgICAgIHdvcmthcm91bmQ6IFwiRW5zdXJlIHlvdSdyZSBydW5uaW5nIGluIGEgc3VwcG9ydGVkIGVudmlyb25tZW50IChicm93c2VyLCBOb2RlLmpzLCBEZW5vKSBvciBwcm92aWRlIGEgY3VzdG9tIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbi5cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBhdmFpbGFibGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIGZvciB0aGUgY3VycmVudCBydW50aW1lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IFdTID0gV2ViU29ja2V0RmFjdG9yeS5nZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpXG4gICAgICogY29uc3Qgc29ja2V0ID0gbmV3IFdTKCd3c3M6Ly9yZWFsdGltZS5zdXBhYmFzZS5jby9zb2NrZXQnKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgZW52ID0gdGhpcy5kZXRlY3RFbnZpcm9ubWVudCgpO1xuICAgICAgICBpZiAoZW52LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52LmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlbnYuZXJyb3IgfHwgJ1dlYlNvY2tldCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuJztcbiAgICAgICAgaWYgKGVudi53b3JrYXJvdW5kKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcblN1Z2dlc3RlZCBzb2x1dGlvbjogJHtlbnYud29ya2Fyb3VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgV2ViU29ja2V0IHVzaW5nIHRoZSBkZXRlY3RlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBXZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZVdlYlNvY2tldCgnd3NzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY28vc29ja2V0JylcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlV2ViU29ja2V0KHVybCwgcHJvdG9jb2xzKSB7XG4gICAgICAgIGNvbnN0IFdTID0gdGhpcy5nZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICByZXR1cm4gbmV3IFdTKHVybCwgcHJvdG9jb2xzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBydW50aW1lIGNhbiBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGlmICghV2ViU29ja2V0RmFjdG9yeS5pc1dlYlNvY2tldFN1cHBvcnRlZCgpKSB7XG4gICAgICogICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBsb25nIHBvbGxpbmcnKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZW52LnR5cGUgPT09ICduYXRpdmUnIHx8IGVudi50eXBlID09PSAnd3MnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRGYWN0b3J5IiwiZGV0ZWN0RW52aXJvbm1lbnQiLCJfYSIsIldlYlNvY2tldCIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJXZWJTb2NrZXRQYWlyIiwiZXJyb3IiLCJ3b3JrYXJvdW5kIiwiRWRnZVJ1bnRpbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsIl9wcm9jZXNzIiwicHJvY2Vzc1ZlcnNpb25zIiwidmVyc2lvblN0cmluZyIsIm5vZGVWZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwic3BsaXQiLCJnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvciIsImVudiIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwiY3JlYXRlV2ViU29ja2V0IiwidXJsIiwicHJvdG9jb2xzIiwiV1MiLCJpc1dlYlNvY2tldFN1cHBvcnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/user.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ User; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.312.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst User = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"User\", [\n    [\n        \"path\",\n        {\n            d: \"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2\",\n            key: \"975kel\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"7\",\n            r: \"4\",\n            key: \"17ys0d\"\n        }\n    ]\n]);\n //# sourceMappingURL=user.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdXNlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLE9BQU9ELGdFQUFnQkEsQ0FBQyxRQUFRO0lBQ3BDO1FBQUM7UUFBUTtZQUFFRSxHQUFHO1lBQTZDQyxLQUFLO1FBQVM7S0FBRTtJQUMzRTtRQUFDO1FBQVU7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQUtDLEdBQUc7WUFBS0gsS0FBSztRQUFTO0tBQUU7Q0FDekQ7QUFFMEIsQ0FDM0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdXNlci5qcz82NjMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjMxMi4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgVXNlciA9IGNyZWF0ZUx1Y2lkZUljb24oXCJVc2VyXCIsIFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE5IDIxdi0yYTQgNCAwIDAgMC00LTRIOWE0IDQgMCAwIDAtNCA0djJcIiwga2V5OiBcIjk3NWtlbFwiIH1dLFxuICBbXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCI3XCIsIHI6IFwiNFwiLCBrZXk6IFwiMTd5czBkXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBVc2VyIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZXIuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIlVzZXIiLCJkIiwia2V5IiwiY3giLCJjeSIsInIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        675: function(e, r) {\n            \"use strict\";\n            r.byteLength = byteLength;\n            r.toByteArray = toByteArray;\n            r.fromByteArray = fromByteArray;\n            var t = [];\n            var f = [];\n            var n = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n            var i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            for(var o = 0, u = i.length; o < u; ++o){\n                t[o] = i[o];\n                f[i.charCodeAt(o)] = o;\n            }\n            f[\"-\".charCodeAt(0)] = 62;\n            f[\"_\".charCodeAt(0)] = 63;\n            function getLens(e) {\n                var r = e.length;\n                if (r % 4 > 0) {\n                    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n                }\n                var t = e.indexOf(\"=\");\n                if (t === -1) t = r;\n                var f = t === r ? 0 : 4 - t % 4;\n                return [\n                    t,\n                    f\n                ];\n            }\n            function byteLength(e) {\n                var r = getLens(e);\n                var t = r[0];\n                var f = r[1];\n                return (t + f) * 3 / 4 - f;\n            }\n            function _byteLength(e, r, t) {\n                return (r + t) * 3 / 4 - t;\n            }\n            function toByteArray(e) {\n                var r;\n                var t = getLens(e);\n                var i = t[0];\n                var o = t[1];\n                var u = new n(_byteLength(e, i, o));\n                var a = 0;\n                var s = o > 0 ? i - 4 : i;\n                var h;\n                for(h = 0; h < s; h += 4){\n                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];\n                    u[a++] = r >> 16 & 255;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                if (o === 2) {\n                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;\n                    u[a++] = r & 255;\n                }\n                if (o === 1) {\n                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                return u;\n            }\n            function tripletToBase64(e) {\n                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];\n            }\n            function encodeChunk(e, r, t) {\n                var f;\n                var n = [];\n                for(var i = r; i < t; i += 3){\n                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);\n                    n.push(tripletToBase64(f));\n                }\n                return n.join(\"\");\n            }\n            function fromByteArray(e) {\n                var r;\n                var f = e.length;\n                var n = f % 3;\n                var i = [];\n                var o = 16383;\n                for(var u = 0, a = f - n; u < a; u += o){\n                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));\n                }\n                if (n === 1) {\n                    r = e[f - 1];\n                    i.push(t[r >> 2] + t[r << 4 & 63] + \"==\");\n                } else if (n === 2) {\n                    r = (e[f - 2] << 8) + e[f - 1];\n                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + \"=\");\n                }\n                return i.join(\"\");\n            }\n        },\n        72: function(e, r, t) {\n            \"use strict\";\n            /*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ var f = t(675);\n            var n = t(783);\n            var i = typeof Symbol === \"function\" && typeof Symbol.for === \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n            r.Buffer = Buffer;\n            r.SlowBuffer = SlowBuffer;\n            r.INSPECT_MAX_BYTES = 50;\n            var o = 2147483647;\n            r.kMaxLength = o;\n            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n            }\n            function typedArraySupport() {\n                try {\n                    var e = new Uint8Array(1);\n                    var r = {\n                        foo: function() {\n                            return 42;\n                        }\n                    };\n                    Object.setPrototypeOf(r, Uint8Array.prototype);\n                    Object.setPrototypeOf(e, r);\n                    return e.foo() === 42;\n                } catch (e) {\n                    return false;\n                }\n            }\n            Object.defineProperty(Buffer.prototype, \"parent\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.buffer;\n                }\n            });\n            Object.defineProperty(Buffer.prototype, \"offset\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.byteOffset;\n                }\n            });\n            function createBuffer(e) {\n                if (e > o) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n                var r = new Uint8Array(e);\n                Object.setPrototypeOf(r, Buffer.prototype);\n                return r;\n            }\n            function Buffer(e, r, t) {\n                if (typeof e === \"number\") {\n                    if (typeof r === \"string\") {\n                        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n                    }\n                    return allocUnsafe(e);\n                }\n                return from(e, r, t);\n            }\n            Buffer.poolSize = 8192;\n            function from(e, r, t) {\n                if (typeof e === \"string\") {\n                    return fromString(e, r);\n                }\n                if (ArrayBuffer.isView(e)) {\n                    return fromArrayLike(e);\n                }\n                if (e == null) {\n                    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n                }\n                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof e === \"number\") {\n                    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n                }\n                var f = e.valueOf && e.valueOf();\n                if (f != null && f !== e) {\n                    return Buffer.from(f, r, t);\n                }\n                var n = fromObject(e);\n                if (n) return n;\n                if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === \"function\") {\n                    return Buffer.from(e[Symbol.toPrimitive](\"string\"), r, t);\n                }\n                throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n            }\n            Buffer.from = function(e, r, t) {\n                return from(e, r, t);\n            };\n            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n            Object.setPrototypeOf(Buffer, Uint8Array);\n            function assertSize(e) {\n                if (typeof e !== \"number\") {\n                    throw new TypeError('\"size\" argument must be of type number');\n                } else if (e < 0) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n            }\n            function alloc(e, r, t) {\n                assertSize(e);\n                if (e <= 0) {\n                    return createBuffer(e);\n                }\n                if (r !== undefined) {\n                    return typeof t === \"string\" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);\n                }\n                return createBuffer(e);\n            }\n            Buffer.alloc = function(e, r, t) {\n                return alloc(e, r, t);\n            };\n            function allocUnsafe(e) {\n                assertSize(e);\n                return createBuffer(e < 0 ? 0 : checked(e) | 0);\n            }\n            Buffer.allocUnsafe = function(e) {\n                return allocUnsafe(e);\n            };\n            Buffer.allocUnsafeSlow = function(e) {\n                return allocUnsafe(e);\n            };\n            function fromString(e, r) {\n                if (typeof r !== \"string\" || r === \"\") {\n                    r = \"utf8\";\n                }\n                if (!Buffer.isEncoding(r)) {\n                    throw new TypeError(\"Unknown encoding: \" + r);\n                }\n                var t = byteLength(e, r) | 0;\n                var f = createBuffer(t);\n                var n = f.write(e, r);\n                if (n !== t) {\n                    f = f.slice(0, n);\n                }\n                return f;\n            }\n            function fromArrayLike(e) {\n                var r = e.length < 0 ? 0 : checked(e.length) | 0;\n                var t = createBuffer(r);\n                for(var f = 0; f < r; f += 1){\n                    t[f] = e[f] & 255;\n                }\n                return t;\n            }\n            function fromArrayBuffer(e, r, t) {\n                if (r < 0 || e.byteLength < r) {\n                    throw new RangeError('\"offset\" is outside of buffer bounds');\n                }\n                if (e.byteLength < r + (t || 0)) {\n                    throw new RangeError('\"length\" is outside of buffer bounds');\n                }\n                var f;\n                if (r === undefined && t === undefined) {\n                    f = new Uint8Array(e);\n                } else if (t === undefined) {\n                    f = new Uint8Array(e, r);\n                } else {\n                    f = new Uint8Array(e, r, t);\n                }\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            }\n            function fromObject(e) {\n                if (Buffer.isBuffer(e)) {\n                    var r = checked(e.length) | 0;\n                    var t = createBuffer(r);\n                    if (t.length === 0) {\n                        return t;\n                    }\n                    e.copy(t, 0, 0, r);\n                    return t;\n                }\n                if (e.length !== undefined) {\n                    if (typeof e.length !== \"number\" || numberIsNaN(e.length)) {\n                        return createBuffer(0);\n                    }\n                    return fromArrayLike(e);\n                }\n                if (e.type === \"Buffer\" && Array.isArray(e.data)) {\n                    return fromArrayLike(e.data);\n                }\n            }\n            function checked(e) {\n                if (e >= o) {\n                    throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + o.toString(16) + \" bytes\");\n                }\n                return e | 0;\n            }\n            function SlowBuffer(e) {\n                if (+e != e) {\n                    e = 0;\n                }\n                return Buffer.alloc(+e);\n            }\n            Buffer.isBuffer = function isBuffer(e) {\n                return e != null && e._isBuffer === true && e !== Buffer.prototype;\n            };\n            Buffer.compare = function compare(e, r) {\n                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);\n                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);\n                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {\n                    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n                }\n                if (e === r) return 0;\n                var t = e.length;\n                var f = r.length;\n                for(var n = 0, i = Math.min(t, f); n < i; ++n){\n                    if (e[n] !== r[n]) {\n                        t = e[n];\n                        f = r[n];\n                        break;\n                    }\n                }\n                if (t < f) return -1;\n                if (f < t) return 1;\n                return 0;\n            };\n            Buffer.isEncoding = function isEncoding(e) {\n                switch(String(e).toLowerCase()){\n                    case \"hex\":\n                    case \"utf8\":\n                    case \"utf-8\":\n                    case \"ascii\":\n                    case \"latin1\":\n                    case \"binary\":\n                    case \"base64\":\n                    case \"ucs2\":\n                    case \"ucs-2\":\n                    case \"utf16le\":\n                    case \"utf-16le\":\n                        return true;\n                    default:\n                        return false;\n                }\n            };\n            Buffer.concat = function concat(e, r) {\n                if (!Array.isArray(e)) {\n                    throw new TypeError('\"list\" argument must be an Array of Buffers');\n                }\n                if (e.length === 0) {\n                    return Buffer.alloc(0);\n                }\n                var t;\n                if (r === undefined) {\n                    r = 0;\n                    for(t = 0; t < e.length; ++t){\n                        r += e[t].length;\n                    }\n                }\n                var f = Buffer.allocUnsafe(r);\n                var n = 0;\n                for(t = 0; t < e.length; ++t){\n                    var i = e[t];\n                    if (isInstance(i, Uint8Array)) {\n                        i = Buffer.from(i);\n                    }\n                    if (!Buffer.isBuffer(i)) {\n                        throw new TypeError('\"list\" argument must be an Array of Buffers');\n                    }\n                    i.copy(f, n);\n                    n += i.length;\n                }\n                return f;\n            };\n            function byteLength(e, r) {\n                if (Buffer.isBuffer(e)) {\n                    return e.length;\n                }\n                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {\n                    return e.byteLength;\n                }\n                if (typeof e !== \"string\") {\n                    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof e);\n                }\n                var t = e.length;\n                var f = arguments.length > 2 && arguments[2] === true;\n                if (!f && t === 0) return 0;\n                var n = false;\n                for(;;){\n                    switch(r){\n                        case \"ascii\":\n                        case \"latin1\":\n                        case \"binary\":\n                            return t;\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8ToBytes(e).length;\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return t * 2;\n                        case \"hex\":\n                            return t >>> 1;\n                        case \"base64\":\n                            return base64ToBytes(e).length;\n                        default:\n                            if (n) {\n                                return f ? -1 : utf8ToBytes(e).length;\n                            }\n                            r = (\"\" + r).toLowerCase();\n                            n = true;\n                    }\n                }\n            }\n            Buffer.byteLength = byteLength;\n            function slowToString(e, r, t) {\n                var f = false;\n                if (r === undefined || r < 0) {\n                    r = 0;\n                }\n                if (r > this.length) {\n                    return \"\";\n                }\n                if (t === undefined || t > this.length) {\n                    t = this.length;\n                }\n                if (t <= 0) {\n                    return \"\";\n                }\n                t >>>= 0;\n                r >>>= 0;\n                if (t <= r) {\n                    return \"\";\n                }\n                if (!e) e = \"utf8\";\n                while(true){\n                    switch(e){\n                        case \"hex\":\n                            return hexSlice(this, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Slice(this, r, t);\n                        case \"ascii\":\n                            return asciiSlice(this, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Slice(this, r, t);\n                        case \"base64\":\n                            return base64Slice(this, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return utf16leSlice(this, r, t);\n                        default:\n                            if (f) throw new TypeError(\"Unknown encoding: \" + e);\n                            e = (e + \"\").toLowerCase();\n                            f = true;\n                    }\n                }\n            }\n            Buffer.prototype._isBuffer = true;\n            function swap(e, r, t) {\n                var f = e[r];\n                e[r] = e[t];\n                e[t] = f;\n            }\n            Buffer.prototype.swap16 = function swap16() {\n                var e = this.length;\n                if (e % 2 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n                }\n                for(var r = 0; r < e; r += 2){\n                    swap(this, r, r + 1);\n                }\n                return this;\n            };\n            Buffer.prototype.swap32 = function swap32() {\n                var e = this.length;\n                if (e % 4 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n                }\n                for(var r = 0; r < e; r += 4){\n                    swap(this, r, r + 3);\n                    swap(this, r + 1, r + 2);\n                }\n                return this;\n            };\n            Buffer.prototype.swap64 = function swap64() {\n                var e = this.length;\n                if (e % 8 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n                }\n                for(var r = 0; r < e; r += 8){\n                    swap(this, r, r + 7);\n                    swap(this, r + 1, r + 6);\n                    swap(this, r + 2, r + 5);\n                    swap(this, r + 3, r + 4);\n                }\n                return this;\n            };\n            Buffer.prototype.toString = function toString() {\n                var e = this.length;\n                if (e === 0) return \"\";\n                if (arguments.length === 0) return utf8Slice(this, 0, e);\n                return slowToString.apply(this, arguments);\n            };\n            Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n            Buffer.prototype.equals = function equals(e) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n                if (this === e) return true;\n                return Buffer.compare(this, e) === 0;\n            };\n            Buffer.prototype.inspect = function inspect() {\n                var e = \"\";\n                var t = r.INSPECT_MAX_BYTES;\n                e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim();\n                if (this.length > t) e += \" ... \";\n                return \"<Buffer \" + e + \">\";\n            };\n            if (i) {\n                Buffer.prototype[i] = Buffer.prototype.inspect;\n            }\n            Buffer.prototype.compare = function compare(e, r, t, f, n) {\n                if (isInstance(e, Uint8Array)) {\n                    e = Buffer.from(e, e.offset, e.byteLength);\n                }\n                if (!Buffer.isBuffer(e)) {\n                    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof e);\n                }\n                if (r === undefined) {\n                    r = 0;\n                }\n                if (t === undefined) {\n                    t = e ? e.length : 0;\n                }\n                if (f === undefined) {\n                    f = 0;\n                }\n                if (n === undefined) {\n                    n = this.length;\n                }\n                if (r < 0 || t > e.length || f < 0 || n > this.length) {\n                    throw new RangeError(\"out of range index\");\n                }\n                if (f >= n && r >= t) {\n                    return 0;\n                }\n                if (f >= n) {\n                    return -1;\n                }\n                if (r >= t) {\n                    return 1;\n                }\n                r >>>= 0;\n                t >>>= 0;\n                f >>>= 0;\n                n >>>= 0;\n                if (this === e) return 0;\n                var i = n - f;\n                var o = t - r;\n                var u = Math.min(i, o);\n                var a = this.slice(f, n);\n                var s = e.slice(r, t);\n                for(var h = 0; h < u; ++h){\n                    if (a[h] !== s[h]) {\n                        i = a[h];\n                        o = s[h];\n                        break;\n                    }\n                }\n                if (i < o) return -1;\n                if (o < i) return 1;\n                return 0;\n            };\n            function bidirectionalIndexOf(e, r, t, f, n) {\n                if (e.length === 0) return -1;\n                if (typeof t === \"string\") {\n                    f = t;\n                    t = 0;\n                } else if (t > 2147483647) {\n                    t = 2147483647;\n                } else if (t < -2147483648) {\n                    t = -2147483648;\n                }\n                t = +t;\n                if (numberIsNaN(t)) {\n                    t = n ? 0 : e.length - 1;\n                }\n                if (t < 0) t = e.length + t;\n                if (t >= e.length) {\n                    if (n) return -1;\n                    else t = e.length - 1;\n                } else if (t < 0) {\n                    if (n) t = 0;\n                    else return -1;\n                }\n                if (typeof r === \"string\") {\n                    r = Buffer.from(r, f);\n                }\n                if (Buffer.isBuffer(r)) {\n                    if (r.length === 0) {\n                        return -1;\n                    }\n                    return arrayIndexOf(e, r, t, f, n);\n                } else if (typeof r === \"number\") {\n                    r = r & 255;\n                    if (typeof Uint8Array.prototype.indexOf === \"function\") {\n                        if (n) {\n                            return Uint8Array.prototype.indexOf.call(e, r, t);\n                        } else {\n                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);\n                        }\n                    }\n                    return arrayIndexOf(e, [\n                        r\n                    ], t, f, n);\n                }\n                throw new TypeError(\"val must be string, number or Buffer\");\n            }\n            function arrayIndexOf(e, r, t, f, n) {\n                var i = 1;\n                var o = e.length;\n                var u = r.length;\n                if (f !== undefined) {\n                    f = String(f).toLowerCase();\n                    if (f === \"ucs2\" || f === \"ucs-2\" || f === \"utf16le\" || f === \"utf-16le\") {\n                        if (e.length < 2 || r.length < 2) {\n                            return -1;\n                        }\n                        i = 2;\n                        o /= 2;\n                        u /= 2;\n                        t /= 2;\n                    }\n                }\n                function read(e, r) {\n                    if (i === 1) {\n                        return e[r];\n                    } else {\n                        return e.readUInt16BE(r * i);\n                    }\n                }\n                var a;\n                if (n) {\n                    var s = -1;\n                    for(a = t; a < o; a++){\n                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {\n                            if (s === -1) s = a;\n                            if (a - s + 1 === u) return s * i;\n                        } else {\n                            if (s !== -1) a -= a - s;\n                            s = -1;\n                        }\n                    }\n                } else {\n                    if (t + u > o) t = o - u;\n                    for(a = t; a >= 0; a--){\n                        var h = true;\n                        for(var c = 0; c < u; c++){\n                            if (read(e, a + c) !== read(r, c)) {\n                                h = false;\n                                break;\n                            }\n                        }\n                        if (h) return a;\n                    }\n                }\n                return -1;\n            }\n            Buffer.prototype.includes = function includes(e, r, t) {\n                return this.indexOf(e, r, t) !== -1;\n            };\n            Buffer.prototype.indexOf = function indexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, true);\n            };\n            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, false);\n            };\n            function hexWrite(e, r, t, f) {\n                t = Number(t) || 0;\n                var n = e.length - t;\n                if (!f) {\n                    f = n;\n                } else {\n                    f = Number(f);\n                    if (f > n) {\n                        f = n;\n                    }\n                }\n                var i = r.length;\n                if (f > i / 2) {\n                    f = i / 2;\n                }\n                for(var o = 0; o < f; ++o){\n                    var u = parseInt(r.substr(o * 2, 2), 16);\n                    if (numberIsNaN(u)) return o;\n                    e[t + o] = u;\n                }\n                return o;\n            }\n            function utf8Write(e, r, t, f) {\n                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);\n            }\n            function asciiWrite(e, r, t, f) {\n                return blitBuffer(asciiToBytes(r), e, t, f);\n            }\n            function latin1Write(e, r, t, f) {\n                return asciiWrite(e, r, t, f);\n            }\n            function base64Write(e, r, t, f) {\n                return blitBuffer(base64ToBytes(r), e, t, f);\n            }\n            function ucs2Write(e, r, t, f) {\n                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);\n            }\n            Buffer.prototype.write = function write(e, r, t, f) {\n                if (r === undefined) {\n                    f = \"utf8\";\n                    t = this.length;\n                    r = 0;\n                } else if (t === undefined && typeof r === \"string\") {\n                    f = r;\n                    t = this.length;\n                    r = 0;\n                } else if (isFinite(r)) {\n                    r = r >>> 0;\n                    if (isFinite(t)) {\n                        t = t >>> 0;\n                        if (f === undefined) f = \"utf8\";\n                    } else {\n                        f = t;\n                        t = undefined;\n                    }\n                } else {\n                    throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n                }\n                var n = this.length - r;\n                if (t === undefined || t > n) t = n;\n                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {\n                    throw new RangeError(\"Attempt to write outside buffer bounds\");\n                }\n                if (!f) f = \"utf8\";\n                var i = false;\n                for(;;){\n                    switch(f){\n                        case \"hex\":\n                            return hexWrite(this, e, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Write(this, e, r, t);\n                        case \"ascii\":\n                            return asciiWrite(this, e, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Write(this, e, r, t);\n                        case \"base64\":\n                            return base64Write(this, e, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return ucs2Write(this, e, r, t);\n                        default:\n                            if (i) throw new TypeError(\"Unknown encoding: \" + f);\n                            f = (\"\" + f).toLowerCase();\n                            i = true;\n                    }\n                }\n            };\n            Buffer.prototype.toJSON = function toJSON() {\n                return {\n                    type: \"Buffer\",\n                    data: Array.prototype.slice.call(this._arr || this, 0)\n                };\n            };\n            function base64Slice(e, r, t) {\n                if (r === 0 && t === e.length) {\n                    return f.fromByteArray(e);\n                } else {\n                    return f.fromByteArray(e.slice(r, t));\n                }\n            }\n            function utf8Slice(e, r, t) {\n                t = Math.min(e.length, t);\n                var f = [];\n                var n = r;\n                while(n < t){\n                    var i = e[n];\n                    var o = null;\n                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;\n                    if (n + u <= t) {\n                        var a, s, h, c;\n                        switch(u){\n                            case 1:\n                                if (i < 128) {\n                                    o = i;\n                                }\n                                break;\n                            case 2:\n                                a = e[n + 1];\n                                if ((a & 192) === 128) {\n                                    c = (i & 31) << 6 | a & 63;\n                                    if (c > 127) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 3:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                if ((a & 192) === 128 && (s & 192) === 128) {\n                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;\n                                    if (c > 2047 && (c < 55296 || c > 57343)) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 4:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                h = e[n + 3];\n                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {\n                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;\n                                    if (c > 65535 && c < 1114112) {\n                                        o = c;\n                                    }\n                                }\n                        }\n                    }\n                    if (o === null) {\n                        o = 65533;\n                        u = 1;\n                    } else if (o > 65535) {\n                        o -= 65536;\n                        f.push(o >>> 10 & 1023 | 55296);\n                        o = 56320 | o & 1023;\n                    }\n                    f.push(o);\n                    n += u;\n                }\n                return decodeCodePointsArray(f);\n            }\n            var u = 4096;\n            function decodeCodePointsArray(e) {\n                var r = e.length;\n                if (r <= u) {\n                    return String.fromCharCode.apply(String, e);\n                }\n                var t = \"\";\n                var f = 0;\n                while(f < r){\n                    t += String.fromCharCode.apply(String, e.slice(f, f += u));\n                }\n                return t;\n            }\n            function asciiSlice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n] & 127);\n                }\n                return f;\n            }\n            function latin1Slice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n]);\n                }\n                return f;\n            }\n            function hexSlice(e, r, t) {\n                var f = e.length;\n                if (!r || r < 0) r = 0;\n                if (!t || t < 0 || t > f) t = f;\n                var n = \"\";\n                for(var i = r; i < t; ++i){\n                    n += s[e[i]];\n                }\n                return n;\n            }\n            function utf16leSlice(e, r, t) {\n                var f = e.slice(r, t);\n                var n = \"\";\n                for(var i = 0; i < f.length; i += 2){\n                    n += String.fromCharCode(f[i] + f[i + 1] * 256);\n                }\n                return n;\n            }\n            Buffer.prototype.slice = function slice(e, r) {\n                var t = this.length;\n                e = ~~e;\n                r = r === undefined ? t : ~~r;\n                if (e < 0) {\n                    e += t;\n                    if (e < 0) e = 0;\n                } else if (e > t) {\n                    e = t;\n                }\n                if (r < 0) {\n                    r += t;\n                    if (r < 0) r = 0;\n                } else if (r > t) {\n                    r = t;\n                }\n                if (r < e) r = e;\n                var f = this.subarray(e, r);\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            };\n            function checkOffset(e, r, t) {\n                if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n                if (e + r > t) throw new RangeError(\"Trying to access beyond buffer length\");\n            }\n            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) {\n                    checkOffset(e, r, this.length);\n                }\n                var f = this[e + --r];\n                var n = 1;\n                while(r > 0 && (n *= 256)){\n                    f += this[e + --r] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUInt8 = function readUInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                return this[e];\n            };\n            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] | this[e + 1] << 8;\n            };\n            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] << 8 | this[e + 1];\n            };\n            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;\n            };\n            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n            };\n            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                n *= 128;\n                if (f >= n) f -= Math.pow(2, 8 * r);\n                return f;\n            };\n            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = r;\n                var n = 1;\n                var i = this[e + --f];\n                while(f > 0 && (n *= 256)){\n                    i += this[e + --f] * n;\n                }\n                n *= 128;\n                if (i >= n) i -= Math.pow(2, 8 * r);\n                return i;\n            };\n            Buffer.prototype.readInt8 = function readInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                if (!(this[e] & 128)) return this[e];\n                return (255 - this[e] + 1) * -1;\n            };\n            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e] | this[e + 1] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e + 1] | this[e] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n            };\n            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n            };\n            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, true, 23, 4);\n            };\n            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, false, 23, 4);\n            };\n            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, true, 52, 8);\n            };\n            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, false, 52, 8);\n            };\n            function checkInt(e, r, t, f, n, i) {\n                if (!Buffer.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n                if (r > n || r < i) throw new RangeError('\"value\" argument is out of bounds');\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n            }\n            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = 1;\n                var o = 0;\n                this[r] = e & 255;\n                while(++o < t && (i *= 256)){\n                    this[r + o] = e / i & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = t - 1;\n                var o = 1;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    this[r + i] = e / o & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 255, 0);\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r + 3] = e >>> 24;\n                this[r + 2] = e >>> 16;\n                this[r + 1] = e >>> 8;\n                this[r] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = 0;\n                var o = 1;\n                var u = 0;\n                this[r] = e & 255;\n                while(++i < t && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = t - 1;\n                var o = 1;\n                var u = 0;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 127, -128);\n                if (e < 0) e = 255 + e + 1;\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                this[r + 2] = e >>> 16;\n                this[r + 3] = e >>> 24;\n                return r + 4;\n            };\n            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                if (e < 0) e = 4294967295 + e + 1;\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            function checkIEEE754(e, r, t, f, n, i) {\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n                if (t < 0) throw new RangeError(\"Index out of range\");\n            }\n            function writeFloat(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);\n                }\n                n.write(e, r, t, f, 23, 4);\n                return t + 4;\n            }\n            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {\n                return writeFloat(this, e, r, true, t);\n            };\n            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {\n                return writeFloat(this, e, r, false, t);\n            };\n            function writeDouble(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);\n                }\n                n.write(e, r, t, f, 52, 8);\n                return t + 8;\n            }\n            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {\n                return writeDouble(this, e, r, true, t);\n            };\n            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {\n                return writeDouble(this, e, r, false, t);\n            };\n            Buffer.prototype.copy = function copy(e, r, t, f) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n                if (!t) t = 0;\n                if (!f && f !== 0) f = this.length;\n                if (r >= e.length) r = e.length;\n                if (!r) r = 0;\n                if (f > 0 && f < t) f = t;\n                if (f === t) return 0;\n                if (e.length === 0 || this.length === 0) return 0;\n                if (r < 0) {\n                    throw new RangeError(\"targetStart out of bounds\");\n                }\n                if (t < 0 || t >= this.length) throw new RangeError(\"Index out of range\");\n                if (f < 0) throw new RangeError(\"sourceEnd out of bounds\");\n                if (f > this.length) f = this.length;\n                if (e.length - r < f - t) {\n                    f = e.length - r + t;\n                }\n                var n = f - t;\n                if (this === e && typeof Uint8Array.prototype.copyWithin === \"function\") {\n                    this.copyWithin(r, t, f);\n                } else if (this === e && t < r && r < f) {\n                    for(var i = n - 1; i >= 0; --i){\n                        e[i + r] = this[i + t];\n                    }\n                } else {\n                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);\n                }\n                return n;\n            };\n            Buffer.prototype.fill = function fill(e, r, t, f) {\n                if (typeof e === \"string\") {\n                    if (typeof r === \"string\") {\n                        f = r;\n                        r = 0;\n                        t = this.length;\n                    } else if (typeof t === \"string\") {\n                        f = t;\n                        t = this.length;\n                    }\n                    if (f !== undefined && typeof f !== \"string\") {\n                        throw new TypeError(\"encoding must be a string\");\n                    }\n                    if (typeof f === \"string\" && !Buffer.isEncoding(f)) {\n                        throw new TypeError(\"Unknown encoding: \" + f);\n                    }\n                    if (e.length === 1) {\n                        var n = e.charCodeAt(0);\n                        if (f === \"utf8\" && n < 128 || f === \"latin1\") {\n                            e = n;\n                        }\n                    }\n                } else if (typeof e === \"number\") {\n                    e = e & 255;\n                } else if (typeof e === \"boolean\") {\n                    e = Number(e);\n                }\n                if (r < 0 || this.length < r || this.length < t) {\n                    throw new RangeError(\"Out of range index\");\n                }\n                if (t <= r) {\n                    return this;\n                }\n                r = r >>> 0;\n                t = t === undefined ? this.length : t >>> 0;\n                if (!e) e = 0;\n                var i;\n                if (typeof e === \"number\") {\n                    for(i = r; i < t; ++i){\n                        this[i] = e;\n                    }\n                } else {\n                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);\n                    var u = o.length;\n                    if (u === 0) {\n                        throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n                    }\n                    for(i = 0; i < t - r; ++i){\n                        this[i + r] = o[i % u];\n                    }\n                }\n                return this;\n            };\n            var a = /[^+/0-9A-Za-z-_]/g;\n            function base64clean(e) {\n                e = e.split(\"=\")[0];\n                e = e.trim().replace(a, \"\");\n                if (e.length < 2) return \"\";\n                while(e.length % 4 !== 0){\n                    e = e + \"=\";\n                }\n                return e;\n            }\n            function utf8ToBytes(e, r) {\n                r = r || Infinity;\n                var t;\n                var f = e.length;\n                var n = null;\n                var i = [];\n                for(var o = 0; o < f; ++o){\n                    t = e.charCodeAt(o);\n                    if (t > 55295 && t < 57344) {\n                        if (!n) {\n                            if (t > 56319) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            } else if (o + 1 === f) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            }\n                            n = t;\n                            continue;\n                        }\n                        if (t < 56320) {\n                            if ((r -= 3) > -1) i.push(239, 191, 189);\n                            n = t;\n                            continue;\n                        }\n                        t = (n - 55296 << 10 | t - 56320) + 65536;\n                    } else if (n) {\n                        if ((r -= 3) > -1) i.push(239, 191, 189);\n                    }\n                    n = null;\n                    if (t < 128) {\n                        if ((r -= 1) < 0) break;\n                        i.push(t);\n                    } else if (t < 2048) {\n                        if ((r -= 2) < 0) break;\n                        i.push(t >> 6 | 192, t & 63 | 128);\n                    } else if (t < 65536) {\n                        if ((r -= 3) < 0) break;\n                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else if (t < 1114112) {\n                        if ((r -= 4) < 0) break;\n                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else {\n                        throw new Error(\"Invalid code point\");\n                    }\n                }\n                return i;\n            }\n            function asciiToBytes(e) {\n                var r = [];\n                for(var t = 0; t < e.length; ++t){\n                    r.push(e.charCodeAt(t) & 255);\n                }\n                return r;\n            }\n            function utf16leToBytes(e, r) {\n                var t, f, n;\n                var i = [];\n                for(var o = 0; o < e.length; ++o){\n                    if ((r -= 2) < 0) break;\n                    t = e.charCodeAt(o);\n                    f = t >> 8;\n                    n = t % 256;\n                    i.push(n);\n                    i.push(f);\n                }\n                return i;\n            }\n            function base64ToBytes(e) {\n                return f.toByteArray(base64clean(e));\n            }\n            function blitBuffer(e, r, t, f) {\n                for(var n = 0; n < f; ++n){\n                    if (n + t >= r.length || n >= e.length) break;\n                    r[n + t] = e[n];\n                }\n                return n;\n            }\n            function isInstance(e, r) {\n                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;\n            }\n            function numberIsNaN(e) {\n                return e !== e;\n            }\n            var s = function() {\n                var e = \"0123456789abcdef\";\n                var r = new Array(256);\n                for(var t = 0; t < 16; ++t){\n                    var f = t * 16;\n                    for(var n = 0; n < 16; ++n){\n                        r[f + n] = e[t] + e[n];\n                    }\n                }\n                return r;\n            }();\n        },\n        783: function(e, r) {\n            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {\n                var i, o;\n                var u = n * 8 - f - 1;\n                var a = (1 << u) - 1;\n                var s = a >> 1;\n                var h = -7;\n                var c = t ? n - 1 : 0;\n                var l = t ? -1 : 1;\n                var p = e[r + c];\n                c += l;\n                i = p & (1 << -h) - 1;\n                p >>= -h;\n                h += u;\n                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}\n                o = i & (1 << -h) - 1;\n                i >>= -h;\n                h += f;\n                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}\n                if (i === 0) {\n                    i = 1 - s;\n                } else if (i === a) {\n                    return o ? NaN : (p ? -1 : 1) * Infinity;\n                } else {\n                    o = o + Math.pow(2, f);\n                    i = i - s;\n                }\n                return (p ? -1 : 1) * o * Math.pow(2, i - f);\n            };\n            r.write = function(e, r, t, f, n, i) {\n                var o, u, a;\n                var s = i * 8 - n - 1;\n                var h = (1 << s) - 1;\n                var c = h >> 1;\n                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n                var p = f ? 0 : i - 1;\n                var y = f ? 1 : -1;\n                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;\n                r = Math.abs(r);\n                if (isNaN(r) || r === Infinity) {\n                    u = isNaN(r) ? 1 : 0;\n                    o = h;\n                } else {\n                    o = Math.floor(Math.log(r) / Math.LN2);\n                    if (r * (a = Math.pow(2, -o)) < 1) {\n                        o--;\n                        a *= 2;\n                    }\n                    if (o + c >= 1) {\n                        r += l / a;\n                    } else {\n                        r += l * Math.pow(2, 1 - c);\n                    }\n                    if (r * a >= 2) {\n                        o++;\n                        a /= 2;\n                    }\n                    if (o + c >= h) {\n                        u = 0;\n                        o = h;\n                    } else if (o + c >= 1) {\n                        u = (r * a - 1) * Math.pow(2, n);\n                        o = o + c;\n                    } else {\n                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);\n                        o = 0;\n                    }\n                }\n                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}\n                o = o << n | u;\n                s += n;\n                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}\n                e[t + p - y] |= g * 128;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var f = r[t];\n        if (f !== undefined) {\n            return f.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(72);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDLEVBQUNDLENBQUM7WUFBRTtZQUFhQSxFQUFFQyxVQUFVLEdBQUNBO1lBQVdELEVBQUVFLFdBQVcsR0FBQ0E7WUFBWUYsRUFBRUcsYUFBYSxHQUFDQTtZQUFjLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsT0FBT0MsZUFBYSxjQUFZQSxhQUFXQztZQUFNLElBQUlDLElBQUU7WUFBbUUsSUFBSSxJQUFJQyxJQUFFLEdBQUVDLElBQUVGLEVBQUVHLE1BQU0sRUFBQ0YsSUFBRUMsR0FBRSxFQUFFRCxFQUFFO2dCQUFDTixDQUFDLENBQUNNLEVBQUUsR0FBQ0QsQ0FBQyxDQUFDQyxFQUFFO2dCQUFDTCxDQUFDLENBQUNJLEVBQUVJLFVBQVUsQ0FBQ0gsR0FBRyxHQUFDQTtZQUFDO1lBQUNMLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUdSLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUcsU0FBU0MsUUFBUWYsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRCxFQUFFYSxNQUFNO2dCQUFDLElBQUdaLElBQUUsSUFBRSxHQUFFO29CQUFDLE1BQU0sSUFBSWUsTUFBTTtnQkFBaUQ7Z0JBQUMsSUFBSVgsSUFBRUwsRUFBRWlCLE9BQU8sQ0FBQztnQkFBSyxJQUFHWixNQUFJLENBQUMsR0FBRUEsSUFBRUo7Z0JBQUUsSUFBSUssSUFBRUQsTUFBSUosSUFBRSxJQUFFLElBQUVJLElBQUU7Z0JBQUUsT0FBTTtvQkFBQ0E7b0JBQUVDO2lCQUFFO1lBQUE7WUFBQyxTQUFTSixXQUFXRixDQUFDO2dCQUFFLElBQUlDLElBQUVjLFFBQVFmO2dCQUFHLElBQUlLLElB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O0lBQUM7SUFBRSxJQUFJdEwsSUFBRSxDQUFDO0lBQUUsU0FBUzRMLG9CQUFvQnhMLENBQUM7UUFBRSxJQUFJQyxJQUFFTCxDQUFDLENBQUNJLEVBQUU7UUFBQyxJQUFHQyxNQUFJc0MsV0FBVTtZQUFDLE9BQU90QyxFQUFFd0wsT0FBTztRQUFBO1FBQUMsSUFBSXZMLElBQUVOLENBQUMsQ0FBQ0ksRUFBRSxHQUFDO1lBQUN5TCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlwTCxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNLLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXVMLE9BQU8sRUFBQ0Q7WUFBcUJuTCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT1QsQ0FBQyxDQUFDSSxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFdUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPRCx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0wsSUFBRXdMLG9CQUFvQjtJQUFJSSxPQUFPSCxPQUFPLEdBQUN6TDtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzPzM3NzYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezY3NTpmdW5jdGlvbihlLHIpe1widXNlIHN0cmljdFwiO3IuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO3IudG9CeXRlQXJyYXk9dG9CeXRlQXJyYXk7ci5mcm9tQnl0ZUFycmF5PWZyb21CeXRlQXJyYXk7dmFyIHQ9W107dmFyIGY9W107dmFyIG49dHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Zm9yKHZhciBvPTAsdT1pLmxlbmd0aDtvPHU7KytvKXt0W29dPWlbb107ZltpLmNoYXJDb2RlQXQobyldPW99ZltcIi1cIi5jaGFyQ29kZUF0KDApXT02MjtmW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2Z1bmN0aW9uIGdldExlbnMoZSl7dmFyIHI9ZS5sZW5ndGg7aWYociU0PjApe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIil9dmFyIHQ9ZS5pbmRleE9mKFwiPVwiKTtpZih0PT09LTEpdD1yO3ZhciBmPXQ9PT1yPzA6NC10JTQ7cmV0dXJuW3QsZl19ZnVuY3Rpb24gYnl0ZUxlbmd0aChlKXt2YXIgcj1nZXRMZW5zKGUpO3ZhciB0PXJbMF07dmFyIGY9clsxXTtyZXR1cm4odCtmKSozLzQtZn1mdW5jdGlvbiBfYnl0ZUxlbmd0aChlLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gdG9CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIHQ9Z2V0TGVucyhlKTt2YXIgaT10WzBdO3ZhciBvPXRbMV07dmFyIHU9bmV3IG4oX2J5dGVMZW5ndGgoZSxpLG8pKTt2YXIgYT0wO3ZhciBzPW8+MD9pLTQ6aTt2YXIgaDtmb3IoaD0wO2g8cztoKz00KXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTh8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDEyfGZbZS5jaGFyQ29kZUF0KGgrMildPDw2fGZbZS5jaGFyQ29kZUF0KGgrMyldO3VbYSsrXT1yPj4xNiYyNTU7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1pZihvPT09Mil7cj1mW2UuY2hhckNvZGVBdChoKV08PDJ8ZltlLmNoYXJDb2RlQXQoaCsxKV0+PjQ7dVthKytdPXImMjU1fWlmKG89PT0xKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTB8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDR8ZltlLmNoYXJDb2RlQXQoaCsyKV0+PjI7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1yZXR1cm4gdX1mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQoZSl7cmV0dXJuIHRbZT4+MTgmNjNdK3RbZT4+MTImNjNdK3RbZT4+NiY2M10rdFtlJjYzXX1mdW5jdGlvbiBlbmNvZGVDaHVuayhlLHIsdCl7dmFyIGY7dmFyIG49W107Zm9yKHZhciBpPXI7aTx0O2krPTMpe2Y9KGVbaV08PDE2JjE2NzExNjgwKSsoZVtpKzFdPDw4JjY1MjgwKSsoZVtpKzJdJjI1NSk7bi5wdXNoKHRyaXBsZXRUb0Jhc2U2NChmKSl9cmV0dXJuIG4uam9pbihcIlwiKX1mdW5jdGlvbiBmcm9tQnl0ZUFycmF5KGUpe3ZhciByO3ZhciBmPWUubGVuZ3RoO3ZhciBuPWYlMzt2YXIgaT1bXTt2YXIgbz0xNjM4Mztmb3IodmFyIHU9MCxhPWYtbjt1PGE7dSs9byl7aS5wdXNoKGVuY29kZUNodW5rKGUsdSx1K28+YT9hOnUrbykpfWlmKG49PT0xKXtyPWVbZi0xXTtpLnB1c2godFtyPj4yXSt0W3I8PDQmNjNdK1wiPT1cIil9ZWxzZSBpZihuPT09Mil7cj0oZVtmLTJdPDw4KStlW2YtMV07aS5wdXNoKHRbcj4+MTBdK3Rbcj4+NCY2M10rdFtyPDwyJjYzXStcIj1cIil9cmV0dXJuIGkuam9pbihcIlwiKX19LDcyOmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL3ZhciBmPXQoNjc1KTt2YXIgbj10KDc4Myk7dmFyIGk9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5mb3I9PT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7ci5CdWZmZXI9QnVmZmVyO3IuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO3IuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIG89MjE0NzQ4MzY0NztyLmtNYXhMZW5ndGg9bztCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVD10eXBlZEFycmF5U3VwcG9ydCgpO2lmKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGUhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PVwiZnVuY3Rpb25cIil7Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBcIitcImBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuXCIpfWZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3ZhciByPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGUscik7cmV0dXJuIGUuZm9vKCk9PT00Mn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnl0ZU9mZnNldH19KTtmdW5jdGlvbiBjcmVhdGVCdWZmZXIoZSl7aWYoZT5vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX12YXIgcj1uZXcgVWludDhBcnJheShlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gcn1mdW5jdGlvbiBCdWZmZXIoZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXJldHVybiBhbGxvY1Vuc2FmZShlKX1yZXR1cm4gZnJvbShlLHIsdCl9QnVmZmVyLnBvb2xTaXplPTgxOTI7ZnVuY3Rpb24gZnJvbShlLHIsdCl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZnJvbVN0cmluZyhlLHIpfWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZT09bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiYoaXNJbnN0YW5jZShlLFNoYXJlZEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixTaGFyZWRBcnJheUJ1ZmZlcikpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9dmFyIGY9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihmIT1udWxsJiZmIT09ZSl7cmV0dXJuIEJ1ZmZlci5mcm9tKGYscix0KX12YXIgbj1mcm9tT2JqZWN0KGUpO2lmKG4pcmV0dXJuIG47aWYodHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIGVbU3ltYm9sLnRvUHJpbWl0aXZlXT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIEJ1ZmZlci5mcm9tKGVbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxyLHQpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1CdWZmZXIuZnJvbT1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGZyb20oZSxyLHQpfTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcixVaW50OEFycmF5KTtmdW5jdGlvbiBhc3NlcnRTaXplKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpfWVsc2UgaWYoZTwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX19ZnVuY3Rpb24gYWxsb2MoZSxyLHQpe2Fzc2VydFNpemUoZSk7aWYoZTw9MCl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1pZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gdHlwZW9mIHQ9PT1cInN0cmluZ1wiP2NyZWF0ZUJ1ZmZlcihlKS5maWxsKHIsdCk6Y3JlYXRlQnVmZmVyKGUpLmZpbGwocil9cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1CdWZmZXIuYWxsb2M9ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBhbGxvYyhlLHIsdCl9O2Z1bmN0aW9uIGFsbG9jVW5zYWZlKGUpe2Fzc2VydFNpemUoZSk7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlPDA/MDpjaGVja2VkKGUpfDApfUJ1ZmZlci5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O0J1ZmZlci5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtmdW5jdGlvbiBmcm9tU3RyaW5nKGUscil7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyPT09XCJcIil7cj1cInV0ZjhcIn1pZighQnVmZmVyLmlzRW5jb2Rpbmcocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX12YXIgdD1ieXRlTGVuZ3RoKGUscil8MDt2YXIgZj1jcmVhdGVCdWZmZXIodCk7dmFyIG49Zi53cml0ZShlLHIpO2lmKG4hPT10KXtmPWYuc2xpY2UoMCxuKX1yZXR1cm4gZn1mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGUpe3ZhciByPWUubGVuZ3RoPDA/MDpjaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtmb3IodmFyIGY9MDtmPHI7Zis9MSl7dFtmXT1lW2ZdJjI1NX1yZXR1cm4gdH1mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpe2lmKHI8MHx8ZS5ieXRlTGVuZ3RoPHIpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfWlmKGUuYnl0ZUxlbmd0aDxyKyh0fHwwKSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9dmFyIGY7aWYocj09PXVuZGVmaW5lZCYmdD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlKX1lbHNlIGlmKHQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSxyKX1lbHNle2Y9bmV3IFVpbnQ4QXJyYXkoZSxyLHQpfU9iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfWZ1bmN0aW9uIGZyb21PYmplY3QoZSl7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXt2YXIgcj1jaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtpZih0Lmxlbmd0aD09PTApe3JldHVybiB0fWUuY29weSh0LDAsMCxyKTtyZXR1cm4gdH1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIGUubGVuZ3RoIT09XCJudW1iZXJcInx8bnVtYmVySXNOYU4oZS5sZW5ndGgpKXtyZXR1cm4gY3JlYXRlQnVmZmVyKDApfXJldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGUudHlwZT09PVwiQnVmZmVyXCImJkFycmF5LmlzQXJyYXkoZS5kYXRhKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZS5kYXRhKX19ZnVuY3Rpb24gY2hlY2tlZChlKXtpZihlPj1vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gXCIrXCJzaXplOiAweFwiK28udG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpfXJldHVybiBlfDB9ZnVuY3Rpb24gU2xvd0J1ZmZlcihlKXtpZigrZSE9ZSl7ZT0wfXJldHVybiBCdWZmZXIuYWxsb2MoK2UpfUJ1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbiBpc0J1ZmZlcihlKXtyZXR1cm4gZSE9bnVsbCYmZS5faXNCdWZmZXI9PT10cnVlJiZlIT09QnVmZmVyLnByb3RvdHlwZX07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIpe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSllPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKTtpZihpc0luc3RhbmNlKHIsVWludDhBcnJheSkpcj1CdWZmZXIuZnJvbShyLHIub2Zmc2V0LHIuYnl0ZUxlbmd0aCk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKXx8IUJ1ZmZlci5pc0J1ZmZlcihyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpfWlmKGU9PT1yKXJldHVybiAwO3ZhciB0PWUubGVuZ3RoO3ZhciBmPXIubGVuZ3RoO2Zvcih2YXIgbj0wLGk9TWF0aC5taW4odCxmKTtuPGk7KytuKXtpZihlW25dIT09cltuXSl7dD1lW25dO2Y9cltuXTticmVha319aWYodDxmKXJldHVybi0xO2lmKGY8dClyZXR1cm4gMTtyZXR1cm4gMH07QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24gaXNFbmNvZGluZyhlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2V9fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uIGNvbmNhdChlLHIpe2lmKCFBcnJheS5pc0FycmF5KGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pZihlLmxlbmd0aD09PTApe3JldHVybiBCdWZmZXIuYWxsb2MoMCl9dmFyIHQ7aWYocj09PXVuZGVmaW5lZCl7cj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3IrPWVbdF0ubGVuZ3RofX12YXIgZj1CdWZmZXIuYWxsb2NVbnNhZmUocik7dmFyIG49MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXt2YXIgaT1lW3RdO2lmKGlzSW5zdGFuY2UoaSxVaW50OEFycmF5KSl7aT1CdWZmZXIuZnJvbShpKX1pZighQnVmZmVyLmlzQnVmZmVyKGkpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pLmNvcHkoZixuKTtuKz1pLmxlbmd0aH1yZXR1cm4gZn07ZnVuY3Rpb24gYnl0ZUxlbmd0aChlLHIpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7cmV0dXJuIGUubGVuZ3RofWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKXx8aXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKSl7cmV0dXJuIGUuYnl0ZUxlbmd0aH1pZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT10cnVlO2lmKCFmJiZ0PT09MClyZXR1cm4gMDt2YXIgbj1mYWxzZTtmb3IoOzspe3N3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4VG9CeXRlcyhlKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHQqMjtjYXNlXCJoZXhcIjpyZXR1cm4gdD4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFRvQnl0ZXMoZSkubGVuZ3RoO2RlZmF1bHQ6aWYobil7cmV0dXJuIGY/LTE6dXRmOFRvQnl0ZXMoZSkubGVuZ3RofXI9KFwiXCIrcikudG9Mb3dlckNhc2UoKTtuPXRydWV9fX1CdWZmZXIuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2Z1bmN0aW9uIHNsb3dUb1N0cmluZyhlLHIsdCl7dmFyIGY9ZmFsc2U7aWYocj09PXVuZGVmaW5lZHx8cjwwKXtyPTB9aWYocj50aGlzLmxlbmd0aCl7cmV0dXJuXCJcIn1pZih0PT09dW5kZWZpbmVkfHx0PnRoaXMubGVuZ3RoKXt0PXRoaXMubGVuZ3RofWlmKHQ8PTApe3JldHVyblwiXCJ9dD4+Pj0wO3I+Pj49MDtpZih0PD1yKXtyZXR1cm5cIlwifWlmKCFlKWU9XCJ1dGY4XCI7d2hpbGUodHJ1ZSl7c3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBoZXhTbGljZSh0aGlzLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlTbGljZSh0aGlzLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVNsaWNlKHRoaXMscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0U2xpY2UodGhpcyxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1dGYxNmxlU2xpY2UodGhpcyxyLHQpO2RlZmF1bHQ6aWYoZil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpO2Y9dHJ1ZX19fUJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyPXRydWU7ZnVuY3Rpb24gc3dhcChlLHIsdCl7dmFyIGY9ZVtyXTtlW3JdPWVbdF07ZVt0XT1mfUJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uIHN3YXAxNigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTIpe3N3YXAodGhpcyxyLHIrMSl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uIHN3YXAzMigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlNCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTQpe3N3YXAodGhpcyxyLHIrMyk7c3dhcCh0aGlzLHIrMSxyKzIpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbiBzd2FwNjQoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTghPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz04KXtzd2FwKHRoaXMscixyKzcpO3N3YXAodGhpcyxyKzEscis2KTtzd2FwKHRoaXMscisyLHIrNSk7c3dhcCh0aGlzLHIrMyxyKzQpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZT09PTApcmV0dXJuXCJcIjtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gdXRmOFNsaWNlKHRoaXMsMCxlKTtyZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07QnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nO0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uIGVxdWFscyhlKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO2lmKHRoaXM9PT1lKXJldHVybiB0cnVlO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGUpPT09MH07QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXt2YXIgZT1cIlwiO3ZhciB0PXIuSU5TUEVDVF9NQVhfQllURVM7ZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCk7aWYodGhpcy5sZW5ndGg+dCllKz1cIiAuLi4gXCI7cmV0dXJuXCI8QnVmZmVyIFwiK2UrXCI+XCJ9O2lmKGkpe0J1ZmZlci5wcm90b3R5cGVbaV09QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0fUJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscix0LGYsbil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKXtlPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKX1pZighQnVmZmVyLmlzQnVmZmVyKGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYocj09PXVuZGVmaW5lZCl7cj0wfWlmKHQ9PT11bmRlZmluZWQpe3Q9ZT9lLmxlbmd0aDowfWlmKGY9PT11bmRlZmluZWQpe2Y9MH1pZihuPT09dW5kZWZpbmVkKXtuPXRoaXMubGVuZ3RofWlmKHI8MHx8dD5lLmxlbmd0aHx8ZjwwfHxuPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKX1pZihmPj1uJiZyPj10KXtyZXR1cm4gMH1pZihmPj1uKXtyZXR1cm4tMX1pZihyPj10KXtyZXR1cm4gMX1yPj4+PTA7dD4+Pj0wO2Y+Pj49MDtuPj4+PTA7aWYodGhpcz09PWUpcmV0dXJuIDA7dmFyIGk9bi1mO3ZhciBvPXQtcjt2YXIgdT1NYXRoLm1pbihpLG8pO3ZhciBhPXRoaXMuc2xpY2UoZixuKTt2YXIgcz1lLnNsaWNlKHIsdCk7Zm9yKHZhciBoPTA7aDx1OysraCl7aWYoYVtoXSE9PXNbaF0pe2k9YVtoXTtvPXNbaF07YnJlYWt9fWlmKGk8bylyZXR1cm4tMTtpZihvPGkpcmV0dXJuIDE7cmV0dXJuIDB9O2Z1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGUscix0LGYsbil7aWYoZS5sZW5ndGg9PT0wKXJldHVybi0xO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9MH1lbHNlIGlmKHQ+MjE0NzQ4MzY0Nyl7dD0yMTQ3NDgzNjQ3fWVsc2UgaWYodDwtMjE0NzQ4MzY0OCl7dD0tMjE0NzQ4MzY0OH10PSt0O2lmKG51bWJlcklzTmFOKHQpKXt0PW4/MDplLmxlbmd0aC0xfWlmKHQ8MCl0PWUubGVuZ3RoK3Q7aWYodD49ZS5sZW5ndGgpe2lmKG4pcmV0dXJuLTE7ZWxzZSB0PWUubGVuZ3RoLTF9ZWxzZSBpZih0PDApe2lmKG4pdD0wO2Vsc2UgcmV0dXJuLTF9aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtyPUJ1ZmZlci5mcm9tKHIsZil9aWYoQnVmZmVyLmlzQnVmZmVyKHIpKXtpZihyLmxlbmd0aD09PTApe3JldHVybi0xfXJldHVybiBhcnJheUluZGV4T2YoZSxyLHQsZixuKX1lbHNlIGlmKHR5cGVvZiByPT09XCJudW1iZXJcIil7cj1yJjI1NTtpZih0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09PVwiZnVuY3Rpb25cIil7aWYobil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHIsdCl9ZWxzZXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHIsdCl9fXJldHVybiBhcnJheUluZGV4T2YoZSxbcl0sdCxmLG4pfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9ZnVuY3Rpb24gYXJyYXlJbmRleE9mKGUscix0LGYsbil7dmFyIGk9MTt2YXIgbz1lLmxlbmd0aDt2YXIgdT1yLmxlbmd0aDtpZihmIT09dW5kZWZpbmVkKXtmPVN0cmluZyhmKS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInVjczJcInx8Zj09PVwidWNzLTJcInx8Zj09PVwidXRmMTZsZVwifHxmPT09XCJ1dGYtMTZsZVwiKXtpZihlLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXtyZXR1cm4tMX1pPTI7by89Mjt1Lz0yO3QvPTJ9fWZ1bmN0aW9uIHJlYWQoZSxyKXtpZihpPT09MSl7cmV0dXJuIGVbcl19ZWxzZXtyZXR1cm4gZS5yZWFkVUludDE2QkUocippKX19dmFyIGE7aWYobil7dmFyIHM9LTE7Zm9yKGE9dDthPG87YSsrKXtpZihyZWFkKGUsYSk9PT1yZWFkKHIscz09PS0xPzA6YS1zKSl7aWYocz09PS0xKXM9YTtpZihhLXMrMT09PXUpcmV0dXJuIHMqaX1lbHNle2lmKHMhPT0tMSlhLT1hLXM7cz0tMX19fWVsc2V7aWYodCt1Pm8pdD1vLXU7Zm9yKGE9dDthPj0wO2EtLSl7dmFyIGg9dHJ1ZTtmb3IodmFyIGM9MDtjPHU7YysrKXtpZihyZWFkKGUsYStjKSE9PXJlYWQocixjKSl7aD1mYWxzZTticmVha319aWYoaClyZXR1cm4gYX19cmV0dXJuLTF9QnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbiBpbmNsdWRlcyhlLHIsdCl7cmV0dXJuIHRoaXMuaW5kZXhPZihlLHIsdCkhPT0tMX07QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uIGluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LHRydWUpfTtCdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uIGxhc3RJbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCxmYWxzZSl9O2Z1bmN0aW9uIGhleFdyaXRlKGUscix0LGYpe3Q9TnVtYmVyKHQpfHwwO3ZhciBuPWUubGVuZ3RoLXQ7aWYoIWYpe2Y9bn1lbHNle2Y9TnVtYmVyKGYpO2lmKGY+bil7Zj1ufX12YXIgaT1yLmxlbmd0aDtpZihmPmkvMil7Zj1pLzJ9Zm9yKHZhciBvPTA7bzxmOysrbyl7dmFyIHU9cGFyc2VJbnQoci5zdWJzdHIobyoyLDIpLDE2KTtpZihudW1iZXJJc05hTih1KSlyZXR1cm4gbztlW3Qrb109dX1yZXR1cm4gb31mdW5jdGlvbiB1dGY4V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9ZnVuY3Rpb24gYXNjaWlXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIGxhdGluMVdyaXRlKGUscix0LGYpe3JldHVybiBhc2NpaVdyaXRlKGUscix0LGYpfWZ1bmN0aW9uIGJhc2U2NFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIHVjczJXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uIHdyaXRlKGUscix0LGYpe2lmKHI9PT11bmRlZmluZWQpe2Y9XCJ1dGY4XCI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZih0PT09dW5kZWZpbmVkJiZ0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKGlzRmluaXRlKHIpKXtyPXI+Pj4wO2lmKGlzRmluaXRlKHQpKXt0PXQ+Pj4wO2lmKGY9PT11bmRlZmluZWQpZj1cInV0ZjhcIn1lbHNle2Y9dDt0PXVuZGVmaW5lZH19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKX12YXIgbj10aGlzLmxlbmd0aC1yO2lmKHQ9PT11bmRlZmluZWR8fHQ+bil0PW47aWYoZS5sZW5ndGg+MCYmKHQ8MHx8cjwwKXx8cj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKX1pZighZilmPVwidXRmOFwiO3ZhciBpPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKGYpe2Nhc2VcImhleFwiOnJldHVybiBoZXhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdWNzMldyaXRlKHRoaXMsZSxyLHQpO2RlZmF1bHQ6aWYoaSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZik7Zj0oXCJcIitmKS50b0xvd2VyQ2FzZSgpO2k9dHJ1ZX19fTtCdWZmZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbiB0b0pTT04oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24gYmFzZTY0U2xpY2UoZSxyLHQpe2lmKHI9PT0wJiZ0PT09ZS5sZW5ndGgpe3JldHVybiBmLmZyb21CeXRlQXJyYXkoZSl9ZWxzZXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUuc2xpY2Uocix0KSl9fWZ1bmN0aW9uIHV0ZjhTbGljZShlLHIsdCl7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTt2YXIgZj1bXTt2YXIgbj1yO3doaWxlKG48dCl7dmFyIGk9ZVtuXTt2YXIgbz1udWxsO3ZhciB1PWk+MjM5PzQ6aT4yMjM/MzppPjE5MT8yOjE7aWYobit1PD10KXt2YXIgYSxzLGgsYztzd2l0Y2godSl7Y2FzZSAxOmlmKGk8MTI4KXtvPWl9YnJlYWs7Y2FzZSAyOmE9ZVtuKzFdO2lmKChhJjE5Mik9PT0xMjgpe2M9KGkmMzEpPDw2fGEmNjM7aWYoYz4xMjcpe289Y319YnJlYWs7Y2FzZSAzOmE9ZVtuKzFdO3M9ZVtuKzJdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxMnwoYSY2Myk8PDZ8cyY2MztpZihjPjIwNDcmJihjPDU1Mjk2fHxjPjU3MzQzKSl7bz1jfX1icmVhaztjYXNlIDQ6YT1lW24rMV07cz1lW24rMl07aD1lW24rM107aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCYmKGgmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDE4fChhJjYzKTw8MTJ8KHMmNjMpPDw2fGgmNjM7aWYoYz42NTUzNSYmYzwxMTE0MTEyKXtvPWN9fX19aWYobz09PW51bGwpe289NjU1MzM7dT0xfWVsc2UgaWYobz42NTUzNSl7by09NjU1MzY7Zi5wdXNoKG8+Pj4xMCYxMDIzfDU1Mjk2KTtvPTU2MzIwfG8mMTAyM31mLnB1c2gobyk7bis9dX1yZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KGYpfXZhciB1PTQwOTY7ZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGUpe3ZhciByPWUubGVuZ3RoO2lmKHI8PXUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKX12YXIgdD1cIlwiO3ZhciBmPTA7d2hpbGUoZjxyKXt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlLnNsaWNlKGYsZis9dSkpfXJldHVybiB0fWZ1bmN0aW9uIGFzY2lpU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0mMTI3KX1yZXR1cm4gZn1mdW5jdGlvbiBsYXRpbjFTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSl9cmV0dXJuIGZ9ZnVuY3Rpb24gaGV4U2xpY2UoZSxyLHQpe3ZhciBmPWUubGVuZ3RoO2lmKCFyfHxyPDApcj0wO2lmKCF0fHx0PDB8fHQ+Zil0PWY7dmFyIG49XCJcIjtmb3IodmFyIGk9cjtpPHQ7KytpKXtuKz1zW2VbaV1dfXJldHVybiBufWZ1bmN0aW9uIHV0ZjE2bGVTbGljZShlLHIsdCl7dmFyIGY9ZS5zbGljZShyLHQpO3ZhciBuPVwiXCI7Zm9yKHZhciBpPTA7aTxmLmxlbmd0aDtpKz0yKXtuKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGZbaV0rZltpKzFdKjI1Nil9cmV0dXJuIG59QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbiBzbGljZShlLHIpe3ZhciB0PXRoaXMubGVuZ3RoO2U9fn5lO3I9cj09PXVuZGVmaW5lZD90On5+cjtpZihlPDApe2UrPXQ7aWYoZTwwKWU9MH1lbHNlIGlmKGU+dCl7ZT10fWlmKHI8MCl7cis9dDtpZihyPDApcj0wfWVsc2UgaWYocj50KXtyPXR9aWYocjxlKXI9ZTt2YXIgZj10aGlzLnN1YmFycmF5KGUscik7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9O2Z1bmN0aW9uIGNoZWNrT2Zmc2V0KGUscix0KXtpZihlJTEhPT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYoZStyPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbiByZWFkVUludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24gcmVhZFVJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KXtjaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpfXZhciBmPXRoaXNbZSstLXJdO3ZhciBuPTE7d2hpbGUocj4wJiYobio9MjU2KSl7Zis9dGhpc1tlKy0tcl0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24gcmVhZFVJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbiByZWFkVUludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbiByZWFkVUludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDh8dGhpc1tlKzFdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbiByZWFkVUludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpK3RoaXNbZSszXSoxNjc3NzIxNn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdKjE2Nzc3MjE2Kyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbiByZWFkSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59bio9MTI4O2lmKGY+PW4pZi09TWF0aC5wb3coMiw4KnIpO3JldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbiByZWFkSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXI7dmFyIG49MTt2YXIgaT10aGlzW2UrLS1mXTt3aGlsZShmPjAmJihuKj0yNTYpKXtpKz10aGlzW2UrLS1mXSpufW4qPTEyODtpZihpPj1uKWktPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gaX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtpZighKHRoaXNbZV0mMTI4KSlyZXR1cm4gdGhpc1tlXTtyZXR1cm4oMjU1LXRoaXNbZV0rMSkqLTF9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24gcmVhZEludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24gcmVhZEludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24gcmVhZEludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTZ8dGhpc1tlKzNdPDwyNH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbiByZWFkSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uIHJlYWRGbG9hdExFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24gcmVhZEZsb2F0QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uIHJlYWREb3VibGVMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDUyLDgpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbiByZWFkRG91YmxlQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsNTIsOCl9O2Z1bmN0aW9uIGNoZWNrSW50KGUscix0LGYsbixpKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+bnx8cjxpKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uIHdyaXRlVUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9MTt2YXIgbz0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytvPHQmJihpKj0yNTYpKXt0aGlzW3Irb109ZS9pJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uIHdyaXRlVUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9dC0xO3ZhciBvPTE7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe3RoaXNbcitpXT1lL28mMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbiB3cml0ZVVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwyNTUsMCk7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24gd3JpdGVVSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlVUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbciszXT1lPj4+MjQ7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24gd3JpdGVVSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uIHdyaXRlSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9MDt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK2k8dCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpLTFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24gd3JpdGVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT10LTE7dmFyIG89MTt2YXIgdT0wO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraSsxXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24gd3JpdGVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwxMjcsLTEyOCk7aWYoZTwwKWU9MjU1K2UrMTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbiB3cml0ZUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24gd3JpdGVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbciszXT1lPj4+MjQ7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24gd3JpdGVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTtpZihlPDApZT00Mjk0OTY3Mjk1K2UrMTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07ZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGUscix0LGYsbixpKXtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIHdyaXRlRmxvYXQoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMil9bi53cml0ZShlLHIsdCxmLDIzLDQpO3JldHVybiB0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24gd3JpdGVGbG9hdExFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbiB3cml0ZUZsb2F0QkUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLGZhbHNlLHQpfTtmdW5jdGlvbiB3cml0ZURvdWJsZShlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpfW4ud3JpdGUoZSxyLHQsZiw1Miw4KTtyZXR1cm4gdCs4fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbiB3cml0ZURvdWJsZUxFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uIHdyaXRlRG91YmxlQkUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscixmYWxzZSx0KX07QnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uIGNvcHkoZSxyLHQsZil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKCF0KXQ9MDtpZighZiYmZiE9PTApZj10aGlzLmxlbmd0aDtpZihyPj1lLmxlbmd0aClyPWUubGVuZ3RoO2lmKCFyKXI9MDtpZihmPjAmJmY8dClmPXQ7aWYoZj09PXQpcmV0dXJuIDA7aWYoZS5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYocjwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIil9aWYodDwwfHx0Pj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpZihmPnRoaXMubGVuZ3RoKWY9dGhpcy5sZW5ndGg7aWYoZS5sZW5ndGgtcjxmLXQpe2Y9ZS5sZW5ndGgtcit0fXZhciBuPWYtdDtpZih0aGlzPT09ZSYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PT1cImZ1bmN0aW9uXCIpe3RoaXMuY29weVdpdGhpbihyLHQsZil9ZWxzZSBpZih0aGlzPT09ZSYmdDxyJiZyPGYpe2Zvcih2YXIgaT1uLTE7aT49MDstLWkpe2VbaStyXT10aGlzW2krdF19fWVsc2V7VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KHQsZikscil9cmV0dXJuIG59O0J1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbiBmaWxsKGUscix0LGYpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7cj0wO3Q9dGhpcy5sZW5ndGh9ZWxzZSBpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PXRoaXMubGVuZ3RofWlmKGYhPT11bmRlZmluZWQmJnR5cGVvZiBmIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIil9aWYodHlwZW9mIGY9PT1cInN0cmluZ1wiJiYhQnVmZmVyLmlzRW5jb2RpbmcoZikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKX1pZihlLmxlbmd0aD09PTEpe3ZhciBuPWUuY2hhckNvZGVBdCgwKTtpZihmPT09XCJ1dGY4XCImJm48MTI4fHxmPT09XCJsYXRpbjFcIil7ZT1ufX19ZWxzZSBpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2U9ZSYyNTV9ZWxzZSBpZih0eXBlb2YgZT09PVwiYm9vbGVhblwiKXtlPU51bWJlcihlKX1pZihyPDB8fHRoaXMubGVuZ3RoPHJ8fHRoaXMubGVuZ3RoPHQpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKHQ8PXIpe3JldHVybiB0aGlzfXI9cj4+PjA7dD10PT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOnQ+Pj4wO2lmKCFlKWU9MDt2YXIgaTtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2ZvcihpPXI7aTx0OysraSl7dGhpc1tpXT1lfX1lbHNle3ZhciBvPUJ1ZmZlci5pc0J1ZmZlcihlKT9lOkJ1ZmZlci5mcm9tKGUsZik7dmFyIHU9by5sZW5ndGg7aWYodT09PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyl9Zm9yKGk9MDtpPHQtcjsrK2kpe3RoaXNbaStyXT1vW2kldV19fXJldHVybiB0aGlzfTt2YXIgYT0vW14rLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIGJhc2U2NGNsZWFuKGUpe2U9ZS5zcGxpdChcIj1cIilbMF07ZT1lLnRyaW0oKS5yZXBsYWNlKGEsXCJcIik7aWYoZS5sZW5ndGg8MilyZXR1cm5cIlwiO3doaWxlKGUubGVuZ3RoJTQhPT0wKXtlPWUrXCI9XCJ9cmV0dXJuIGV9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoZSxyKXtyPXJ8fEluZmluaXR5O3ZhciB0O3ZhciBmPWUubGVuZ3RoO3ZhciBuPW51bGw7dmFyIGk9W107Zm9yKHZhciBvPTA7bzxmOysrbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD41NTI5NSYmdDw1NzM0NCl7aWYoIW4pe2lmKHQ+NTYzMTkpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYobysxPT09Zil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9bj10O2NvbnRpbnVlfWlmKHQ8NTYzMjApe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO249dDtjb250aW51ZX10PShuLTU1Mjk2PDwxMHx0LTU2MzIwKSs2NTUzNn1lbHNlIGlmKG4pe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpfW49bnVsbDtpZih0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7aS5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztpLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7aS5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO2kucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX19cmV0dXJuIGl9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGUpe3ZhciByPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyLnB1c2goZS5jaGFyQ29kZUF0KHQpJjI1NSl9cmV0dXJuIHJ9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoZSxyKXt2YXIgdCxmLG47dmFyIGk9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe2lmKChyLT0yKTwwKWJyZWFrO3Q9ZS5jaGFyQ29kZUF0KG8pO2Y9dD4+ODtuPXQlMjU2O2kucHVzaChuKTtpLnB1c2goZil9cmV0dXJuIGl9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhlKXtyZXR1cm4gZi50b0J5dGVBcnJheShiYXNlNjRjbGVhbihlKSl9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihlLHIsdCxmKXtmb3IodmFyIG49MDtuPGY7KytuKXtpZihuK3Q+PXIubGVuZ3RofHxuPj1lLmxlbmd0aClicmVhaztyW24rdF09ZVtuXX1yZXR1cm4gbn1mdW5jdGlvbiBpc0luc3RhbmNlKGUscil7cmV0dXJuIGUgaW5zdGFuY2VvZiByfHxlIT1udWxsJiZlLmNvbnN0cnVjdG9yIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZT09PXIubmFtZX1mdW5jdGlvbiBudW1iZXJJc05hTihlKXtyZXR1cm4gZSE9PWV9dmFyIHM9ZnVuY3Rpb24oKXt2YXIgZT1cIjAxMjM0NTY3ODlhYmNkZWZcIjt2YXIgcj1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIHQ9MDt0PDE2OysrdCl7dmFyIGY9dCoxNjtmb3IodmFyIG49MDtuPDE2Oysrbil7cltmK25dPWVbdF0rZVtuXX19cmV0dXJuIHJ9KCl9LDc4MzpmdW5jdGlvbihlLHIpe1xuLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbnIucmVhZD1mdW5jdGlvbihlLHIsdCxmLG4pe3ZhciBpLG87dmFyIHU9bio4LWYtMTt2YXIgYT0oMTw8dSktMTt2YXIgcz1hPj4xO3ZhciBoPS03O3ZhciBjPXQ/bi0xOjA7dmFyIGw9dD8tMToxO3ZhciBwPWVbcitjXTtjKz1sO2k9cCYoMTw8LWgpLTE7cD4+PS1oO2grPXU7Zm9yKDtoPjA7aT1pKjI1NitlW3IrY10sYys9bCxoLT04KXt9bz1pJigxPDwtaCktMTtpPj49LWg7aCs9Zjtmb3IoO2g+MDtvPW8qMjU2K2VbcitjXSxjKz1sLGgtPTgpe31pZihpPT09MCl7aT0xLXN9ZWxzZSBpZihpPT09YSl7cmV0dXJuIG8/TmFOOihwPy0xOjEpKkluZmluaXR5fWVsc2V7bz1vK01hdGgucG93KDIsZik7aT1pLXN9cmV0dXJuKHA/LTE6MSkqbypNYXRoLnBvdygyLGktZil9O3Iud3JpdGU9ZnVuY3Rpb24oZSxyLHQsZixuLGkpe3ZhciBvLHUsYTt2YXIgcz1pKjgtbi0xO3ZhciBoPSgxPDxzKS0xO3ZhciBjPWg+PjE7dmFyIGw9bj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgcD1mPzA6aS0xO3ZhciB5PWY/MTotMTt2YXIgZz1yPDB8fHI9PT0wJiYxL3I8MD8xOjA7cj1NYXRoLmFicyhyKTtpZihpc05hTihyKXx8cj09PUluZmluaXR5KXt1PWlzTmFOKHIpPzE6MDtvPWh9ZWxzZXtvPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpO2lmKHIqKGE9TWF0aC5wb3coMiwtbykpPDEpe28tLTthKj0yfWlmKG8rYz49MSl7cis9bC9hfWVsc2V7cis9bCpNYXRoLnBvdygyLDEtYyl9aWYociphPj0yKXtvKys7YS89Mn1pZihvK2M+PWgpe3U9MDtvPWh9ZWxzZSBpZihvK2M+PTEpe3U9KHIqYS0xKSpNYXRoLnBvdygyLG4pO289bytjfWVsc2V7dT1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLG4pO289MH19Zm9yKDtuPj04O2VbdCtwXT11JjI1NSxwKz15LHUvPTI1NixuLT04KXt9bz1vPDxufHU7cys9bjtmb3IoO3M+MDtlW3QrcF09byYyNTUscCs9eSxvLz0yNTYscy09OCl7fWVbdCtwLXldfD1nKjEyOH19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBmPXJbdF07aWYoZiE9PXVuZGVmaW5lZCl7cmV0dXJuIGYuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNzIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiciIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJ0IiwiZiIsIm4iLCJVaW50OEFycmF5IiwiQXJyYXkiLCJpIiwibyIsInUiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsIkVycm9yIiwiaW5kZXhPZiIsIl9ieXRlTGVuZ3RoIiwiYSIsInMiLCJoIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJwdXNoIiwiam9pbiIsIlN5bWJvbCIsImZvciIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJmb28iLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb21BcnJheUxpa2UiLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJpc0VuY29kaW5nIiwid3JpdGUiLCJzbGljZSIsImNvcHkiLCJudW1iZXJJc05hTiIsInR5cGUiLCJpc0FycmF5IiwiZGF0YSIsInRvU3RyaW5nIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImFyZ3VtZW50cyIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJyZXBsYWNlIiwidHJpbSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImMiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsImZyb21DaGFyQ29kZSIsInN1YmFycmF5IiwiY2hlY2tPZmZzZXQiLCJyZWFkVUludExFIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwiY29weVdpdGhpbiIsInNldCIsImJhc2U2NGNsZWFuIiwic3BsaXQiLCJJbmZpbml0eSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImwiLCJwIiwiTmFOIiwieSIsImciLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImV4cG9ydHMiLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar defaultParseOptions = {\n    decodeValues: true,\n    map: false,\n    silent: false\n};\nfunction isForbiddenKey(key) {\n    return typeof key !== \"string\" || key in {};\n}\nfunction createNullObj() {\n    return Object.create(null);\n}\nfunction isNonEmptyString(str) {\n    return typeof str === \"string\" && !!str.trim();\n}\nfunction parseString(setCookieValue, options) {\n    var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n    var nameValuePairStr = parts.shift();\n    var parsed = parseNameValuePair(nameValuePairStr);\n    var name = parsed.name;\n    var value = parsed.value;\n    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n    if (isForbiddenKey(name)) {\n        return null;\n    }\n    try {\n        value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n    } catch (e) {\n        console.error(\"set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.\", e);\n    }\n    var cookie = createNullObj();\n    cookie.name = name;\n    cookie.value = value;\n    parts.forEach(function(part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        if (isForbiddenKey(key)) {\n            return;\n        }\n        var value = sides.join(\"=\");\n        if (key === \"expires\") {\n            cookie.expires = new Date(value);\n        } else if (key === \"max-age\") {\n            var n = parseInt(value, 10);\n            if (!Number.isNaN(n)) cookie.maxAge = n;\n        } else if (key === \"secure\") {\n            cookie.secure = true;\n        } else if (key === \"httponly\") {\n            cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n            cookie.sameSite = value;\n        } else if (key === \"partitioned\") {\n            cookie.partitioned = true;\n        } else if (key) {\n            cookie[key] = value;\n        }\n    });\n    return cookie;\n}\nfunction parseNameValuePair(nameValuePairStr) {\n    // Parses name-value-pair according to rfc6265bis draft\n    var name = \"\";\n    var value = \"\";\n    var nameValueArr = nameValuePairStr.split(\"=\");\n    if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n    } else {\n        value = nameValuePairStr;\n    }\n    return {\n        name: name,\n        value: value\n    };\n}\nfunction parse(input, options) {\n    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n    if (!input) {\n        if (!options.map) {\n            return [];\n        } else {\n            return createNullObj();\n        }\n    }\n    if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n            // for fetch responses - they combine headers of the same type in the headers array,\n            // but getSetCookie returns an uncombined array\n            input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n            // fast-path for node.js (which automatically normalizes header names to lower-case)\n            input = input.headers[\"set-cookie\"];\n        } else {\n            // slow-path for other environments - see #25\n            var sch = input.headers[Object.keys(input.headers).find(function(key) {\n                return key.toLowerCase() === \"set-cookie\";\n            })];\n            // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n            if (!sch && input.headers.cookie && !options.silent) {\n                console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n            }\n            input = sch;\n        }\n    }\n    if (!Array.isArray(input)) {\n        input = [\n            input\n        ];\n    }\n    if (!options.map) {\n        return input.filter(isNonEmptyString).map(function(str) {\n            return parseString(str, options);\n        }).filter(Boolean);\n    } else {\n        var cookies = createNullObj();\n        return input.filter(isNonEmptyString).reduce(function(cookies, str) {\n            var cookie = parseString(str, options);\n            if (cookie && !isForbiddenKey(cookie.name)) {\n                cookies[cookie.name] = cookie;\n            }\n            return cookies;\n        }, cookies);\n    }\n}\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/ function splitCookiesString(cookiesString) {\n    if (Array.isArray(cookiesString)) {\n        return cookiesString;\n    }\n    if (typeof cookiesString !== \"string\") {\n        return [];\n    }\n    var cookiesStrings = [];\n    var pos = 0;\n    var start;\n    var ch;\n    var lastComma;\n    var nextStart;\n    var cookiesSeparatorFound;\n    function skipWhitespace() {\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n            pos += 1;\n        }\n        return pos < cookiesString.length;\n    }\n    function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n    }\n    while(pos < cookiesString.length){\n        start = pos;\n        cookiesSeparatorFound = false;\n        while(skipWhitespace()){\n            ch = cookiesString.charAt(pos);\n            if (ch === \",\") {\n                // ',' is a cookie separator if we have later first '=', not ';' or ','\n                lastComma = pos;\n                pos += 1;\n                skipWhitespace();\n                nextStart = pos;\n                while(pos < cookiesString.length && notSpecialChar()){\n                    pos += 1;\n                }\n                // currently special character\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n                    // we found cookies separator\n                    cookiesSeparatorFound = true;\n                    // pos is inside the next cookie, so back up and return it.\n                    pos = nextStart;\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\n                    start = pos;\n                } else {\n                    // in param ',' or param separator ';',\n                    // we continue from that comma\n                    pos = lastComma + 1;\n                }\n            } else {\n                pos += 1;\n            }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n    }\n    return cookiesStrings;\n}\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLHNCQUFzQjtJQUN4QkMsY0FBYztJQUNkQyxLQUFLO0lBQ0xDLFFBQVE7QUFDVjtBQUVBLFNBQVNDLGVBQWVDLEdBQUc7SUFDekIsT0FBTyxPQUFPQSxRQUFRLFlBQVlBLE9BQU8sQ0FBQztBQUM1QztBQUVBLFNBQVNDO0lBQ1AsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO0FBQ3ZCO0FBRUEsU0FBU0MsaUJBQWlCQyxHQUFHO0lBQzNCLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUMsQ0FBQ0EsSUFBSUMsSUFBSTtBQUM5QztBQUVBLFNBQVNDLFlBQVlDLGNBQWMsRUFBRUMsT0FBTztJQUMxQyxJQUFJQyxRQUFRRixlQUFlRyxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDUjtJQUU3QyxJQUFJUyxtQkFBbUJILE1BQU1JLEtBQUs7SUFDbEMsSUFBSUMsU0FBU0MsbUJBQW1CSDtJQUNoQyxJQUFJSSxPQUFPRixPQUFPRSxJQUFJO0lBQ3RCLElBQUlDLFFBQVFILE9BQU9HLEtBQUs7SUFFeEJULFVBQVVBLFVBQ05QLE9BQU9pQixNQUFNLENBQUMsQ0FBQyxHQUFHeEIscUJBQXFCYyxXQUN2Q2Q7SUFFSixJQUFJSSxlQUFla0IsT0FBTztRQUN4QixPQUFPO0lBQ1Q7SUFFQSxJQUFJO1FBQ0ZDLFFBQVFULFFBQVFiLFlBQVksR0FBR3dCLG1CQUFtQkYsU0FBU0EsT0FBTyxzQkFBc0I7SUFDMUYsRUFBRSxPQUFPRyxHQUFHO1FBQ1ZDLFFBQVFDLEtBQUssQ0FDWCx5R0FDQUY7SUFFSjtJQUVBLElBQUlHLFNBQVN2QjtJQUNidUIsT0FBT1AsSUFBSSxHQUFHQTtJQUNkTyxPQUFPTixLQUFLLEdBQUdBO0lBRWZSLE1BQU1lLE9BQU8sQ0FBQyxTQUFVQyxJQUFJO1FBQzFCLElBQUlDLFFBQVFELEtBQUtm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Q1pBLE9BQU87Z0JBRVBNO2dCQUNBRixZQUFZSjtnQkFFWixNQUFPQSxNQUFNRixjQUFjZixNQUFNLElBQUkwQixpQkFBa0I7b0JBQ3JEVCxPQUFPO2dCQUNUO2dCQUVBLDhCQUE4QjtnQkFDOUIsSUFBSUEsTUFBTUYsY0FBY2YsTUFBTSxJQUFJZSxjQUFjVSxNQUFNLENBQUNSLFNBQVMsS0FBSztvQkFDbkUsNkJBQTZCO29CQUM3Qkssd0JBQXdCO29CQUN4QiwyREFBMkQ7b0JBQzNETCxNQUFNSTtvQkFDTkwsZUFBZVcsSUFBSSxDQUFDWixjQUFjYSxTQUFTLENBQUNWLE9BQU9FO29CQUNuREYsUUFBUUQ7Z0JBQ1YsT0FBTztvQkFDTCx1Q0FBdUM7b0JBQ3ZDLDhCQUE4QjtvQkFDOUJBLE1BQU1HLFlBQVk7Z0JBQ3BCO1lBQ0YsT0FBTztnQkFDTEgsT0FBTztZQUNUO1FBQ0Y7UUFFQSxJQUFJLENBQUNLLHlCQUF5QkwsT0FBT0YsY0FBY2YsTUFBTSxFQUFFO1lBQ3pEZ0IsZUFBZVcsSUFBSSxDQUFDWixjQUFjYSxTQUFTLENBQUNWLE9BQU9ILGNBQWNmLE1BQU07UUFDekU7SUFDRjtJQUVBLE9BQU9nQjtBQUNUO0FBRUFhLE9BQU9DLE9BQU8sR0FBRzdCO0FBQ2pCNEIsb0JBQW9CLEdBQUc1QjtBQUN2QjRCLDBCQUEwQixHQUFHakU7QUFDN0JpRSxpQ0FBaUMsR0FBR2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NldC1jb29raWUtcGFyc2VyL2xpYi9zZXQtY29va2llLmpzPzMzMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlbktleShrZXkpIHtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIgfHwga2V5IGluIHt9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOdWxsT2JqKCkge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuXG4gIHZhciBuYW1lVmFsdWVQYWlyU3RyID0gcGFydHMuc2hpZnQoKTtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKTtcbiAgdmFyIG5hbWUgPSBwYXJzZWQubmFtZTtcbiAgdmFyIHZhbHVlID0gcGFyc2VkLnZhbHVlO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoaXNGb3JiaWRkZW5LZXkobmFtZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXI6IGZhaWxlZCB0byBkZWNvZGUgY29va2llIHZhbHVlLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXM9ZmFsc2UgdG8gZGlzYWJsZSBkZWNvZGluZy5cIixcbiAgICAgIGVcbiAgICApO1xuICB9XG5cbiAgdmFyIGNvb2tpZSA9IGNyZWF0ZU51bGxPYmooKTtcbiAgY29va2llLm5hbWUgPSBuYW1lO1xuICBjb29raWUudmFsdWUgPSB2YWx1ZTtcblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgdmFyIGtleSA9IHNpZGVzLnNoaWZ0KCkudHJpbUxlZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0ZvcmJpZGRlbktleShrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgIGlmIChrZXkgPT09IFwiZXhwaXJlc1wiKSB7XG4gICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXgtYWdlXCIpIHtcbiAgICAgIHZhciBuID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKG4pKSBjb29raWUubWF4QWdlID0gbjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgY29va2llLnNlY3VyZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzYW1lc2l0ZVwiKSB7XG4gICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJwYXJ0aXRpb25lZFwiKSB7XG4gICAgICBjb29raWUucGFydGl0aW9uZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICBjb29raWVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvb2tpZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpIHtcbiAgLy8gUGFyc2VzIG5hbWUtdmFsdWUtcGFpciBhY2NvcmRpbmcgdG8gcmZjNjI2NWJpcyBkcmFmdFxuXG4gIHZhciBuYW1lID0gXCJcIjtcbiAgdmFyIHZhbHVlID0gXCJcIjtcbiAgdmFyIG5hbWVWYWx1ZUFyciA9IG5hbWVWYWx1ZVBhaXJTdHIuc3BsaXQoXCI9XCIpO1xuICBpZiAobmFtZVZhbHVlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICBuYW1lID0gbmFtZVZhbHVlQXJyLnNoaWZ0KCk7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVBcnIuam9pbihcIj1cIik7IC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0ID0sIGpvaW5lZCBieSBhIFwiPVwiIGlmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIHBhcnRcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJTdHI7XG4gIH1cblxuICByZXR1cm4geyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghaW5wdXQpIHtcbiAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVOdWxsT2JqKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGZvciBmZXRjaCByZXNwb25zZXMgLSB0aGV5IGNvbWJpbmUgaGVhZGVycyBvZiB0aGUgc2FtZSB0eXBlIGluIHRoZSBoZWFkZXJzIGFycmF5LFxuICAgICAgLy8gYnV0IGdldFNldENvb2tpZSByZXR1cm5zIGFuIHVuY29tYmluZWQgYXJyYXlcbiAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZSlcbiAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNsb3ctcGF0aCBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gc2VlICMyNVxuICAgICAgdmFyIHNjaCA9XG4gICAgICAgIGlucHV0LmhlYWRlcnNbXG4gICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQuaGVhZGVycykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiO1xuICAgICAgICAgIH0pXG4gICAgICAgIF07XG4gICAgICAvLyB3YXJuIGlmIGNhbGxlZCBvbiBhIHJlcXVlc3QtbGlrZSBvYmplY3Qgd2l0aCBhIGNvb2tpZSBoZWFkZXIgcmF0aGVyIHRoYW4gYSBzZXQtY29va2llIGhlYWRlciAtIHNlZSAjMzQsIDM2XG4gICAgICBpZiAoIXNjaCAmJiBpbnB1dC5oZWFkZXJzLmNvb2tpZSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBzY2g7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IFtpbnB1dF07XG4gIH1cblxuICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgcmV0dXJuIGlucHV0XG4gICAgICAuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpXG4gICAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29va2llcyA9IGNyZWF0ZU51bGxPYmooKTtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbiAoY29va2llcywgc3RyKSB7XG4gICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgIGlmIChjb29raWUgJiYgIWlzRm9yYmlkZGVuS2V5KGNvb2tpZS5uYW1lKSkge1xuICAgICAgICBjb29raWVzW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWVzO1xuICAgIH0sIGNvb2tpZXMpO1xuICB9XG59XG5cbi8qXG4gIFNldC1Db29raWUgaGVhZGVyIGZpZWxkLXZhbHVlcyBhcmUgc29tZXRpbWVzIGNvbW1hIGpvaW5lZCBpbiBvbmUgc3RyaW5nLiBUaGlzIHNwbGl0cyB0aGVtIHdpdGhvdXQgY2hva2luZyBvbiBjb21tYXNcbiAgdGhhdCBhcmUgd2l0aGluIGEgc2luZ2xlIHNldC1jb29raWUgZmllbGQtdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIEV4cGlyZXMgcG9ydGlvbi5cblxuICBUaGlzIGlzIHVuY29tbW9uLCBidXQgZXhwbGljaXRseSBhbGxvd2VkIC0gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tNC4yXG4gIE5vZGUuanMgZG9lcyB0aGlzIGZvciBldmVyeSBoZWFkZXIgKmV4Y2VwdCogc2V0LWNvb2tpZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9kNWUzNjNiNzdlYmFmMWNhZjY3Y2Q3NTI4MjI0YjY1MWM4NjgxNWMxL2xpYi9faHR0cF9pbmNvbWluZy5qcyNMMTI4XG4gIFJlYWN0IE5hdGl2ZSdzIGZldGNoIGRvZXMgdGhpcyBmb3IgKmV2ZXJ5KiBoZWFkZXIsIGluY2x1ZGluZyBzZXQtY29va2llLlxuXG4gIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2oyb2JqYy9jb21taXQvMTY4MjBmZGJjOGY3NmNhMGMzMzQ3MjgxMGNlMGNiMDNkMjBlZmUyNVxuICBDcmVkaXRzIHRvOiBodHRwczovL2dpdGh1Yi5jb20vdG9tYmFsbCBmb3Igb3JpZ2luYWwgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJ1c2FydCBmb3IgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuKi9cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb29raWVzU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcblxuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgLy8gJywnIGlzIGEgY29va2llIHNlcGFyYXRvciBpZiB3ZSBoYXZlIGxhdGVyIGZpcnN0ICc9Jywgbm90ICc7JyBvciAnLCdcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAvLyB3ZSBmb3VuZCBjb29raWVzIHNlcGFyYXRvclxuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nO1xuIl0sIm5hbWVzIjpbImRlZmF1bHRQYXJzZU9wdGlvbnMiLCJkZWNvZGVWYWx1ZXMiLCJtYXAiLCJzaWxlbnQiLCJpc0ZvcmJpZGRlbktleSIsImtleSIsImNyZWF0ZU51bGxPYmoiLCJPYmplY3QiLCJjcmVhdGUiLCJpc05vbkVtcHR5U3RyaW5nIiwic3RyIiwidHJpbSIsInBhcnNlU3RyaW5nIiwic2V0Q29va2llVmFsdWUiLCJvcHRpb25zIiwicGFydHMiLCJzcGxpdCIsImZpbHRlciIsIm5hbWVWYWx1ZVBhaXJTdHIiLCJzaGlmdCIsInBhcnNlZCIsInBhcnNlTmFtZVZhbHVlUGFpciIsIm5hbWUiLCJ2YWx1ZSIsImFzc2lnbiIsImRlY29kZVVSSUNvbXBvbmVudCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJjb29raWUiLCJmb3JFYWNoIiwicGFydCIsInNpZGVzIiwidHJpbUxlZnQiLCJ0b0xvd2VyQ2FzZSIsImpvaW4iLCJleHBpcmVzIiwiRGF0ZSIsIm4iLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwibWF4QWdlIiwic2VjdXJlIiwiaHR0cE9ubHkiLCJzYW1lU2l0ZSIsInBhcnRpdGlvbmVkIiwibmFtZVZhbHVlQXJyIiwibGVuZ3RoIiwicGFyc2UiLCJpbnB1dCIsImhlYWRlcnMiLCJnZXRTZXRDb29raWUiLCJzY2giLCJrZXlzIiwiZmluZCIsIndhcm4iLCJBcnJheSIsImlzQXJyYXkiLCJCb29sZWFuIiwiY29va2llcyIsInJlZHVjZSIsInNwbGl0Q29va2llc1N0cmluZyIsImNvb2tpZXNTdHJpbmciLCJjb29raWVzU3RyaW5ncyIsInBvcyIsInN0YXJ0IiwiY2giLCJsYXN0Q29tbWEiLCJuZXh0U3RhcnQiLCJjb29raWVzU2VwYXJhdG9yRm91bmQiLCJza2lwV2hpdGVzcGFjZSIsInRlc3QiLCJjaGFyQXQiLCJub3RTcGVjaWFsQ2hhciIsInB1c2giLCJzdWJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/dashboard/layout.tsx":
/*!**********************************!*\
  !*** ./app/dashboard/layout.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DashboardLayout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/layout-dashboard.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/users.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/bell.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/award.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/log-out.js\");\n/* harmony import */ var _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=Award,Bell,LayoutDashboard,LogOut,MapPin,Menu,Settings,TrendingUp,User,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst navigation = [\n    {\n        name: \"Dashboard\",\n        href: \"/dashboard\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\n    },\n    {\n        name: \"Clientes\",\n        href: \"/dashboard/customers\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n    },\n    {\n        name: \"Notificaciones\",\n        href: \"/dashboard/notifications\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n    },\n    {\n        name: \"Campa\\xf1as\",\n        href: \"/dashboard/campaigns\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\n    },\n    {\n        name: \"Ubicaciones\",\n        href: \"/dashboard/locations\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"]\n    },\n    {\n        name: \"Fidelizaci\\xf3n\",\n        href: \"/dashboard/loyalty\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"]\n    },\n    {\n        name: \"Configuraci\\xf3n\",\n        href: \"/dashboard/settings\",\n        icon: _barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"]\n    }\n];\nfunction DashboardLayout(param) {\n    let { children } = param;\n    var _user_user_metadata_full_name, _user_user_metadata, _user_email, _user_user_metadata1;\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname)();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const supabase = (0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_4__.createClientComponentClient)();\n    const [sidebarOpen, setSidebarOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Fetch User Data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const getUser = async ()=>{\n            const { data: { user } } = await supabase.auth.getUser();\n            setUser(user);\n            setLoading(false);\n        };\n        getUser();\n    }, [\n        supabase\n    ]);\n    const handleLogout = async ()=>{\n        await supabase.auth.signOut();\n        router.push(\"/login\");\n        router.refresh();\n    };\n    // Close sidebar on route change (mobile)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setSidebarOpen(false);\n    }, [\n        pathname\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-50 dark:bg-gray-900\",\n        children: [\n            sidebarOpen && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed inset-0 bg-black/50 z-40 lg:hidden\",\n                onClick: ()=>setSidebarOpen(false)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                lineNumber: 65,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n                className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.cn)(\"fixed top-0 left-0 z-50 h-full w-64 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 transition-transform duration-300 transform\", sidebarOpen ? \"translate-x-0\" : \"-translate-x-full lg:translate-x-0\"),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col h-full\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    href: \"/dashboard\",\n                                    className: \"flex items-center space-x-2 group\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"bg-primary-50 dark:bg-primary-900/20 p-2 rounded-lg group-hover:bg-primary-100 dark:group-hover:bg-primary-900/40 transition-colors\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                className: \"w-6 h-6 text-primary-600\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                lineNumber: 83,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 82,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-600 to-secondary-600\",\n                                            children: \"RadarTracking\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 85,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 81,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>setSidebarOpen(false),\n                                    className: \"lg:hidden p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg text-gray-500\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                                        className: \"w-5 h-5\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                        lineNumber: 93,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 89,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                            lineNumber: 80,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                            className: \"flex-1 p-4 space-y-1 overflow-y-auto custom-scrollbar\",\n                            children: navigation.map((item)=>{\n                                const isActive = pathname === item.href;\n                                const Icon = item.icon;\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    href: item.href,\n                                    className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.cn)(\"flex items-center space-x-3 px-4 py-3 rounded-lg transition-all duration-200 group\", isActive ? \"bg-primary-50 dark:bg-primary-900/20 text-primary-700 dark:text-primary-300 font-semibold\" : \"text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700/50 hover:text-gray-900 dark:hover:text-white\"),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Icon, {\n                                            className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.cn)(\"w-5 h-5 transition-colors\", isActive ? \"text-primary-600\" : \"text-gray-400 group-hover:text-gray-500\")\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 113,\n                                            columnNumber: 37\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: item.name\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 114,\n                                            columnNumber: 37\n                                        }, this)\n                                    ]\n                                }, item.name, true, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 103,\n                                    columnNumber: 33\n                                }, this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                            lineNumber: 98,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50/50 dark:bg-gray-800/50\",\n                            children: [\n                                loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"animate-pulse flex items-center space-x-3 px-4 py-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"rounded-full bg-gray-200 h-10 w-10\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 124,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex-1 space-y-2\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"h-2 bg-gray-200 rounded w-full\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                    lineNumber: 126,\n                                                    columnNumber: 37\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"h-2 bg-gray-200 rounded w-2/3\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                    lineNumber: 127,\n                                                    columnNumber: 37\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 125,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 123,\n                                    columnNumber: 29\n                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-3 px-4 py-3 rounded-lg mb-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"w-10 h-10 rounded-full bg-gradient-to-br from-primary-500 to-secondary-500 flex items-center justify-center text-white font-bold shadow-sm\",\n                                            children: (user === null || user === void 0 ? void 0 : (_user_user_metadata = user.user_metadata) === null || _user_user_metadata === void 0 ? void 0 : (_user_user_metadata_full_name = _user_user_metadata.full_name) === null || _user_user_metadata_full_name === void 0 ? void 0 : _user_user_metadata_full_name.charAt(0).toUpperCase()) || (user === null || user === void 0 ? void 0 : (_user_email = user.email) === null || _user_email === void 0 ? void 0 : _user_email.charAt(0).toUpperCase()) || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                                                className: \"w-6 h-6\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                lineNumber: 133,\n                                                columnNumber: 137\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 132,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex-1 min-w-0\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-sm font-medium text-gray-900 dark:text-white truncate\",\n                                                    children: (user === null || user === void 0 ? void 0 : (_user_user_metadata1 = user.user_metadata) === null || _user_user_metadata1 === void 0 ? void 0 : _user_user_metadata1.full_name) || \"Usuario\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                    lineNumber: 136,\n                                                    columnNumber: 37\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-xs text-gray-500 dark:text-gray-400 truncate\",\n                                                    children: user === null || user === void 0 ? void 0 : user.email\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                    lineNumber: 139,\n                                                    columnNumber: 37\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 135,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 131,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handleLogout,\n                                    className: \"w-full flex items-center space-x-3 px-4 py-2 rounded-lg text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors text-sm font-medium\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {\n                                            className: \"w-4 h-4\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 149,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: \"Cerrar Sesi\\xf3n\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                            lineNumber: 150,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 145,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                            lineNumber: 121,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                    lineNumber: 78,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                lineNumber: 72,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"lg:pl-64 flex flex-col min-h-screen\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                        className: \"sticky top-0 z-30 bg-white/80 dark:bg-gray-800/80 backdrop-blur-md border-b border-gray-200 dark:border-gray-700 px-6 py-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-between\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>setSidebarOpen(true),\n                                    className: \"lg:hidden p-2 -ml-2 text-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {\n                                        className: \"w-6 h-6\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                        lineNumber: 165,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 161,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"hidden md:block\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 169,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-4\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"relative p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Award_Bell_LayoutDashboard_LogOut_MapPin_Menu_Settings_TrendingUp_User_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                                className: \"w-5 h-5 text-gray-600 dark:text-gray-400\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                lineNumber: 175,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"absolute top-1 right-1 w-2.5 h-2.5 bg-red-500 rounded-full border-2 border-white dark:border-gray-800\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                                lineNumber: 176,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                        lineNumber: 174,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                                    lineNumber: 173,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                            lineNumber: 160,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                        lineNumber: 159,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                        className: \"flex-1 p-6 overflow-x-hidden\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"max-w-7xl mx-auto animate-fadeIn\",\n                            children: children\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                            lineNumber: 184,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                        lineNumber: 183,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n                lineNumber: 157,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\lisan\\\\OneDrive\\\\Escritorio\\\\radar-enterprise\\\\app\\\\dashboard\\\\layout.tsx\",\n        lineNumber: 62,\n        columnNumber: 9\n    }, this);\n}\n_s(DashboardLayout, \"eqFXOtXwVZjQGP9PeXlEACvfwsw=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = DashboardLayout;\nvar _c;\n$RefreshReg$(_c, \"DashboardLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXNoYm9hcmQvbGF5b3V0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXNEO0FBQzFCO0FBQzRCO0FBQ21CO0FBYXREO0FBQ1c7QUFFaEMsTUFBTWtCLGFBQWE7SUFDZjtRQUFFQyxNQUFNO1FBQWFDLE1BQU07UUFBY0MsTUFBTWYsMEpBQWVBO0lBQUM7SUFDL0Q7UUFBRWEsTUFBTTtRQUFZQyxNQUFNO1FBQXdCQyxNQUFNZCwwSkFBS0E7SUFBQztJQUM5RDtRQUFFWSxNQUFNO1FBQWtCQyxNQUFNO1FBQTRCQyxNQUFNYiwwSkFBSUE7SUFBQztJQUN2RTtRQUFFVyxNQUFNO1FBQVlDLE1BQU07UUFBd0JDLE1BQU1WLDBKQUFVQTtJQUFDO0lBQ25FO1FBQUVRLE1BQU07UUFBZUMsTUFBTTtRQUF3QkMsTUFBTVosMkpBQU1BO0lBQUM7SUFDbEU7UUFBRVUsTUFBTTtRQUFnQkMsTUFBTTtRQUFzQkMsTUFBTVgsMkpBQUtBO0lBQUM7SUFDaEU7UUFBRVMsTUFBTTtRQUFpQkMsTUFBTTtRQUF1QkMsTUFBTVQsMkpBQVFBO0lBQUM7Q0FDeEU7QUFFYyxTQUFTVSxnQkFBZ0IsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQztRQXFHSEMsK0JBQUFBLHFCQUEyREEsYUFJdkRBOztJQXhHckMsTUFBTUMsV0FBV3RCLDREQUFXQTtJQUM1QixNQUFNdUIsU0FBU3RCLDBEQUFTQTtJQUN4QixNQUFNdUIsV0FBV3RCLDBGQUEyQkE7SUFDNUMsTUFBTSxDQUFDdUIsYUFBYUMsZUFBZSxHQUFHNUIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDdUIsTUFBTU0sUUFBUSxHQUFHN0IsK0NBQVFBLENBQU07SUFDdEMsTUFBTSxDQUFDOEIsU0FBU0MsV0FBVyxHQUFHL0IsK0NBQVFBLENBQUM7SUFFdkMsa0JBQWtCO0lBQ2xCRCxnREFBU0EsQ0FBQztRQUNOLE1BQU1pQyxVQUFVO1lBQ1os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QU0rQixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBSzVCLDhEQUFDVjtvQ0FDR0gsU0FBU047b0NBQ1RLLFdBQVU7O3NEQUVWLDhEQUFDNUIsMkpBQU1BOzRDQUFDNEIsV0FBVTs7Ozs7O3NEQUNsQiw4REFBQ0c7c0RBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU90Qiw4REFBQ0o7Z0JBQUlDLFdBQVU7O2tDQUVYLDhEQUFDZ0I7d0JBQU9oQixXQUFVO2tDQUNkLDRFQUFDRDs0QkFBSUMsV0FBVTs7OENBQ1gsOERBQUNJO29DQUNHSCxTQUFTLElBQU1iLGVBQWU7b0NBQzlCWSxXQUFVOzhDQUVWLDRFQUFDM0IsMkpBQUlBO3dDQUFDMkIsV0FBVTs7Ozs7Ozs7Ozs7OENBSXBCLDhEQUFDRDtvQ0FBSUMsV0FBVTs7Ozs7OzhDQUlmLDhEQUFDRDtvQ0FBSUMsV0FBVTs4Q0FDWCw0RUFBQ0k7d0NBQU9KLFdBQVU7OzBEQUNkLDhEQUFDakMsMEpBQUlBO2dEQUFDaUMsV0FBVTs7Ozs7OzBEQUNoQiw4REFBQ0c7Z0RBQUtILFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBT2hDLDhEQUFDaUI7d0JBQUtqQixXQUFVO2tDQUNaLDRFQUFDRDs0QkFBSUMsV0FBVTtzQ0FDVmxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU16QjtHQS9Kd0JEOztRQUNIbkIsd0RBQVdBO1FBQ2JDLHNEQUFTQTs7O0tBRkprQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvZGFzaGJvYXJkL2xheW91dC50c3g/NzFlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IFJlYWN0Tm9kZSwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcbmltcG9ydCB7IHVzZVBhdGhuYW1lLCB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXHJcbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzJ1xyXG5pbXBvcnQge1xyXG4gICAgTGF5b3V0RGFzaGJvYXJkLFxyXG4gICAgVXNlcnMsXHJcbiAgICBCZWxsLFxyXG4gICAgTWFwUGluLFxyXG4gICAgQXdhcmQsXHJcbiAgICBUcmVuZGluZ1VwLFxyXG4gICAgU2V0dGluZ3MsXHJcbiAgICBMb2dPdXQsXHJcbiAgICBNZW51LFxyXG4gICAgWCxcclxuICAgIFVzZXJcclxufSBmcm9tICdsdWNpZGUtcmVhY3QnXHJcbmltcG9ydCB7IGNuIH0gZnJvbSAnQC9saWIvdXRpbHMnXHJcblxyXG5jb25zdCBuYXZpZ2F0aW9uID0gW1xyXG4gICAgeyBuYW1lOiAnRGFzaGJvYXJkJywgaHJlZjogJy9kYXNoYm9hcmQnLCBpY29uOiBMYXlvdXREYXNoYm9hcmQgfSxcclxuICAgIHsgbmFtZTogJ0NsaWVudGVzJywgaHJlZjogJy9kYXNoYm9hcmQvY3VzdG9tZXJzJywgaWNvbjogVXNlcnMgfSxcclxuICAgIHsgbmFtZTogJ05vdGlmaWNhY2lvbmVzJywgaHJlZjogJy9kYXNoYm9hcmQvbm90aWZpY2F0aW9ucycsIGljb246IEJlbGwgfSxcclxuICAgIHsgbmFtZTogJ0NhbXBhw7FhcycsIGhyZWY6ICcvZGFzaGJvYXJkL2NhbXBhaWducycsIGljb246IFRyZW5kaW5nVXAgfSxcclxuICAgIHsgbmFtZTogJ1ViaWNhY2lvbmVzJywgaHJlZjogJy9kYXNoYm9hcmQvbG9jYXRpb25zJywgaWNvbjogTWFwUGluIH0sXHJcbiAgICB7IG5hbWU6ICdGaWRlbGl6YWNpw7NuJywgaHJlZjogJy9kYXNoYm9hcmQvbG95YWx0eScsIGljb246IEF3YXJkIH0sXHJcbiAgICB7IG5hbWU6ICdDb25maWd1cmFjacOzbicsIGhyZWY6ICcvZGFzaGJvYXJkL3NldHRpbmdzJywgaWNvbjogU2V0dGluZ3MgfSxcclxuXVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkTGF5b3V0KHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcclxuICAgIGNvbnN0IHBhdGhuYW1lID0gdXNlUGF0aG5hbWUoKVxyXG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcclxuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50KClcclxuICAgIGNvbnN0IFtzaWRlYmFyT3Blbiwgc2V0U2lkZWJhck9wZW5dID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpXHJcbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxyXG5cclxuICAgIC8vIEZldGNoIFVzZXIgRGF0YVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBnZXRVc2VyID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxyXG4gICAgICAgICAgICBzZXRVc2VyKHVzZXIpXHJcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFVzZXIoKVxyXG4gICAgfSwgW3N1cGFiYXNlXSlcclxuXHJcbiAgICBjb25zdCBoYW5kbGVMb2dvdXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KClcclxuICAgICAgICByb3V0ZXIucHVzaCgnL2xvZ2luJylcclxuICAgICAgICByb3V0ZXIucmVmcmVzaCgpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xvc2Ugc2lkZWJhciBvbiByb3V0ZSBjaGFuZ2UgKG1vYmlsZSlcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0U2lkZWJhck9wZW4oZmFsc2UpXHJcbiAgICB9LCBbcGF0aG5hbWVdKVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctZ3JheS01MCBkYXJrOmJnLWdyYXktOTAwXCI+XHJcbiAgICAgICAgICAgIHsvKiBNb2JpbGUgc2lkZWJhciBiYWNrZHJvcCAqL31cclxuICAgICAgICAgICAge3NpZGViYXJPcGVuICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIGJnLWJsYWNrLzUwIHotNDAgbGc6aGlkZGVuXCJcclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaWRlYmFyT3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApfVxyXG5cclxuICAgICAgICAgICAgey8qIFNpZGViYXIgKi99XHJcbiAgICAgICAgICAgIDxhc2lkZVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbihcclxuICAgICAgICAgICAgICAgICAgICAnZml4ZWQgdG9wLTAgbGVmdC0wIHotNTAgaC1mdWxsIHctNjQgYmctd2hpdGUgZGFyazpiZy1ncmF5LTgwMCBib3JkZXItciBib3JkZXItZ3JheS0yMDAgZGFyazpib3JkZXItZ3JheS03MDAgdHJhbnNpdGlvbi10cmFuc2Zvcm0gZHVyYXRpb24tMzAwIHRyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZWJhck9wZW4gPyAndHJhbnNsYXRlLXgtMCcgOiAnLXRyYW5zbGF0ZS14LWZ1bGwgbGc6dHJhbnNsYXRlLXgtMCdcclxuICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBoLWZ1bGxcIj5cclxuICAgICAgICAgICAgICAgICAgICB7LyogTG9nbyAqL31cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLTYgYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwIGRhcms6Ym9yZGVyLWdyYXktNzAwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCIgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yIGdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXByaW1hcnktNTAgZGFyazpiZy1wcmltYXJ5LTkwMC8yMCBwLTIgcm91bmRlZC1sZyBncm91cC1ob3ZlcjpiZy1wcmltYXJ5LTEwMCBkYXJrOmdyb3VwLWhvdmVyOmJnLXByaW1hcnktOTAwLzQwIHRyYW5zaXRpb24tY29sb3JzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1hcFBpbiBjbGFzc05hbWU9XCJ3LTYgaC02IHRleHQtcHJpbWFyeS02MDBcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCBiZy1jbGlwLXRleHQgdGV4dC10cmFuc3BhcmVudCBiZy1ncmFkaWVudC10by1yIGZyb20tcHJpbWFyeS02MDAgdG8tc2Vjb25kYXJ5LTYwMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJhZGFyVHJhY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaWRlYmFyT3BlbihmYWxzZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsZzpoaWRkZW4gcC0yIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFggY2xhc3NOYW1lPVwidy01IGgtNVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB7LyogTmF2aWdhdGlvbiAqL31cclxuICAgICAgICAgICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cImZsZXgtMSBwLTQgc3BhY2UteS0xIG92ZXJmbG93LXktYXV0byBjdXN0b20tc2Nyb2xsYmFyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYXZpZ2F0aW9uLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBwYXRobmFtZSA9PT0gaXRlbS5ocmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBJY29uID0gaXRlbS5pY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aXRlbS5uYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmPXtpdGVtLmhyZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0zIHB4LTQgcHktMyByb3VuZGVkLWxnIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBncm91cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2JnLXByaW1hcnktNTAgZGFyazpiZy1wcmltYXJ5LTkwMC8yMCB0ZXh0LXByaW1hcnktNzAwIGRhcms6dGV4dC1wcmltYXJ5LTMwMCBmb250LXNlbWlib2xkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RleHQtZ3JheS02MDAgZGFyazp0ZXh0LWdyYXktNDAwIGhvdmVyOmJnLWdyYXktNTAgZGFyazpob3ZlcjpiZy1ncmF5LTcwMC81MCBob3Zlcjp0ZXh0LWdyYXktOTAwIGRhcms6aG92ZXI6dGV4dC13aGl0ZSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIGNsYXNzTmFtZT17Y24oXCJ3LTUgaC01IHRyYW5zaXRpb24tY29sb3JzXCIsIGlzQWN0aXZlID8gXCJ0ZXh0LXByaW1hcnktNjAwXCIgOiBcInRleHQtZ3JheS00MDAgZ3JvdXAtaG92ZXI6dGV4dC1ncmF5LTUwMFwiKX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e2l0ZW0ubmFtZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgICAgICA8L25hdj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgey8qIFVzZXIgc2VjdGlvbiAqL31cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBib3JkZXItdCBib3JkZXItZ3JheS0yMDAgZGFyazpib3JkZXItZ3JheS03MDAgYmctZ3JheS01MC81MCBkYXJrOmJnLWdyYXktODAwLzUwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXB1bHNlIGZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMyBweC00IHB5LTJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdW5kZWQtZnVsbCBiZy1ncmF5LTIwMCBoLTEwIHctMTBcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBzcGFjZS15LTJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLTIgYmctZ3JheS0yMDAgcm91bmRlZCB3LWZ1bGxcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLTIgYmctZ3JheS0yMDAgcm91bmRlZCB3LTIvM1wiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMyBweC00IHB5LTMgcm91bmRlZC1sZyBtYi0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTEwIGgtMTAgcm91bmRlZC1mdWxsIGJnLWdyYWRpZW50LXRvLWJyIGZyb20tcHJpbWFyeS01MDAgdG8tc2Vjb25kYXJ5LTUwMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXdoaXRlIGZvbnQtYm9sZCBzaGFkb3ctc21cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3VzZXI/LnVzZXJfbWV0YWRhdGE/LmZ1bGxfbmFtZT8uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgfHwgdXNlcj8uZW1haWw/LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpIHx8IDxVc2VyIGNsYXNzTmFtZT1cInctNiBoLTZcIiAvPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBtaW4tdy0wXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgdHJ1bmNhdGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt1c2VyPy51c2VyX21ldGFkYXRhPy5mdWxsX25hbWUgfHwgJ1VzdWFyaW8nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAgdHJ1bmNhdGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt1c2VyPy5lbWFpbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUxvZ291dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTMgcHgtNCBweS0yIHJvdW5kZWQtbGcgdGV4dC1yZWQtNjAwIGhvdmVyOmJnLXJlZC01MCBkYXJrOmhvdmVyOmJnLXJlZC05MDAvMjAgdHJhbnNpdGlvbi1jb2xvcnMgdGV4dC1zbSBmb250LW1lZGl1bVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMb2dPdXQgY2xhc3NOYW1lPVwidy00IGgtNFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5DZXJyYXIgU2VzacOzbjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9hc2lkZT5cclxuXHJcbiAgICAgICAgICAgIHsvKiBNYWluIGNvbnRlbnQgKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGc6cGwtNjQgZmxleCBmbGV4LWNvbCBtaW4taC1zY3JlZW5cIj5cclxuICAgICAgICAgICAgICAgIHsvKiBUb3AgYmFyICovfVxyXG4gICAgICAgICAgICAgICAgPGhlYWRlciBjbGFzc05hbWU9XCJzdGlja3kgdG9wLTAgei0zMCBiZy13aGl0ZS84MCBkYXJrOmJnLWdyYXktODAwLzgwIGJhY2tkcm9wLWJsdXItbWQgYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwIGRhcms6Ym9yZGVyLWdyYXktNzAwIHB4LTYgcHktNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNpZGViYXJPcGVuKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGc6aGlkZGVuIHAtMiAtbWwtMiB0ZXh0LWdyYXktNjAwIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWNvbG9yc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNZW51IGNsYXNzTmFtZT1cInctNiBoLTZcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBCcmVhZGNydW1icyBvciBQYWdlIFRpdGxlIFBsYWNlaG9sZGVyICovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiBtZDpibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey8qIEZ1dHVyZTogRHluYW1pYyBCcmVhZGNydW1icyAqL31cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBwLTIgcm91bmRlZC1mdWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS03MDAgdHJhbnNpdGlvbi1jb2xvcnNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QmVsbCBjbGFzc05hbWU9XCJ3LTUgaC01IHRleHQtZ3JheS02MDAgZGFyazp0ZXh0LWdyYXktNDAwXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMSByaWdodC0xIHctMi41IGgtMi41IGJnLXJlZC01MDAgcm91bmRlZC1mdWxsIGJvcmRlci0yIGJvcmRlci13aGl0ZSBkYXJrOmJvcmRlci1ncmF5LTgwMFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvaGVhZGVyPlxyXG5cclxuICAgICAgICAgICAgICAgIHsvKiBQYWdlIGNvbnRlbnQgKi99XHJcbiAgICAgICAgICAgICAgICA8bWFpbiBjbGFzc05hbWU9XCJmbGV4LTEgcC02IG92ZXJmbG93LXgtaGlkZGVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy03eGwgbXgtYXV0byBhbmltYXRlLWZhZGVJblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L21haW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkxpbmsiLCJ1c2VQYXRobmFtZSIsInVzZVJvdXRlciIsImNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCIsIkxheW91dERhc2hib2FyZCIsIlVzZXJzIiwiQmVsbCIsIk1hcFBpbiIsIkF3YXJkIiwiVHJlbmRpbmdVcCIsIlNldHRpbmdzIiwiTG9nT3V0IiwiTWVudSIsIlgiLCJVc2VyIiwiY24iLCJuYXZpZ2F0aW9uIiwibmFtZSIsImhyZWYiLCJpY29uIiwiRGFzaGJvYXJkTGF5b3V0IiwiY2hpbGRyZW4iLCJ1c2VyIiwicGF0aG5hbWUiLCJyb3V0ZXIiLCJzdXBhYmFzZSIsInNpZGViYXJPcGVuIiwic2V0U2lkZWJhck9wZW4iLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJnZXRVc2VyIiwiZGF0YSIsImF1dGgiLCJoYW5kbGVMb2dvdXQiLCJzaWduT3V0IiwicHVzaCIsInJlZnJlc2giLCJkaXYiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwiYXNpZGUiLCJzcGFuIiwiYnV0dG9uIiwibmF2IiwibWFwIiwiaXRlbSIsImlzQWN0aXZlIiwiSWNvbiIsInVzZXJfbWV0YWRhdGEiLCJmdWxsX25hbWUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImVtYWlsIiwicCIsImhlYWRlciIsIm1haW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/dashboard/layout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-shared/dist/index.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserCookieAuthStorageAdapter: function() { return /* binding */ BrowserCookieAuthStorageAdapter; },\n/* harmony export */   CookieAuthStorageAdapter: function() { return /* binding */ CookieAuthStorageAdapter; },\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: function() { return /* binding */ DEFAULT_COOKIE_OPTIONS; },\n/* harmony export */   createSupabaseClient: function() { return /* binding */ createSupabaseClient; },\n/* harmony export */   isBrowser: function() { return /* binding */ isBrowser; },\n/* harmony export */   parseCookies: function() { return /* binding */ export_parseCookies; },\n/* harmony export */   parseSupabaseCookie: function() { return /* binding */ parseSupabaseCookie; },\n/* harmony export */   serializeCookie: function() { return /* binding */ export_serializeCookie; },\n/* harmony export */   stringifySupabaseSession: function() { return /* binding */ stringifySupabaseSession; }\n/* harmony export */ });\n/* harmony import */ var jose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jose */ \"(app-pages-browser)/./node_modules/jose/dist/browser/util/base64url.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n// ../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js\nvar require_cookie = __commonJS({\n    \"../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js\" (exports) {\n        \"use strict\";\n        exports.parse = parse3;\n        exports.serialize = serialize3;\n        var __toString = Object.prototype.toString;\n        var fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n        function parse3(str, options) {\n            if (typeof str !== \"string\") {\n                throw new TypeError(\"argument str must be a string\");\n            }\n            var obj = {};\n            var opt = options || {};\n            var dec = opt.decode || decode;\n            var index = 0;\n            while(index < str.length){\n                var eqIdx = str.indexOf(\"=\", index);\n                if (eqIdx === -1) {\n                    break;\n                }\n                var endIdx = str.indexOf(\";\", index);\n                if (endIdx === -1) {\n                    endIdx = str.length;\n                } else if (endIdx < eqIdx) {\n                    index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n                    continue;\n                }\n                var key = str.slice(index, eqIdx).trim();\n                if (void 0 === obj[key]) {\n                    var val = str.slice(eqIdx + 1, endIdx).trim();\n                    if (val.charCodeAt(0) === 34) {\n                        val = val.slice(1, -1);\n                    }\n                    obj[key] = tryDecode(val, dec);\n                }\n                index = endIdx + 1;\n            }\n            return obj;\n        }\n        function serialize3(name, val, options) {\n            var opt = options || {};\n            var enc = opt.encode || encode;\n            if (typeof enc !== \"function\") {\n                throw new TypeError(\"option encode is invalid\");\n            }\n            if (!fieldContentRegExp.test(name)) {\n                throw new TypeError(\"argument name is invalid\");\n            }\n            var value = enc(val);\n            if (value && !fieldContentRegExp.test(value)) {\n                throw new TypeError(\"argument val is invalid\");\n            }\n            var str = name + \"=\" + value;\n            if (null != opt.maxAge) {\n                var maxAge = opt.maxAge - 0;\n                if (isNaN(maxAge) || !isFinite(maxAge)) {\n                    throw new TypeError(\"option maxAge is invalid\");\n                }\n                str += \"; Max-Age=\" + Math.floor(maxAge);\n            }\n            if (opt.domain) {\n                if (!fieldContentRegExp.test(opt.domain)) {\n                    throw new TypeError(\"option domain is invalid\");\n                }\n                str += \"; Domain=\" + opt.domain;\n            }\n            if (opt.path) {\n                if (!fieldContentRegExp.test(opt.path)) {\n                    throw new TypeError(\"option path is invalid\");\n                }\n                str += \"; Path=\" + opt.path;\n            }\n            if (opt.expires) {\n                var expires = opt.expires;\n                if (!isDate(expires) || isNaN(expires.valueOf())) {\n                    throw new TypeError(\"option expires is invalid\");\n                }\n                str += \"; Expires=\" + expires.toUTCString();\n            }\n            if (opt.httpOnly) {\n                str += \"; HttpOnly\";\n            }\n            if (opt.secure) {\n                str += \"; Secure\";\n            }\n            if (opt.priority) {\n                var priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n                switch(priority){\n                    case \"low\":\n                        str += \"; Priority=Low\";\n                        break;\n                    case \"medium\":\n                        str += \"; Priority=Medium\";\n                        break;\n                    case \"high\":\n                        str += \"; Priority=High\";\n                        break;\n                    default:\n                        throw new TypeError(\"option priority is invalid\");\n                }\n            }\n            if (opt.sameSite) {\n                var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n                switch(sameSite){\n                    case true:\n                        str += \"; SameSite=Strict\";\n                        break;\n                    case \"lax\":\n                        str += \"; SameSite=Lax\";\n                        break;\n                    case \"strict\":\n                        str += \"; SameSite=Strict\";\n                        break;\n                    case \"none\":\n                        str += \"; SameSite=None\";\n                        break;\n                    default:\n                        throw new TypeError(\"option sameSite is invalid\");\n                }\n            }\n            return str;\n        }\n        function decode(str) {\n            return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n        }\n        function encode(val) {\n            return encodeURIComponent(val);\n        }\n        function isDate(val) {\n            return __toString.call(val) === \"[object Date]\" || val instanceof Date;\n        }\n        function tryDecode(str, decode2) {\n            try {\n                return decode2(str);\n            } catch (e) {\n                return str;\n            }\n        }\n    }\n});\n// src/browserCookieStorage.ts\nvar import_cookie2 = __toESM(require_cookie());\n// src/utils/cookies.ts\nvar import_cookie = __toESM(require_cookie());\n\nfunction parseSupabaseCookie(str) {\n    if (!str) {\n        return null;\n    }\n    try {\n        const session = JSON.parse(str);\n        if (!session) {\n            return null;\n        }\n        if (session.constructor.name === \"Object\") {\n            return session;\n        }\n        if (session.constructor.name !== \"Array\") {\n            throw new Error(\"Unexpected format: \".concat(session.constructor.name));\n        }\n        const [_header, payloadStr, _signature] = session[0].split(\".\");\n        const payload = jose__WEBPACK_IMPORTED_MODULE_0__.decode(payloadStr);\n        const decoder = new TextDecoder();\n        const { exp, sub, ...user } = JSON.parse(decoder.decode(payload));\n        return {\n            expires_at: exp,\n            expires_in: exp - Math.round(Date.now() / 1e3),\n            token_type: \"bearer\",\n            access_token: session[0],\n            refresh_token: session[1],\n            provider_token: session[2],\n            provider_refresh_token: session[3],\n            user: {\n                id: sub,\n                factors: session[4],\n                ...user\n            }\n        };\n    } catch (err) {\n        console.warn(\"Failed to parse cookie string:\", err);\n        return null;\n    }\n}\nfunction stringifySupabaseSession(session) {\n    var _a;\n    var _ref;\n    return JSON.stringify([\n        session.access_token,\n        session.refresh_token,\n        session.provider_token,\n        session.provider_refresh_token,\n        (_ref = (_a = session.user) == null ? void 0 : _a.factors) !== null && _ref !== void 0 ? _ref : null\n    ]);\n}\n// src/utils/helpers.ts\nfunction isBrowser() {\n    return  true && typeof window.document !== \"undefined\";\n}\n// src/utils/constants.ts\nvar DEFAULT_COOKIE_OPTIONS = {\n    path: \"/\",\n    sameSite: \"lax\",\n    maxAge: 60 * 60 * 24 * 365 * 1e3\n};\n// src/chunker.ts\nfunction createChunkRegExp(chunkSize) {\n    return new RegExp(\".{1,\" + chunkSize + \"}\", \"g\");\n}\nvar MAX_CHUNK_SIZE = 3180;\nvar MAX_CHUNK_REGEXP = createChunkRegExp(MAX_CHUNK_SIZE);\n_c = MAX_CHUNK_REGEXP;\nfunction createChunks(key, value, chunkSize) {\n    const re = chunkSize !== void 0 ? createChunkRegExp(chunkSize) : MAX_CHUNK_REGEXP;\n    const chunkCount = Math.ceil(value.length / (chunkSize !== null && chunkSize !== void 0 ? chunkSize : MAX_CHUNK_SIZE));\n    if (chunkCount === 1) {\n        return [\n            {\n                name: key,\n                value\n            }\n        ];\n    }\n    const chunks = [];\n    const values = value.match(re);\n    values == null ? void 0 : values.forEach((value2, i)=>{\n        const name = \"\".concat(key, \".\").concat(i);\n        chunks.push({\n            name,\n            value: value2\n        });\n    });\n    return chunks;\n}\nfunction combineChunks(key) {\n    let retrieveChunk = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ()=>{\n        return null;\n    };\n    let values = [];\n    for(let i = 0;; i++){\n        const chunkName = \"\".concat(key, \".\").concat(i);\n        const chunk = retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        values.push(chunk);\n    }\n    return values.length ? values.join(\"\") : null;\n}\n// src/cookieAuthStorageAdapter.ts\nvar CookieAuthStorageAdapter = class {\n    getItem(key) {\n        const value = this.getCookie(key);\n        if (key.endsWith(\"-code-verifier\") && value) {\n            return value;\n        }\n        if (value) {\n            return JSON.stringify(parseSupabaseCookie(value));\n        }\n        const chunks = combineChunks(key, (chunkName)=>{\n            return this.getCookie(chunkName);\n        });\n        return chunks !== null ? JSON.stringify(parseSupabaseCookie(chunks)) : null;\n    }\n    setItem(key, value) {\n        if (key.endsWith(\"-code-verifier\")) {\n            this.setCookie(key, value);\n            return;\n        }\n        let session = JSON.parse(value);\n        const sessionStr = stringifySupabaseSession(session);\n        const sessionChunks = createChunks(key, sessionStr);\n        sessionChunks.forEach((sess)=>{\n            this.setCookie(sess.name, sess.value);\n        });\n    }\n    removeItem(key) {\n        this._deleteSingleCookie(key);\n        this._deleteChunkedCookies(key);\n    }\n    _deleteSingleCookie(key) {\n        if (this.getCookie(key)) {\n            this.deleteCookie(key);\n        }\n    }\n    _deleteChunkedCookies(key) {\n        let from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        for(let i = from;; i++){\n            const cookieName = \"\".concat(key, \".\").concat(i);\n            const value = this.getCookie(cookieName);\n            if (value === void 0) {\n                break;\n            }\n            this.deleteCookie(cookieName);\n        }\n    }\n    constructor(cookieOptions){\n        this.cookieOptions = {\n            ...DEFAULT_COOKIE_OPTIONS,\n            ...cookieOptions,\n            maxAge: DEFAULT_COOKIE_OPTIONS.maxAge\n        };\n    }\n};\n// src/browserCookieStorage.ts\nvar BrowserCookieAuthStorageAdapter = class extends CookieAuthStorageAdapter {\n    getCookie(name) {\n        if (!isBrowser()) return null;\n        const cookies = (0, import_cookie2.parse)(document.cookie);\n        return cookies[name];\n    }\n    setCookie(name, value) {\n        if (!isBrowser()) return null;\n        document.cookie = (0, import_cookie2.serialize)(name, value, {\n            ...this.cookieOptions,\n            httpOnly: false\n        });\n    }\n    deleteCookie(name) {\n        if (!isBrowser()) return null;\n        document.cookie = (0, import_cookie2.serialize)(name, \"\", {\n            ...this.cookieOptions,\n            maxAge: 0,\n            httpOnly: false\n        });\n    }\n    constructor(cookieOptions){\n        super(cookieOptions);\n    }\n};\n// src/createClient.ts\n\nfunction createSupabaseClient(supabaseUrl, supabaseKey, options) {\n    var _a;\n    const browser = isBrowser();\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        auth: {\n            flowType: \"pkce\",\n            autoRefreshToken: browser,\n            detectSessionInUrl: browser,\n            persistSession: true,\n            storage: options.auth.storage,\n            // fix this in supabase-js\n            ...((_a = options.auth) == null ? void 0 : _a.storageKey) ? {\n                storageKey: options.auth.storageKey\n            } : {}\n        }\n    });\n}\nvar export_parseCookies = import_cookie.parse;\nvar export_serializeCookie = import_cookie.serialize;\n /*! Bundled license information:\n\ncookie/index.js:\n  (*!\n   * cookie\n   * Copyright(c) 2012-2014 Roman Shtylman\n   * Copyright(c) 2015 Douglas Christopher Wilson\n   * MIT Licensed\n   *)\n*/  //# sourceMappingURL=index.mjs.map\nvar _c;\n$RefreshReg$(_c, \"MAX_CHUNK_REGEXP\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLXNoYXJlZC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxhQUFhLENBQUNDLElBQUlDLE1BQVEsU0FBU0M7UUFDckMsT0FBT0QsT0FBTyxDQUFDLEdBQUdELEVBQUUsQ0FBQ1Isa0JBQWtCUSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsTUFBTTtZQUFFRSxTQUFTLENBQUM7UUFBRSxHQUFHQSxPQUFPLEVBQUVGLE1BQU1BLElBQUlFLE9BQU87SUFDcEc7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9qQixrQkFBa0JjLE1BQ2hDLElBQUksQ0FBQ1YsYUFBYWMsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVFLEtBQUssSUFBTUwsSUFBSSxDQUFDRyxJQUFJO1lBQUVHLFlBQVksQ0FBRUosQ0FBQUEsT0FBT2xCLGlCQUFpQmdCLE1BQU1HLElBQUcsS0FBTUQsS0FBS0ksVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT1A7QUFDVDtBQUNBLElBQUlRLFVBQVUsQ0FBQ1osS0FBS2EsWUFBWUMsU0FBWUEsQ0FBQUEsU0FBU2QsT0FBTyxPQUFPaEIsU0FBU1Ms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QUksQ0FBQzRELGFBQ0gsT0FBTztRQUNURSxTQUFTd0MsTUFBTSxHQUFHLENBQUMsR0FBRzdFLGVBQWVoRCxTQUFTLEVBQUV1QixNQUFNLElBQUk7WUFDeEQsR0FBRyxJQUFJLENBQUNtRyxhQUFhO1lBQ3JCL0YsUUFBUTtZQUNSVyxVQUFVO1FBQ1o7SUFDRjtJQXpCQWdCLFlBQVlvRSxhQUFhLENBQUU7UUFDekIsS0FBSyxDQUFDQTtJQUNSO0FBd0JGO0FBRUEsc0JBQXNCO0FBQytCO0FBQ3JELFNBQVNLLHFCQUFxQkMsV0FBVyxFQUFFQyxXQUFXLEVBQUUzSCxPQUFPO0lBQzdELElBQUkyRTtJQUNKLE1BQU1pRCxVQUFVL0M7SUFDaEIsT0FBTzJDLG1FQUFZQSxDQUFDRSxhQUFhQyxhQUFhO1FBQzVDLEdBQUczSCxPQUFPO1FBQ1Y2SCxNQUFNO1lBQ0pDLFVBQVU7WUFDVkMsa0JBQWtCSDtZQUNsQkksb0JBQW9CSjtZQUNwQkssZ0JBQWdCO1lBQ2hCQyxTQUFTbEksUUFBUTZILElBQUksQ0FBQ0ssT0FBTztZQUM3QiwwQkFBMEI7WUFDMUIsR0FBRyxDQUFDLENBQUN2RCxLQUFLM0UsUUFBUTZILElBQUksS0FBSyxPQUFPLEtBQUssSUFBSWxELEdBQUd3RCxVQUFVLElBQUk7Z0JBQzFEQSxZQUFZbkksUUFBUTZILElBQUksQ0FBQ00sVUFBVTtZQUNyQyxJQUFJLENBQUMsQ0FBQztRQUNSO0lBQ0Y7QUFDRjtBQUNBLElBQUlDLHNCQUFzQnpGLGNBQWNuRCxLQUFLO0FBQzdDLElBQUk2SSx5QkFBeUIxRixjQUFjakQsU0FBUztBQVdsRCxDQUNGOzs7Ozs7Ozs7QUFTQSxJQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1zaGFyZWQvZGlzdC9pbmRleC5tanM/MzZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29va2llQDAuNS4wL25vZGVfbW9kdWxlcy9jb29raWUvaW5kZXguanNcbnZhciByZXF1aXJlX2Nvb2tpZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jb29raWVAMC41LjAvbm9kZV9tb2R1bGVzL2Nvb2tpZS9pbmRleC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2UzO1xuICAgIGV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplMztcbiAgICB2YXIgX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgdmFyIGZpZWxkQ29udGVudFJlZ0V4cCA9IC9eW1xcdTAwMDlcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdKyQvO1xuICAgIGZ1bmN0aW9uIHBhcnNlMyhzdHIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIGRlYyA9IG9wdC5kZWNvZGUgfHwgZGVjb2RlO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVxSWR4ID0gc3RyLmluZGV4T2YoXCI9XCIsIGluZGV4KTtcbiAgICAgICAgaWYgKGVxSWR4ID09PSAtMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRJZHggPSBzdHIuaW5kZXhPZihcIjtcIiwgaW5kZXgpO1xuICAgICAgICBpZiAoZW5kSWR4ID09PSAtMSkge1xuICAgICAgICAgIGVuZElkeCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kSWR4IDwgZXFJZHgpIHtcbiAgICAgICAgICBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZihcIjtcIiwgZXFJZHggLSAxKSArIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHN0ci5zbGljZShpbmRleCwgZXFJZHgpLnRyaW0oKTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gb2JqW2tleV0pIHtcbiAgICAgICAgICB2YXIgdmFsID0gc3RyLnNsaWNlKGVxSWR4ICsgMSwgZW5kSWR4KS50cmltKCk7XG4gICAgICAgICAgaWYgKHZhbC5jaGFyQ29kZUF0KDApID09PSAzNCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqW2tleV0gPSB0cnlEZWNvZGUodmFsLCBkZWMpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gZW5kSWR4ICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZTMobmFtZSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBlbmMgPSBvcHQuZW5jb2RlIHx8IGVuY29kZTtcbiAgICAgIGlmICh0eXBlb2YgZW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBlbmNvZGUgaXMgaW52YWxpZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IG5hbWUgaXMgaW52YWxpZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGVuYyh2YWwpO1xuICAgICAgaWYgKHZhbHVlICYmICFmaWVsZENvbnRlbnRSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHZhbCBpcyBpbnZhbGlkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9IG5hbWUgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgaWYgKG51bGwgIT0gb3B0Lm1heEFnZSkge1xuICAgICAgICB2YXIgbWF4QWdlID0gb3B0Lm1heEFnZSAtIDA7XG4gICAgICAgIGlmIChpc05hTihtYXhBZ2UpIHx8ICFpc0Zpbml0ZShtYXhBZ2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBtYXhBZ2UgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IE1heC1BZ2U9XCIgKyBNYXRoLmZsb29yKG1heEFnZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0LmRvbWFpbikge1xuICAgICAgICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG9wdC5kb21haW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBkb21haW4gaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IERvbWFpbj1cIiArIG9wdC5kb21haW47XG4gICAgICB9XG4gICAgICBpZiAob3B0LnBhdGgpIHtcbiAgICAgICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQucGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9uIHBhdGggaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IFBhdGg9XCIgKyBvcHQucGF0aDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHQuZXhwaXJlcykge1xuICAgICAgICB2YXIgZXhwaXJlcyA9IG9wdC5leHBpcmVzO1xuICAgICAgICBpZiAoIWlzRGF0ZShleHBpcmVzKSB8fCBpc05hTihleHBpcmVzLnZhbHVlT2YoKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9uIGV4cGlyZXMgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IEV4cGlyZXM9XCIgKyBleHBpcmVzLnRvVVRDU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgICAgIHN0ciArPSBcIjsgSHR0cE9ubHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgICAgIHN0ciArPSBcIjsgU2VjdXJlXCI7XG4gICAgICB9XG4gICAgICBpZiAob3B0LnByaW9yaXR5KSB7XG4gICAgICAgIHZhciBwcmlvcml0eSA9IHR5cGVvZiBvcHQucHJpb3JpdHkgPT09IFwic3RyaW5nXCIgPyBvcHQucHJpb3JpdHkudG9Mb3dlckNhc2UoKSA6IG9wdC5wcmlvcml0eTtcbiAgICAgICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgXCJsb3dcIjpcbiAgICAgICAgICAgIHN0ciArPSBcIjsgUHJpb3JpdHk9TG93XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PU1lZGl1bVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhpZ2hcIjpcbiAgICAgICAgICAgIHN0ciArPSBcIjsgUHJpb3JpdHk9SGlnaFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gcHJpb3JpdHkgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgICAgICB2YXIgc2FtZVNpdGUgPSB0eXBlb2Ygb3B0LnNhbWVTaXRlID09PSBcInN0cmluZ1wiID8gb3B0LnNhbWVTaXRlLnRvTG93ZXJDYXNlKCkgOiBvcHQuc2FtZVNpdGU7XG4gICAgICAgIHN3aXRjaCAoc2FtZVNpdGUpIHtcbiAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICBzdHIgKz0gXCI7IFNhbWVTaXRlPVN0cmljdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxheFwiOlxuICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1MYXhcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpY3RcIjpcbiAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9U3RyaWN0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1Ob25lXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IGRlY29kZVVSSUNvbXBvbmVudChzdHIpIDogc3RyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICAgIHJldHVybiBfX3RvU3RyaW5nLmNhbGwodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgfHwgdmFsIGluc3RhbmNlb2YgRGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJ5RGVjb2RlKHN0ciwgZGVjb2RlMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZTIoc3RyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBzcmMvYnJvd3NlckNvb2tpZVN0b3JhZ2UudHNcbnZhciBpbXBvcnRfY29va2llMiA9IF9fdG9FU00ocmVxdWlyZV9jb29raWUoKSk7XG5cbi8vIHNyYy91dGlscy9jb29raWVzLnRzXG52YXIgaW1wb3J0X2Nvb2tpZSA9IF9fdG9FU00ocmVxdWlyZV9jb29raWUoKSk7XG5pbXBvcnQgeyBiYXNlNjR1cmwgfSBmcm9tIFwiam9zZVwiO1xuZnVuY3Rpb24gcGFyc2VTdXBhYmFzZUNvb2tpZShzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKHN0cik7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24uY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICAgIGlmIChzZXNzaW9uLmNvbnN0cnVjdG9yLm5hbWUgIT09IFwiQXJyYXlcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGZvcm1hdDogJHtzZXNzaW9uLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtfaGVhZGVyLCBwYXlsb2FkU3RyLCBfc2lnbmF0dXJlXSA9IHNlc3Npb25bMF0uc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBiYXNlNjR1cmwuZGVjb2RlKHBheWxvYWRTdHIpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBjb25zdCB7IGV4cCwgc3ViLCAuLi51c2VyIH0gPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKHBheWxvYWQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwaXJlc19hdDogZXhwLFxuICAgICAgZXhwaXJlc19pbjogZXhwIC0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICAgIHRva2VuX3R5cGU6IFwiYmVhcmVyXCIsXG4gICAgICBhY2Nlc3NfdG9rZW46IHNlc3Npb25bMF0sXG4gICAgICByZWZyZXNoX3Rva2VuOiBzZXNzaW9uWzFdLFxuICAgICAgcHJvdmlkZXJfdG9rZW46IHNlc3Npb25bMl0sXG4gICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuOiBzZXNzaW9uWzNdLFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogc3ViLFxuICAgICAgICBmYWN0b3JzOiBzZXNzaW9uWzRdLFxuICAgICAgICAuLi51c2VyXG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIGNvb2tpZSBzdHJpbmc6XCIsIGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN1cGFiYXNlU2Vzc2lvbihzZXNzaW9uKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICBzZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgc2Vzc2lvbi5wcm92aWRlcl90b2tlbixcbiAgICBzZXNzaW9uLnByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgKChfYSA9IHNlc3Npb24udXNlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZhY3RvcnMpID8/IG51bGxcbiAgXSk7XG59XG5cbi8vIHNyYy91dGlscy9oZWxwZXJzLnRzXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbi8vIHNyYy91dGlscy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0NPT0tJRV9PUFRJT05TID0ge1xuICBwYXRoOiBcIi9cIixcbiAgc2FtZVNpdGU6IFwibGF4XCIsXG4gIG1heEFnZTogNjAgKiA2MCAqIDI0ICogMzY1ICogMWUzXG59O1xuXG4vLyBzcmMvY2h1bmtlci50c1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtSZWdFeHAoY2h1bmtTaXplKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiLnsxLFwiICsgY2h1bmtTaXplICsgXCJ9XCIsIFwiZ1wiKTtcbn1cbnZhciBNQVhfQ0hVTktfU0laRSA9IDMxODA7XG52YXIgTUFYX0NIVU5LX1JFR0VYUCA9IGNyZWF0ZUNodW5rUmVnRXhwKE1BWF9DSFVOS19TSVpFKTtcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rcyhrZXksIHZhbHVlLCBjaHVua1NpemUpIHtcbiAgY29uc3QgcmUgPSBjaHVua1NpemUgIT09IHZvaWQgMCA/IGNyZWF0ZUNodW5rUmVnRXhwKGNodW5rU2l6ZSkgOiBNQVhfQ0hVTktfUkVHRVhQO1xuICBjb25zdCBjaHVua0NvdW50ID0gTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIChjaHVua1NpemUgPz8gTUFYX0NIVU5LX1NJWkUpKTtcbiAgaWYgKGNodW5rQ291bnQgPT09IDEpIHtcbiAgICByZXR1cm4gW3sgbmFtZToga2V5LCB2YWx1ZSB9XTtcbiAgfVxuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgY29uc3QgdmFsdWVzID0gdmFsdWUubWF0Y2gocmUpO1xuICB2YWx1ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTIsIGkpID0+IHtcbiAgICBjb25zdCBuYW1lID0gYCR7a2V5fS4ke2l9YDtcbiAgICBjaHVua3MucHVzaCh7IG5hbWUsIHZhbHVlOiB2YWx1ZTIgfSk7XG4gIH0pO1xuICByZXR1cm4gY2h1bmtzO1xufVxuZnVuY3Rpb24gY29tYmluZUNodW5rcyhrZXksIHJldHJpZXZlQ2h1bmsgPSAoKSA9PiB7XG4gIHJldHVybiBudWxsO1xufSkge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyA7IGkrKykge1xuICAgIGNvbnN0IGNodW5rTmFtZSA9IGAke2tleX0uJHtpfWA7XG4gICAgY29uc3QgY2h1bmsgPSByZXRyaWV2ZUNodW5rKGNodW5rTmFtZSk7XG4gICAgaWYgKCFjaHVuaykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhbHVlcy5wdXNoKGNodW5rKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKFwiXCIpIDogbnVsbDtcbn1cblxuLy8gc3JjL2Nvb2tpZUF1dGhTdG9yYWdlQWRhcHRlci50c1xudmFyIENvb2tpZUF1dGhTdG9yYWdlQWRhcHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29va2llT3B0aW9ucykge1xuICAgIHRoaXMuY29va2llT3B0aW9ucyA9IHtcbiAgICAgIC4uLkRFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gICAgICAuLi5jb29raWVPcHRpb25zLFxuICAgICAgbWF4QWdlOiBERUZBVUxUX0NPT0tJRV9PUFRJT05TLm1heEFnZVxuICAgIH07XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0Q29va2llKGtleSk7XG4gICAgaWYgKGtleS5lbmRzV2l0aChcIi1jb2RlLXZlcmlmaWVyXCIpICYmIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlU3VwYWJhc2VDb29raWUodmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gY29tYmluZUNodW5rcyhrZXksIChjaHVua05hbWUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldENvb2tpZShjaHVua05hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaHVua3MgIT09IG51bGwgPyBKU09OLnN0cmluZ2lmeShwYXJzZVN1cGFiYXNlQ29va2llKGNodW5rcykpIDogbnVsbDtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5LmVuZHNXaXRoKFwiLWNvZGUtdmVyaWZpZXJcIikpIHtcbiAgICAgIHRoaXMuc2V0Q29va2llKGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2Vzc2lvbiA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgIGNvbnN0IHNlc3Npb25TdHIgPSBzdHJpbmdpZnlTdXBhYmFzZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgY29uc3Qgc2Vzc2lvbkNodW5rcyA9IGNyZWF0ZUNodW5rcyhrZXksIHNlc3Npb25TdHIpO1xuICAgIHNlc3Npb25DaHVua3MuZm9yRWFjaCgoc2VzcykgPT4ge1xuICAgICAgdGhpcy5zZXRDb29raWUoc2Vzcy5uYW1lLCBzZXNzLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRoaXMuX2RlbGV0ZVNpbmdsZUNvb2tpZShrZXkpO1xuICAgIHRoaXMuX2RlbGV0ZUNodW5rZWRDb29raWVzKGtleSk7XG4gIH1cbiAgX2RlbGV0ZVNpbmdsZUNvb2tpZShrZXkpIHtcbiAgICBpZiAodGhpcy5nZXRDb29raWUoa2V5KSkge1xuICAgICAgdGhpcy5kZWxldGVDb29raWUoa2V5KTtcbiAgICB9XG4gIH1cbiAgX2RlbGV0ZUNodW5rZWRDb29raWVzKGtleSwgZnJvbSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvb2tpZU5hbWUgPSBgJHtrZXl9LiR7aX1gO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldENvb2tpZShjb29raWVOYW1lKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWxldGVDb29raWUoY29va2llTmFtZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvYnJvd3NlckNvb2tpZVN0b3JhZ2UudHNcbnZhciBCcm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb29raWVPcHRpb25zKSB7XG4gICAgc3VwZXIoY29va2llT3B0aW9ucyk7XG4gIH1cbiAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29va2llcyA9ICgwLCBpbXBvcnRfY29va2llMi5wYXJzZSkoZG9jdW1lbnQuY29va2llKTtcbiAgICByZXR1cm4gY29va2llc1tuYW1lXTtcbiAgfVxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZG9jdW1lbnQuY29va2llID0gKDAsIGltcG9ydF9jb29raWUyLnNlcmlhbGl6ZSkobmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIGh0dHBPbmx5OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGRlbGV0ZUNvb2tpZShuYW1lKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9ICgwLCBpbXBvcnRfY29va2llMi5zZXJpYWxpemUpKG5hbWUsIFwiXCIsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIG1heEFnZTogMCxcbiAgICAgIGh0dHBPbmx5OiBmYWxzZVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvY3JlYXRlQ2xpZW50LnRzXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XG5mdW5jdGlvbiBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBicm93c2VyID0gaXNCcm93c2VyKCk7XG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRoOiB7XG4gICAgICBmbG93VHlwZTogXCJwa2NlXCIsXG4gICAgICBhdXRvUmVmcmVzaFRva2VuOiBicm93c2VyLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBicm93c2VyLFxuICAgICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgICBzdG9yYWdlOiBvcHRpb25zLmF1dGguc3RvcmFnZSxcbiAgICAgIC8vIGZpeCB0aGlzIGluIHN1cGFiYXNlLWpzXG4gICAgICAuLi4oKF9hID0gb3B0aW9ucy5hdXRoKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RvcmFnZUtleSkgPyB7XG4gICAgICAgIHN0b3JhZ2VLZXk6IG9wdGlvbnMuYXV0aC5zdG9yYWdlS2V5XG4gICAgICB9IDoge31cbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cG9ydF9wYXJzZUNvb2tpZXMgPSBpbXBvcnRfY29va2llLnBhcnNlO1xudmFyIGV4cG9ydF9zZXJpYWxpemVDb29raWUgPSBpbXBvcnRfY29va2llLnNlcmlhbGl6ZTtcbmV4cG9ydCB7XG4gIEJyb3dzZXJDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIsXG4gIENvb2tpZUF1dGhTdG9yYWdlQWRhcHRlcixcbiAgREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgY3JlYXRlU3VwYWJhc2VDbGllbnQsXG4gIGlzQnJvd3NlcixcbiAgZXhwb3J0X3BhcnNlQ29va2llcyBhcyBwYXJzZUNvb2tpZXMsXG4gIHBhcnNlU3VwYWJhc2VDb29raWUsXG4gIGV4cG9ydF9zZXJpYWxpemVDb29raWUgYXMgc2VyaWFsaXplQ29va2llLFxuICBzdHJpbmdpZnlTdXBhYmFzZVNlc3Npb25cbn07XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5jb29raWUvaW5kZXguanM6XG4gICgqIVxuICAgKiBjb29raWVcbiAgICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBSb21hbiBTaHR5bG1hblxuICAgKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICAgKiBNSVQgTGljZW5zZWRcbiAgICopXG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX2NvbW1vbkpTIiwiY2IiLCJtb2QiLCJfX3JlcXVpcmUiLCJleHBvcnRzIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsImdldCIsImVudW1lcmFibGUiLCJfX3RvRVNNIiwiaXNOb2RlTW9kZSIsInRhcmdldCIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsInJlcXVpcmVfY29va2llIiwicGFyc2UiLCJwYXJzZTMiLCJzZXJpYWxpemUiLCJzZXJpYWxpemUzIiwiX190b1N0cmluZyIsInRvU3RyaW5nIiwiZmllbGRDb250ZW50UmVnRXhwIiwic3RyIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIm9iaiIsIm9wdCIsImRlYyIsImRlY29kZSIsImluZGV4IiwibGVuZ3RoIiwiZXFJZHgiLCJpbmRleE9mIiwiZW5kSWR4IiwibGFzdEluZGV4T2YiLCJzbGljZSIsInRyaW0iLCJ2YWwiLCJjaGFyQ29kZUF0IiwidHJ5RGVjb2RlIiwibmFtZSIsImVuYyIsImVuY29kZSIsInRlc3QiLCJtYXhBZ2UiLCJpc05hTiIsImlzRmluaXRlIiwiTWF0aCIsImZsb29yIiwiZG9tYWluIiwicGF0aCIsImV4cGlyZXMiLCJpc0RhdGUiLCJ2YWx1ZU9mIiwidG9VVENTdHJpbmciLCJodHRwT25seSIsInNlY3VyZSIsInByaW9yaXR5IiwidG9Mb3dlckNhc2UiLCJzYW1lU2l0ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkRhdGUiLCJkZWNvZGUyIiwiZSIsImltcG9ydF9jb29raWUyIiwiaW1wb3J0X2Nvb2tpZSIsImJhc2U2NHVybCIsInBhcnNlU3VwYWJhc2VDb29raWUiLCJzZXNzaW9uIiwiSlNPTiIsImNvbnN0cnVjdG9yIiwiRXJyb3IiLCJfaGVhZGVyIiwicGF5bG9hZFN0ciIsIl9zaWduYXR1cmUiLCJzcGxpdCIsInBheWxvYWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJleHAiLCJzdWIiLCJ1c2VyIiwiZXhwaXJlc19hdCIsImV4cGlyZXNfaW4iLCJyb3VuZCIsIm5vdyIsInRva2VuX3R5cGUiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIiwicHJvdmlkZXJfdG9rZW4iLCJwcm92aWRlcl9yZWZyZXNoX3Rva2VuIiwiaWQiLCJmYWN0b3JzIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJzdHJpbmdpZnlTdXBhYmFzZVNlc3Npb24iLCJfYSIsInN0cmluZ2lmeSIsImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwiREVGQVVMVF9DT09LSUVfT1BUSU9OUyIsImNyZWF0ZUNodW5rUmVnRXhwIiwiY2h1bmtTaXplIiwiUmVnRXhwIiwiTUFYX0NIVU5LX1NJWkUiLCJNQVhfQ0hVTktfUkVHRVhQIiwiY3JlYXRlQ2h1bmtzIiwicmUiLCJjaHVua0NvdW50IiwiY2VpbCIsImNodW5rcyIsInZhbHVlcyIsIm1hdGNoIiwiZm9yRWFjaCIsInZhbHVlMiIsImkiLCJwdXNoIiwiY29tYmluZUNodW5rcyIsInJldHJpZXZlQ2h1bmsiLCJjaHVua05hbWUiLCJjaHVuayIsImpvaW4iLCJDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIiLCJnZXRJdGVtIiwiZ2V0Q29va2llIiwiZW5kc1dpdGgiLCJzZXRJdGVtIiwic2V0Q29va2llIiwic2Vzc2lvblN0ciIsInNlc3Npb25DaHVua3MiLCJzZXNzIiwicmVtb3ZlSXRlbSIsIl9kZWxldGVTaW5nbGVDb29raWUiLCJfZGVsZXRlQ2h1bmtlZENvb2tpZXMiLCJkZWxldGVDb29raWUiLCJjb29raWVOYW1lIiwiY29va2llT3B0aW9ucyIsIkJyb3dzZXJDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIiLCJjb29raWVzIiwiY29va2llIiwiY3JlYXRlQ2xpZW50IiwiY3JlYXRlU3VwYWJhc2VDbGllbnQiLCJzdXBhYmFzZVVybCIsInN1cGFiYXNlS2V5IiwiYnJvd3NlciIsImF1dGgiLCJmbG93VHlwZSIsImF1dG9SZWZyZXNoVG9rZW4iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJwZXJzaXN0U2Vzc2lvbiIsInN0b3JhZ2UiLCJzdG9yYWdlS2V5IiwiZXhwb3J0X3BhcnNlQ29va2llcyIsImV4cG9ydF9zZXJpYWxpemVDb29raWUiLCJwYXJzZUNvb2tpZXMiLCJzZXJpYWxpemVDb29raWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: function() { return /* binding */ PostgrestBuilder; },\n/* harmony export */   PostgrestClient: function() { return /* binding */ PostgrestClient; },\n/* harmony export */   PostgrestError: function() { return /* binding */ PostgrestError; },\n/* harmony export */   PostgrestFilterBuilder: function() { return /* binding */ PostgrestFilterBuilder; },\n/* harmony export */   PostgrestQueryBuilder: function() { return /* binding */ PostgrestQueryBuilder; },\n/* harmony export */   PostgrestTransformBuilder: function() { return /* binding */ PostgrestTransformBuilder; },\n/* harmony export */   \"default\": function() { return /* binding */ src_default; }\n/* harmony export */ });\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/ var PostgrestError = class extends Error {\n    /**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/ constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n};\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n    /**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t*/ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        var _this = this;\n        if (this.schema === void 0) {} else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n        else this.headers.set(\"Content-Profile\", this.schema);\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res$1)=>{\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res$1.status;\n            let statusText = res$1.statusText;\n            if (res$1.ok) {\n                var _this$headers$get2, _res$headers$get;\n                if (_this.method !== \"HEAD\") {\n                    var _this$headers$get;\n                    const body = await res$1.text();\n                    if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n                    else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n                    else data = JSON.parse(body);\n                }\n                const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n                    error = {\n                        code: \"PGRST116\",\n                        details: \"Results contain \".concat(data.length, \" rows, application/vnd.pgrst.object+json requires 1 row\"),\n                        hint: null,\n                        message: \"JSON object requested, multiple (or no) rows returned\"\n                    };\n                    data = null;\n                    count = null;\n                    status = 406;\n                    statusText = \"Not Acceptable\";\n                } else if (data.length === 1) data = data[0];\n                else data = null;\n            } else {\n                var _error$details;\n                const body = await res$1.text();\n                try {\n                    error = JSON.parse(body);\n                    if (Array.isArray(error) && res$1.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_unused) {\n                    if (res$1.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else error = {\n                        message: body\n                    };\n                }\n                if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n            }\n            return {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n        });\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{\n            var _fetchError$name2;\n            let errorDetails = \"\";\n            let hint = \"\";\n            let code = \"\";\n            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n            if (cause) {\n                var _cause$message, _cause$code, _fetchError$name, _cause$name;\n                const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n                const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n                errorDetails = \"\".concat((_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\", \": \").concat(fetchError === null || fetchError === void 0 ? void 0 : fetchError.message);\n                errorDetails += \"\\n\\nCaused by: \".concat((_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\", \": \").concat(causeMessage);\n                if (causeCode) errorDetails += \" (\".concat(causeCode, \")\");\n                if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += \"\\n\".concat(cause.stack);\n            } else {\n                var _fetchError$stack;\n                errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n            }\n            const urlLength = this.url.toString().length;\n            if ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === \"AbortError\" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === \"ABORT_ERR\") {\n                code = \"\";\n                hint = \"Request was aborted (timeout or manual cancellation)\";\n                if (urlLength > this.urlLengthLimit) hint += \". Note: Your request URL is \".concat(urlLength, \" characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.\");\n            } else if ((cause === null || cause === void 0 ? void 0 : cause.name) === \"HeadersOverflowError\" || (cause === null || cause === void 0 ? void 0 : cause.code) === \"UND_ERR_HEADERS_OVERFLOW\") {\n                code = \"\";\n                hint = \"HTTP headers exceeded server limits (typically 16KB)\";\n                if (urlLength > this.urlLengthLimit) hint += \". Your request URL is \".concat(urlLength, \" characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.\");\n            }\n            return {\n                error: {\n                    message: \"\".concat((_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\", \": \").concat(fetchError === null || fetchError === void 0 ? void 0 : fetchError.message),\n                    details: errorDetails,\n                    hint,\n                    code\n                },\n                data: null,\n                count: null,\n                status: 0,\n                statusText: \"\"\n            };\n        });\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/ overrideTypes() {\n        return this;\n    }\n    /**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/ constructor(builder){\n        var _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n        this.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;\n        if (builder.fetch) this.fetch = builder.fetch;\n        else this.fetch = fetch;\n    }\n};\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n    /**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/ select(columns) {\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ order(column) {\n        let { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const key = referencedTable ? \"\".concat(referencedTable, \".order\") : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, \"\".concat(existingOrder ? \"\".concat(existingOrder, \",\") : \"\").concat(column, \".\").concat(ascending ? \"asc\" : \"desc\").concat(nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"));\n        return this;\n    }\n    /**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ limit(count) {\n        let { foreignTable, referencedTable = foreignTable } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : \"\".concat(referencedTable, \".limit\");\n        this.url.searchParams.set(key, \"\".concat(count));\n        return this;\n    }\n    /**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ range(from, to) {\n        let { foreignTable, referencedTable = foreignTable } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : \"\".concat(referencedTable, \".offset\");\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : \"\".concat(referencedTable, \".limit\");\n        this.url.searchParams.set(keyOffset, \"\".concat(from));\n        this.url.searchParams.set(keyLimit, \"\".concat(to - from + 1));\n        return this;\n    }\n    /**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/ maybeSingle() {\n        if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n        else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n\t* Return `data` as a string in CSV format.\n\t*/ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/ explain() {\n        let { analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _this$headers$get;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.plan+\".concat(format, '; for=\"').concat(forMediatype, '\"; options=').concat(options, \";\"));\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        return this;\n    }\n    /**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", \"max-affected=\".concat(value));\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n    /**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ eq(column, value) {\n        this.url.searchParams.append(column, \"eq.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ neq(column, value) {\n        this.url.searchParams.append(column, \"neq.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gt(column, value) {\n        this.url.searchParams.append(column, \"gt.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gte(column, value) {\n        this.url.searchParams.append(column, \"gte.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lt(column, value) {\n        this.url.searchParams.append(column, \"lt.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lte(column, value) {\n        this.url.searchParams.append(column, \"lte.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ like(column, pattern) {\n        this.url.searchParams.append(column, \"like.\".concat(pattern));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, \"like(all).{\".concat(patterns.join(\",\"), \"}\"));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, \"like(any).{\".concat(patterns.join(\",\"), \"}\"));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ ilike(column, pattern) {\n        this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, \"ilike(all).{\".concat(patterns.join(\",\"), \"}\"));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, \"ilike(any).{\".concat(patterns.join(\",\"), \"}\"));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexMatch(column, pattern) {\n        this.url.searchParams.append(column, \"match.\".concat(pattern));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexIMatch(column, pattern) {\n        this.url.searchParams.append(column, \"imatch.\".concat(pattern));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ is(column, value) {\n        this.url.searchParams.append(column, \"is.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ isDistinct(column, value) {\n        this.url.searchParams.append(column, \"isdistinct.\".concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return '\"'.concat(s, '\"');\n            else return \"\".concat(s);\n        }).join(\",\");\n        this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ notIn(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return '\"'.concat(s, '\"');\n            else return \"\".concat(s);\n        }).join(\",\");\n        this.url.searchParams.append(column, \"not.in.(\".concat(cleanedValues, \")\"));\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ contains(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, \"cs.\".concat(value));\n        else if (Array.isArray(value)) this.url.searchParams.append(column, \"cs.{\".concat(value.join(\",\"), \"}\"));\n        else this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ containedBy(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, \"cd.\".concat(value));\n        else if (Array.isArray(value)) this.url.searchParams.append(column, \"cd.{\".concat(value.join(\",\"), \"}\"));\n        else this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGt(column, range) {\n        this.url.searchParams.append(column, \"sr.\".concat(range));\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGte(column, range) {\n        this.url.searchParams.append(column, \"nxl.\".concat(range));\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLt(column, range) {\n        this.url.searchParams.append(column, \"sl.\".concat(range));\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLte(column, range) {\n        this.url.searchParams.append(column, \"nxr.\".concat(range));\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, \"adj.\".concat(range));\n        return this;\n    }\n    /**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/ overlaps(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, \"ov.\".concat(value));\n        else this.url.searchParams.append(column, \"ov.{\".concat(value.join(\",\"), \"}\"));\n        return this;\n    }\n    /**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/ textSearch(column, query) {\n        let { config, type } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        let typePart = \"\";\n        if (type === \"plain\") typePart = \"pl\";\n        else if (type === \"phrase\") typePart = \"ph\";\n        else if (type === \"websearch\") typePart = \"w\";\n        const configPart = config === void 0 ? \"\" : \"(\".concat(config, \")\");\n        this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n        return this;\n    }\n    /**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/ match(query) {\n        Object.entries(query).forEach((param)=>{\n            let [column, value] = param;\n            this.url.searchParams.append(column, \"eq.\".concat(value));\n        });\n        return this;\n    }\n    /**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ not(column, operator, value) {\n        this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/ or(filters) {\n        let { foreignTable, referencedTable = foreignTable } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const key = referencedTable ? \"\".concat(referencedTable, \".or\") : \"or\";\n        this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ filter(column, operator, value) {\n        this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n    /**\n\t* Clone URL and headers to prevent shared state between operations.\n\t*/ cloneRequestState() {\n        return {\n            url: new URL(this.url.toString()),\n            headers: new Headers(this.headers)\n        };\n    }\n    /**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @remarks\n\t* When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows\n\t* that match your filters, not the number of rows in the current page. Use this to build pagination UI.\n\t*/ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        const { url, headers } = this.cloneRequestState();\n        url.searchParams.set(\"select\", cleanedColumns);\n        if (count) headers.append(\"Prefer\", \"count=\".concat(count));\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/ insert(values) {\n        let { count, defaultToNull = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _this$fetch;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", \"count=\".concat(count));\n        if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>'\"'.concat(column, '\"'));\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/ upsert(values) {\n        let { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _this$fetch2;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        headers.append(\"Prefer\", \"resolution=\".concat(ignoreDuplicates ? \"ignore\" : \"merge\", \"-duplicates\"));\n        if (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) headers.append(\"Prefer\", \"count=\".concat(count));\n        if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>'\"'.concat(column, '\"'));\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ update(values) {\n        let { count } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _this$fetch3;\n        const method = \"PATCH\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", \"count=\".concat(count));\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ delete() {\n        let { count } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _this$fetch4;\n        const method = \"DELETE\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", \"count=\".concat(count));\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1, urlLengthLimit = 8e3 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch$1;\n        this.urlLengthLimit = urlLengthLimit;\n    }\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/ var PostgrestClient = class PostgrestClient {\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n        return new PostgrestQueryBuilder(new URL(\"\".concat(this.url, \"/\").concat(relation)), {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/ rpc(fn) {\n        let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { head = false, get = false, count } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var _this$fetch;\n        let method;\n        const url = new URL(\"\".concat(this.url, \"/rpc/\").concat(fn));\n        let body;\n        const _isObject = (v)=>v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n        const _hasObjectArg = head && Object.values(args).some(_isObject);\n        if (_hasObjectArg) {\n            method = \"POST\";\n            body = args;\n        } else if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args).filter((param)=>{\n                let [_, value] = param;\n                return value !== void 0;\n            }).map((param)=>{\n                let [name, value] = param;\n                return [\n                    name,\n                    Array.isArray(value) ? \"{\".concat(value.join(\",\"), \"}\") : \"\".concat(value)\n                ];\n            }).forEach((param)=>{\n                let [name, value] = param;\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (_hasObjectArg) headers.set(\"Prefer\", count ? \"count=\".concat(count, \",return=minimal\") : \"return=minimal\");\n        else if (count) headers.set(\"Prefer\", \"count=\".concat(count));\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.\n\t* @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t*   timeout: 30000, // 30 second timeout\n\t* })\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1, timeout, urlLengthLimit = 8e3 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.urlLengthLimit = urlLengthLimit;\n        const originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;\n        if (timeout !== void 0 && timeout > 0) this.fetch = (input, init)=>{\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), timeout);\n            const existingSignal = init === null || init === void 0 ? void 0 : init.signal;\n            if (existingSignal) {\n                if (existingSignal.aborted) {\n                    clearTimeout(timeoutId);\n                    return originalFetch(input, init);\n                }\n                const abortHandler = ()=>{\n                    clearTimeout(timeoutId);\n                    controller.abort();\n                };\n                existingSignal.addEventListener(\"abort\", abortHandler, {\n                    once: true\n                });\n                return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {\n                    signal: controller.signal\n                })).finally(()=>{\n                    clearTimeout(timeoutId);\n                    existingSignal.removeEventListener(\"abort\", abortHandler);\n                });\n            }\n            return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {\n                signal: controller.signal\n            })).finally(()=>clearTimeout(timeoutId));\n        };\n        else this.fetch = originalFetch;\n    }\n};\n//#endregion\n//#region src/index.ts\nvar src_default = {\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0I7Ozs7QUFJQSxHQUNBLElBQUlBLGlCQUFpQixjQUFjQztJQUNsQzs7Ozs7Ozs7Ozs7O0NBWUEsR0FDQUMsWUFBWUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0EsUUFBUUMsT0FBTztRQUNyQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHSCxRQUFRRyxPQUFPO1FBQzlCLElBQUksQ0FBQ0MsSUFBSSxHQUFHSixRQUFRSSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHTCxRQUFRSyxJQUFJO0lBQ3pCO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osaUNBQWlDO0FBQ2pDLElBQUlDLG1CQUFtQjtJQTZCdEI7Ozs7O0NBS0EsR0FDQUMsZUFBZTtRQUNkLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Q0FFQSxHQUNBQyxVQUFVUCxJQUFJLEVBQUVRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyxRQUFRLElBQUksQ0FBQ0QsT0FBTztRQUN2QyxJQUFJLENBQUNBLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDWCxNQUFNUTtRQUN2QixPQUFPLElBQUk7SUFDWjtJQUNBSSxLQUFLQyxXQUFXLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixJQUFJQyxRQUFRLElBQUk7UUFDaEIsSUFBSSxJQUFJLENBQUNDLE1BQU0sS0FBSyxLQUFLLEdBQUcsQ0FBQyxPQUFPLElBQUk7WUFBQztZQUFPO1NBQU8sQ0FBQ0MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ1QsT0FBTyxDQUFDRSxHQUFHLENBQUMsa0JBQWtCLElBQUksQ0FBQ0ssTUFBTTthQUN4SCxJ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QUNBQyxlQUFlSSxnQkFBZ0IsQ0FBQyxTQUFTRCxjQUFjO29CQUFFRSxNQUFNO2dCQUFLO2dCQUNwRSxPQUFPZCxjQUFjRSxPQUFPbkIsZUFBZUEsZUFBZSxDQUFDLEdBQUdvQixPQUFPLENBQUMsR0FBRztvQkFBRTlNLFFBQVErTSxXQUFXL00sTUFBTTtnQkFBQyxJQUFJME4sT0FBTyxDQUFDO29CQUNoSEosYUFBYUw7b0JBQ2JHLGVBQWVPLG1CQUFtQixDQUFDLFNBQVNKO2dCQUM3QztZQUNEO1lBQ0EsT0FBT1osY0FBY0UsT0FBT25CLGVBQWVBLGVBQWUsQ0FBQyxHQUFHb0IsT0FBTyxDQUFDLEdBQUc7Z0JBQUU5TSxRQUFRK00sV0FBVy9NLE1BQU07WUFBQyxJQUFJME4sT0FBTyxDQUFDLElBQU1KLGFBQWFMO1FBQ3JJO2FBQ0ssSUFBSSxDQUFDeE4sS0FBSyxHQUFHa047SUFDbkI7QUE4RkQ7QUFFQSxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLElBQUlpQixjQUFjO0lBQ2pCOUI7SUFDQXJEO0lBQ0E5QztJQUNBN0M7SUFDQXJFO0lBQ0FUO0FBQ0Q7QUFFQSxZQUFZO0FBQ21KLENBQy9KLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4Lm1qcz83YWMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0RXJyb3IudHNcbi8qKlxuKiBFcnJvciBmb3JtYXRcbipcbioge0BsaW5rIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWw/aGlnaGxpZ2h0PW9wdGlvbnMjZXJyb3JzLWFuZC1odHRwLXN0YXR1cy1jb2Rlc31cbiovXG52YXIgUG9zdGdyZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0LyoqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RFcnJvciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKHtcblx0KiAgIG1lc3NhZ2U6ICdSb3cgbGV2ZWwgc2VjdXJpdHkgcHJldmVudGVkIHRoZSByZXF1ZXN0Jyxcblx0KiAgIGRldGFpbHM6ICdSTFMgZGVuaWVkIHRoZSBpbnNlcnQnLFxuXHQqICAgaGludDogJ0NoZWNrIHlvdXIgcG9saWNpZXMnLFxuXHQqICAgY29kZTogJ1BHUlNUMzAxJyxcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG5cdFx0c3VwZXIoY29udGV4dC5tZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlBvc3RncmVzdEVycm9yXCI7XG5cdFx0dGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuXHRcdHRoaXMuaGludCA9IGNvbnRleHQuaGludDtcblx0XHR0aGlzLmNvZGUgPSBjb250ZXh0LmNvZGU7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0QnVpbGRlciA9IGNsYXNzIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIGJ1aWxkZXIgY29uZmlndXJlZCBmb3IgYSBzcGVjaWZpYyBQb3N0Z1JFU1QgcmVxdWVzdC5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiBjb25zdCBidWlsZGVyID0gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihcblx0KiAgIG5ldyBVUkwoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxL3VzZXJzJyksXG5cdCogICB7IGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9KSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG5cdFx0dmFyIF9idWlsZGVyJHNob3VsZFRocm93TywgX2J1aWxkZXIkaXNNYXliZVNpbmdsLCBfYnVpbGRlciR1cmxMZW5ndGhMaW07XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kO1xuXHRcdHRoaXMudXJsID0gYnVpbGRlci51cmw7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoYnVpbGRlci5oZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuc2NoZW1hO1xuXHRcdHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keTtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IChfYnVpbGRlciRzaG91bGRUaHJvd08gPSBidWlsZGVyLnNob3VsZFRocm93T25FcnJvcikgIT09IG51bGwgJiYgX2J1aWxkZXIkc2hvdWxkVGhyb3dPICE9PSB2b2lkIDAgPyBfYnVpbGRlciRzaG91bGRUaHJvd08gOiBmYWxzZTtcblx0XHR0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuXHRcdHRoaXMuaXNNYXliZVNpbmdsZSA9IChfYnVpbGRlciRpc01heWJlU2luZ2wgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGUpICE9PSBudWxsICYmIF9idWlsZGVyJGlzTWF5YmVTaW5nbCAhPT0gdm9pZCAwID8gX2J1aWxkZXIkaXNNYXliZVNpbmdsIDogZmFsc2U7XG5cdFx0dGhpcy51cmxMZW5ndGhMaW1pdCA9IChfYnVpbGRlciR1cmxMZW5ndGhMaW0gPSBidWlsZGVyLnVybExlbmd0aExpbWl0KSAhPT0gbnVsbCAmJiBfYnVpbGRlciR1cmxMZW5ndGhMaW0gIT09IHZvaWQgMCA/IF9idWlsZGVyJHVybExlbmd0aExpbSA6IDhlMztcblx0XHRpZiAoYnVpbGRlci5mZXRjaCkgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG5cdFx0ZWxzZSB0aGlzLmZldGNoID0gZmV0Y2g7XG5cdH1cblx0LyoqXG5cdCogSWYgdGhlcmUncyBhbiBlcnJvciB3aXRoIHRoZSBxdWVyeSwgdGhyb3dPbkVycm9yIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIGJ5XG5cdCogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuXHQqXG5cdCoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS1qcy9pc3N1ZXMvOTJ9XG5cdCovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IGFuIEhUVFAgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cblx0Ki9cblx0c2V0SGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRpZiAodGhpcy5zY2hlbWEgPT09IHZvaWQgMCkge30gZWxzZSBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHQtUHJvZmlsZVwiLCB0aGlzLnNjaGVtYSk7XG5cdFx0ZWxzZSB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1Qcm9maWxlXCIsIHRoaXMuc2NoZW1hKTtcblx0XHRpZiAodGhpcy5tZXRob2QgIT09IFwiR0VUXCIgJiYgdGhpcy5tZXRob2QgIT09IFwiSEVBRFwiKSB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoO1xuXHRcdGxldCByZXMgPSBfZmV0Y2godGhpcy51cmwudG9TdHJpbmcoKSwge1xuXHRcdFx0bWV0aG9kOiB0aGlzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSksXG5cdFx0XHRzaWduYWw6IHRoaXMuc2lnbmFsXG5cdFx0fSkudGhlbihhc3luYyAocmVzJDEpID0+IHtcblx0XHRcdGxldCBlcnJvciA9IG51bGw7XG5cdFx0XHRsZXQgZGF0YSA9IG51bGw7XG5cdFx0XHRsZXQgY291bnQgPSBudWxsO1xuXHRcdFx0bGV0IHN0YXR1cyA9IHJlcyQxLnN0YXR1cztcblx0XHRcdGxldCBzdGF0dXNUZXh0ID0gcmVzJDEuc3RhdHVzVGV4dDtcblx0XHRcdGlmIChyZXMkMS5vaykge1xuXHRcdFx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQyLCBfcmVzJGhlYWRlcnMkZ2V0O1xuXHRcdFx0XHRpZiAoX3RoaXMubWV0aG9kICE9PSBcIkhFQURcIikge1xuXHRcdFx0XHRcdHZhciBfdGhpcyRoZWFkZXJzJGdldDtcblx0XHRcdFx0XHRjb25zdCBib2R5ID0gYXdhaXQgcmVzJDEudGV4dCgpO1xuXHRcdFx0XHRcdGlmIChib2R5ID09PSBcIlwiKSB7fSBlbHNlIGlmIChfdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSA9PT0gXCJ0ZXh0L2NzdlwiKSBkYXRhID0gYm9keTtcblx0XHRcdFx0XHRlbHNlIGlmIChfdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSAmJiAoKF90aGlzJGhlYWRlcnMkZ2V0ID0gX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikpID09PSBudWxsIHx8IF90aGlzJGhlYWRlcnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRoZWFkZXJzJGdldC5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5wbGFuK3RleHRcIikpKSBkYXRhID0gYm9keTtcblx0XHRcdFx0XHRlbHNlIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGNvdW50SGVhZGVyID0gKF90aGlzJGhlYWRlcnMkZ2V0MiA9IF90aGlzLmhlYWRlcnMuZ2V0KFwiUHJlZmVyXCIpKSA9PT0gbnVsbCB8fCBfdGhpcyRoZWFkZXJzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGhlYWRlcnMkZ2V0Mi5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pO1xuXHRcdFx0XHRjb25zdCBjb250ZW50UmFuZ2UgPSAoX3JlcyRoZWFkZXJzJGdldCA9IHJlcyQxLmhlYWRlcnMuZ2V0KFwiY29udGVudC1yYW5nZVwiKSkgPT09IG51bGwgfHwgX3JlcyRoZWFkZXJzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRoZWFkZXJzJGdldC5zcGxpdChcIi9cIik7XG5cdFx0XHRcdGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIGNvdW50ID0gcGFyc2VJbnQoY29udGVudFJhbmdlWzFdKTtcblx0XHRcdFx0aWYgKF90aGlzLmlzTWF5YmVTaW5nbGUgJiYgX3RoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRlcnJvciA9IHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiUEdSU1QxMTZcIixcblx0XHRcdFx0XHRcdGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcblx0XHRcdFx0XHRcdGhpbnQ6IG51bGwsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBcIkpTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0XHRcdGNvdW50ID0gbnVsbDtcblx0XHRcdFx0XHRzdGF0dXMgPSA0MDY7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiTm90IEFjY2VwdGFibGVcIjtcblx0XHRcdFx0fSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkgZGF0YSA9IGRhdGFbMF07XG5cdFx0XHRcdGVsc2UgZGF0YSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgX2Vycm9yJGRldGFpbHM7XG5cdFx0XHRcdGNvbnN0IGJvZHkgPSBhd2FpdCByZXMkMS50ZXh0KCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGVycm9yKSAmJiByZXMkMS5zdGF0dXMgPT09IDQwNCkge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IFtdO1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSBudWxsO1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMjAwO1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiT0tcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKF91bnVzZWQpIHtcblx0XHRcdFx0XHRpZiAocmVzJDEuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMjA0O1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiTm8gQ29udGVudFwiO1xuXHRcdFx0XHRcdH0gZWxzZSBlcnJvciA9IHsgbWVzc2FnZTogYm9keSB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcnJvciAmJiBfdGhpcy5pc01heWJlU2luZ2xlICYmIChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwIHx8IChfZXJyb3IkZGV0YWlscyA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9lcnJvciRkZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IkZGV0YWlscy5pbmNsdWRlcyhcIjAgcm93c1wiKSkpIHtcblx0XHRcdFx0XHRlcnJvciA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdHVzID0gMjAwO1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk9LXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVycm9yICYmIF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKGVycm9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdFx0c3RhdHVzLFxuXHRcdFx0XHRzdGF0dXNUZXh0XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuXHRcdFx0dmFyIF9mZXRjaEVycm9yJG5hbWUyO1xuXHRcdFx0bGV0IGVycm9yRGV0YWlscyA9IFwiXCI7XG5cdFx0XHRsZXQgaGludCA9IFwiXCI7XG5cdFx0XHRsZXQgY29kZSA9IFwiXCI7XG5cdFx0XHRjb25zdCBjYXVzZSA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5jYXVzZTtcblx0XHRcdGlmIChjYXVzZSkge1xuXHRcdFx0XHR2YXIgX2NhdXNlJG1lc3NhZ2UsIF9jYXVzZSRjb2RlLCBfZmV0Y2hFcnJvciRuYW1lLCBfY2F1c2UkbmFtZTtcblx0XHRcdFx0Y29uc3QgY2F1c2VNZXNzYWdlID0gKF9jYXVzZSRtZXNzYWdlID0gY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jYXVzZSRtZXNzYWdlICE9PSB2b2lkIDAgPyBfY2F1c2UkbWVzc2FnZSA6IFwiXCI7XG5cdFx0XHRcdGNvbnN0IGNhdXNlQ29kZSA9IChfY2F1c2UkY29kZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5jb2RlKSAhPT0gbnVsbCAmJiBfY2F1c2UkY29kZSAhPT0gdm9pZCAwID8gX2NhdXNlJGNvZGUgOiBcIlwiO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgPSBgJHsoX2ZldGNoRXJyb3IkbmFtZSA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5uYW1lKSAhPT0gbnVsbCAmJiBfZmV0Y2hFcnJvciRuYW1lICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRuYW1lIDogXCJGZXRjaEVycm9yXCJ9OiAke2ZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5tZXNzYWdlfWA7XG5cdFx0XHRcdGVycm9yRGV0YWlscyArPSBgXFxuXFxuQ2F1c2VkIGJ5OiAkeyhfY2F1c2UkbmFtZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5uYW1lKSAhPT0gbnVsbCAmJiBfY2F1c2UkbmFtZSAhPT0gdm9pZCAwID8gX2NhdXNlJG5hbWUgOiBcIkVycm9yXCJ9OiAke2NhdXNlTWVzc2FnZX1gO1xuXHRcdFx0XHRpZiAoY2F1c2VDb2RlKSBlcnJvckRldGFpbHMgKz0gYCAoJHtjYXVzZUNvZGV9KWA7XG5cdFx0XHRcdGlmIChjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2Uuc3RhY2spIGVycm9yRGV0YWlscyArPSBgXFxuJHtjYXVzZS5zdGFja31gO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIF9mZXRjaEVycm9yJHN0YWNrO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgPSAoX2ZldGNoRXJyb3Ikc3RhY2sgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3Iuc3RhY2spICE9PSBudWxsICYmIF9mZXRjaEVycm9yJHN0YWNrICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRzdGFjayA6IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB1cmxMZW5ndGggPSB0aGlzLnVybC50b1N0cmluZygpLmxlbmd0aDtcblx0XHRcdGlmICgoZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIiB8fCAoZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLmNvZGUpID09PSBcIkFCT1JUX0VSUlwiKSB7XG5cdFx0XHRcdGNvZGUgPSBcIlwiO1xuXHRcdFx0XHRoaW50ID0gXCJSZXF1ZXN0IHdhcyBhYm9ydGVkICh0aW1lb3V0IG9yIG1hbnVhbCBjYW5jZWxsYXRpb24pXCI7XG5cdFx0XHRcdGlmICh1cmxMZW5ndGggPiB0aGlzLnVybExlbmd0aExpbWl0KSBoaW50ICs9IGAuIE5vdGU6IFlvdXIgcmVxdWVzdCBVUkwgaXMgJHt1cmxMZW5ndGh9IGNoYXJhY3RlcnMsIHdoaWNoIG1heSBleGNlZWQgc2VydmVyIGxpbWl0cy4gSWYgc2VsZWN0aW5nIG1hbnkgZmllbGRzLCBjb25zaWRlciB1c2luZyB2aWV3cy4gSWYgZmlsdGVyaW5nIHdpdGggbGFyZ2UgYXJyYXlzIChlLmcuLCAuaW4oJ2lkJywgW21hbnkgSURzXSkpLCBjb25zaWRlciB1c2luZyBhbiBSUEMgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgc2VydmVyLXNpZGUuYDtcblx0XHRcdH0gZWxzZSBpZiAoKGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5uYW1lKSA9PT0gXCJIZWFkZXJzT3ZlcmZsb3dFcnJvclwiIHx8IChjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UuY29kZSkgPT09IFwiVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XXCIpIHtcblx0XHRcdFx0Y29kZSA9IFwiXCI7XG5cdFx0XHRcdGhpbnQgPSBcIkhUVFAgaGVhZGVycyBleGNlZWRlZCBzZXJ2ZXIgbGltaXRzICh0eXBpY2FsbHkgMTZLQilcIjtcblx0XHRcdFx0aWYgKHVybExlbmd0aCA+IHRoaXMudXJsTGVuZ3RoTGltaXQpIGhpbnQgKz0gYC4gWW91ciByZXF1ZXN0IFVSTCBpcyAke3VybExlbmd0aH0gY2hhcmFjdGVycy4gSWYgc2VsZWN0aW5nIG1hbnkgZmllbGRzLCBjb25zaWRlciB1c2luZyB2aWV3cy4gSWYgZmlsdGVyaW5nIHdpdGggbGFyZ2UgYXJyYXlzIChlLmcuLCAuaW4oJ2lkJywgWzIwMCsgSURzXSkpLCBjb25zaWRlciB1c2luZyBhbiBSUEMgZnVuY3Rpb24gaW5zdGVhZC5gO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXJyb3I6IHtcblx0XHRcdFx0XHRtZXNzYWdlOiBgJHsoX2ZldGNoRXJyb3IkbmFtZTIgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2ZldGNoRXJyb3IkbmFtZTIgIT09IHZvaWQgMCA/IF9mZXRjaEVycm9yJG5hbWUyIDogXCJGZXRjaEVycm9yXCJ9OiAke2ZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5tZXNzYWdlfWAsXG5cdFx0XHRcdFx0ZGV0YWlsczogZXJyb3JEZXRhaWxzLFxuXHRcdFx0XHRcdGhpbnQsXG5cdFx0XHRcdFx0Y29kZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRjb3VudDogbnVsbCxcblx0XHRcdFx0c3RhdHVzOiAwLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiBcIlwiXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG5cdH1cblx0LyoqXG5cdCogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cblx0KlxuXHQqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG5cdCogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcblx0Ki9cblx0cmV0dXJucygpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAgZmllbGQgaW4gdGhlIHJlc3BvbnNlLlxuXHQqXG5cdCogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHR5cGUgdG8gY2FzdCB0aGUgcmVzcG9uc2UgZGF0YSB0b1xuXHQqIEB0eXBlUGFyYW0gT3B0aW9ucyAtIE9wdGlvbmFsIHR5cGUgY29uZmlndXJhdGlvbiAoZGVmYXVsdHMgdG8geyBtZXJnZTogdHJ1ZSB9KVxuXHQqIEB0eXBlUGFyYW0gT3B0aW9ucy5tZXJnZSAtIFdoZW4gdHJ1ZSwgbWVyZ2VzIHRoZSBuZXcgdHlwZSB3aXRoIGV4aXN0aW5nIHJldHVybiB0eXBlLiBXaGVuIGZhbHNlLCByZXBsYWNlcyB0aGUgZXhpc3RpbmcgdHlwZXMgZW50aXJlbHkgKGRlZmF1bHRzIHRvIHRydWUpXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyB0eXBlcyAoZGVmYXVsdCBiZWhhdmlvcilcblx0KiBjb25zdCBxdWVyeSA9IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnNlbGVjdCgpXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGN1c3RvbV9maWVsZDogc3RyaW5nIH0+KClcblx0KlxuXHQqIC8vIFJlcGxhY2UgZXhpc3RpbmcgdHlwZXMgY29tcGxldGVseVxuXHQqIGNvbnN0IHJlcGxhY2VRdWVyeSA9IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnNlbGVjdCgpXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9LCB7IG1lcmdlOiBmYWxzZSB9PigpXG5cdCogYGBgXG5cdCogQHJldHVybnMgQSBQb3N0Z3Jlc3RCdWlsZGVyIGluc3RhbmNlIHdpdGggdGhlIG5ldyB0eXBlXG5cdCovXG5cdG92ZXJyaWRlVHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlciB7XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGAuaW5zZXJ0KClgLCBgLnVwZGF0ZSgpYCwgYC51cHNlcnQoKWAsIGFuZCBgLmRlbGV0ZSgpYCBkbyBub3Rcblx0KiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cblx0KiBgZGF0YWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG5cdCovXG5cdHNlbGVjdChjb2x1bW5zKSB7XG5cdFx0bGV0IHF1b3RlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6IFwiKlwiKS5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHtcblx0XHRcdGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHJldHVybiBcIlwiO1xuXHRcdFx0aWYgKGMgPT09IFwiXFxcIlwiKSBxdW90ZWQgPSAhcXVvdGVkO1xuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSkuam9pbihcIlwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2VsZWN0XCIsIGNsZWFuZWRDb2x1bW5zKTtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIFwicmV0dXJuPXJlcHJlc2VudGF0aW9uXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG5cdCpcblx0KiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgdG8gb3JkZXIgYnkgbXVsdGlwbGUgY29sdW1ucy5cblx0KlxuXHQqIFlvdSBjYW4gb3JkZXIgcmVmZXJlbmNlZCB0YWJsZXMsIGJ1dCBpdCBvbmx5IGFmZmVjdHMgdGhlIG9yZGVyaW5nIG9mIHRoZVxuXHQqIHBhcmVudCB0YWJsZSBpZiB5b3UgdXNlIGAhaW5uZXJgIGluIHRoZSBxdWVyeS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIG9yZGVyIGJ5XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG5cdCogQHBhcmFtIG9wdGlvbnMubnVsbHNGaXJzdCAtIElmIGB0cnVlYCwgYG51bGxgcyBhcHBlYXIgZmlyc3QuIElmIGBmYWxzZWAsXG5cdCogYG51bGxgcyBhcHBlYXIgbGFzdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcblx0KiBpdHMgY29sdW1uc1xuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG5cdCogaW5zdGVhZFxuXHQqL1xuXHRvcmRlcihjb2x1bW4sIHsgYXNjZW5kaW5nID0gdHJ1ZSwgbnVsbHNGaXJzdCwgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiBcIm9yZGVyXCI7XG5cdFx0Y29uc3QgZXhpc3RpbmdPcmRlciA9IHRoaXMudXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7ZXhpc3RpbmdPcmRlciA/IGAke2V4aXN0aW5nT3JkZXJ9LGAgOiBcIlwifSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/IFwiYXNjXCIgOiBcImRlc2NcIn0ke251bGxzRmlyc3QgPT09IHZvaWQgMCA/IFwiXCIgOiBudWxsc0ZpcnN0ID8gXCIubnVsbHNmaXJzdFwiIDogXCIubnVsbHNsYXN0XCJ9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuXHQqXG5cdCogQHBhcmFtIGNvdW50IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG5cdCogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG5cdCogaW5zdGVhZFxuXHQqL1xuXHRsaW1pdChjb3VudCwgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXkgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSBcInVuZGVmaW5lZFwiID8gXCJsaW1pdFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgc3RhcnRpbmcgYXQgYW4gb2Zmc2V0IGBmcm9tYCBhbmQgZW5kaW5nIGF0IHRoZSBvZmZzZXQgYHRvYC5cblx0KiBPbmx5IHJlY29yZHMgd2l0aGluIHRoaXMgcmFuZ2UgYXJlIHJldHVybmVkLlxuXHQqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG5cdCogVGhlIGBmcm9tYCBhbmQgYHRvYCB2YWx1ZXMgYXJlIDAtYmFzZWQgYW5kIGluY2x1c2l2ZTogYHJhbmdlKDEsIDMpYCB3aWxsIGluY2x1ZGUgdGhlIHNlY29uZCwgdGhpcmRcblx0KiBhbmQgZm91cnRoIHJvd3Mgb2YgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG5cdCogQHBhcmFtIHRvIC0gVGhlIGxhc3QgaW5kZXggdG8gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuXHQqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0cmFuZ2UoZnJvbSwgdG8sIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5T2Zmc2V0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwib2Zmc2V0XCIgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGA7XG5cdFx0Y29uc3Qga2V5TGltaXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSBcInVuZGVmaW5lZFwiID8gXCJsaW1pdFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YCk7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cblx0KlxuXHQqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuXHQqL1xuXHRhYm9ydFNpZ25hbChzaWduYWwpIHtcblx0XHR0aGlzLnNpZ25hbCA9IHNpZ25hbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG5cdCpcblx0KiBRdWVyeSByZXN1bHQgbXVzdCBiZSBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlIHRoaXNcblx0KiByZXR1cm5zIGFuIGVycm9yLlxuXHQqL1xuXHRzaW5nbGUoKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG5cdCpcblx0KiBRdWVyeSByZXN1bHQgbXVzdCBiZSB6ZXJvIG9yIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2Vcblx0KiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG5cdCovXG5cdG1heWJlU2luZ2xlKCkge1xuXHRcdGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikgdGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0ZWxzZSB0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uXCIpO1xuXHRcdHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuXHQqL1xuXHRjc3YoKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcInRleHQvY3N2XCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYW4gb2JqZWN0IGluIFtHZW9KU09OXShodHRwczovL2dlb2pzb24ub3JnKSBmb3JtYXQuXG5cdCovXG5cdGdlb2pzb24oKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2dlbytqc29uXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogWW91IG5lZWQgdG8gZW5hYmxlIHRoZVxuXHQqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuXHQqIHNldHRpbmcgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG5cdCogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcblx0KiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG5cdCogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2Vcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG5cdCogb3IgYFwianNvblwiYFxuXHQqL1xuXHRleHBsYWluKHsgYW5hbHl6ZSA9IGZhbHNlLCB2ZXJib3NlID0gZmFsc2UsIHNldHRpbmdzID0gZmFsc2UsIGJ1ZmZlcnMgPSBmYWxzZSwgd2FsID0gZmFsc2UsIGZvcm1hdCA9IFwidGV4dFwiIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRoZWFkZXJzJGdldDtcblx0XHRjb25zdCBvcHRpb25zID0gW1xuXHRcdFx0YW5hbHl6ZSA/IFwiYW5hbHl6ZVwiIDogbnVsbCxcblx0XHRcdHZlcmJvc2UgPyBcInZlcmJvc2VcIiA6IG51bGwsXG5cdFx0XHRzZXR0aW5ncyA/IFwic2V0dGluZ3NcIiA6IG51bGwsXG5cdFx0XHRidWZmZXJzID8gXCJidWZmZXJzXCIgOiBudWxsLFxuXHRcdFx0d2FsID8gXCJ3YWxcIiA6IG51bGxcblx0XHRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwifFwiKTtcblx0XHRjb25zdCBmb3JNZWRpYXR5cGUgPSAoX3RoaXMkaGVhZGVycyRnZXQgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpKSAhPT0gbnVsbCAmJiBfdGhpcyRoZWFkZXJzJGdldCAhPT0gdm9pZCAwID8gX3RoaXMkaGVhZGVycyRnZXQgOiBcImFwcGxpY2F0aW9uL2pzb25cIjtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YCk7XG5cdFx0aWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHJldHVybiB0aGlzO1xuXHRcdGVsc2UgcmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUm9sbGJhY2sgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogYGRhdGFgIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGJ1dCB0aGUgcXVlcnkgaXMgbm90IGNvbW1pdHRlZC5cblx0Ki9cblx0cm9sbGJhY2soKSB7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcInR4PXJvbGxiYWNrXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG5cdCpcblx0KiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuXHQqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG5cdCovXG5cdHJldHVybnMoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRoYXQgY2FuIGJlIGFmZmVjdGVkIGJ5IHRoZSBxdWVyeS5cblx0KiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z1JFU1QgdjEzKyBhbmQgb25seSB3b3JrcyB3aXRoIFBBVENIIGFuZCBERUxFVEUgbWV0aG9kcy5cblx0KlxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRoYXQgY2FuIGJlIGFmZmVjdGVkXG5cdCovXG5cdG1heEFmZmVjdGVkKHZhbHVlKSB7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcImhhbmRsaW5nPXN0cmljdFwiKTtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBtYXgtYWZmZWN0ZWQ9JHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIudHNcbmNvbnN0IFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChcIlssKCldXCIpO1xudmFyIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIge1xuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0ZXEoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bmVxKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRndChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRndGUoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGx0KGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGx0ZShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZS4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGxpa2VBbGxPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0aWxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyB0aGUgUG9zdGdyZVNRTCByZWdleCBgcGF0dGVybmBcblx0KiBjYXNlLXNlbnNpdGl2ZWx5ICh1c2luZyB0aGUgYH5gIG9wZXJhdG9yKS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIFBvc3RncmVTUUwgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRyZWdleE1hdGNoKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbWF0Y2guJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIHRoZSBQb3N0Z3JlU1FMIHJlZ2V4IGBwYXR0ZXJuYFxuXHQqIGNhc2UtaW5zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+KmAgb3BlcmF0b3IpLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgUG9zdGdyZVNRTCByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdHJlZ2V4SU1hdGNoKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW1hdGNoLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgYHZhbHVlYC5cblx0KlxuXHQqIEZvciBub24tYm9vbGVhbiBjb2x1bW5zLCB0aGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBvZlxuXHQqIGBjb2x1bW5gIGlzIE5VTEwgYnkgc2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYC5cblx0KlxuXHQqIEZvciBib29sZWFuIGNvbHVtbnMsIHlvdSBjYW4gYWxzbyBzZXQgYHZhbHVlYCB0byBgdHJ1ZWAgb3IgYGZhbHNlYCBhbmQgaXRcblx0KiB3aWxsIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYC5lcSgpYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRpcyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBESVNUSU5DVCBGUk9NIGB2YWx1ZWAuXG5cdCpcblx0KiBVbmxpa2UgYC5uZXEoKWAsIHRoaXMgdHJlYXRzIGBOVUxMYCBhcyBhIGNvbXBhcmFibGUgdmFsdWUuIFR3byBgTlVMTGAgdmFsdWVzXG5cdCogYXJlIGNvbnNpZGVyZWQgZXF1YWwgKG5vdCBkaXN0aW5jdCksIGFuZCBjb21wYXJpbmcgYE5VTExgIHdpdGggYW55IG5vbi1OVUxMXG5cdCogdmFsdWUgcmV0dXJucyB0cnVlIChkaXN0aW5jdCkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0aXNEaXN0aW5jdChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpc2Rpc3RpbmN0LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGluKGNvbHVtbiwgdmFsdWVzKSB7XG5cdFx0Y29uc3QgY2xlYW5lZFZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpKS5tYXAoKHMpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgO1xuXHRcdFx0ZWxzZSByZXR1cm4gYCR7c31gO1xuXHRcdH0pLmpvaW4oXCIsXCIpO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIE5PVCBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRub3RJbihjb2x1bW4sIHZhbHVlcykge1xuXHRcdGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSkubWFwKChzKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cC50ZXN0KHMpKSByZXR1cm4gYFwiJHtzfVwiYDtcblx0XHRcdGVsc2UgcmV0dXJuIGAke3N9YDtcblx0XHR9KS5qb2luKFwiLFwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC5pbi4oJHtjbGVhbmVkVmFsdWVzfSlgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRjb250YWlucyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRlbHNlIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGNvbnRhaW5lZEJ5KGNvbHVtbiwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YCk7XG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QueyR7dmFsdWUuam9pbihcIixcIil9fWApO1xuXHRcdGVsc2UgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlR3QoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cblx0KiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlR3RlKGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VMdChjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzbC4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuXHQqIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VMdGUoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG5cdCogbXV0dWFsbHkgZXhjbHVzaXZlIHRvIGByYW5nZWAgYW5kIHRoZXJlIGNhbiBiZSBubyBlbGVtZW50IGJldHdlZW4gdGhlIHR3b1xuXHQqIHJhbmdlcy5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUFkamFjZW50KGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGFkai4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIGFycmF5IGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBhcnJheSBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YCk7XG5cdFx0ZWxzZSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuXHQqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcblx0Ki9cblx0dGV4dFNlYXJjaChjb2x1bW4sIHF1ZXJ5LCB7IGNvbmZpZywgdHlwZSB9ID0ge30pIHtcblx0XHRsZXQgdHlwZVBhcnQgPSBcIlwiO1xuXHRcdGlmICh0eXBlID09PSBcInBsYWluXCIpIHR5cGVQYXJ0ID0gXCJwbFwiO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwicGhyYXNlXCIpIHR5cGVQYXJ0ID0gXCJwaFwiO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwid2Vic2VhcmNoXCIpIHR5cGVQYXJ0ID0gXCJ3XCI7XG5cdFx0Y29uc3QgY29uZmlnUGFydCA9IGNvbmZpZyA9PT0gdm9pZCAwID8gXCJcIiA6IGAoJHtjb25maWd9KWA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke3R5cGVQYXJ0fWZ0cyR7Y29uZmlnUGFydH0uJHtxdWVyeX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuXHQqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG5cdCpcblx0KiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuXHQqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcblx0Ki9cblx0bWF0Y2gocXVlcnkpIHtcblx0XHRPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG5cdFx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuXHQqXG5cdCogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cblx0KiBmb2xsb3cgW1Bvc3RnUkVTVFxuXHQqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG5cdCogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcblx0KiBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqL1xuXHRub3QoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBmaWx0ZXJzYCBpcyB1c2VkIGFzLWlzIGFuZCBuZWVkcyB0byBmb2xsb3cgW1Bvc3RnUkVTVFxuXHQqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG5cdCogdG8gbWFrZSBzdXJlIGl0J3MgcHJvcGVybHkgc2FuaXRpemVkLlxuXHQqXG5cdCogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG5cdCpcblx0KiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIHVzZSwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBmaWx0ZXIgb24gcmVmZXJlbmNlZCB0YWJsZXNcblx0KiBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuXHQqL1xuXHRvcihmaWx0ZXJzLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogXCJvclwiO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgKCR7ZmlsdGVyc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgdGhlIGZpbHRlci4gVGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggLSB5b3Vcblx0KiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG5cdCogZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqL1xuXHRmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7b3BlcmF0b3J9LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHNcbnZhciBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBxdWVyeSBidWlsZGVyIHNjb3BlZCB0byBhIFBvc3RncmVzIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgcXVlcnkgPSBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKFxuXHQqICAgbmV3IFVSTCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3Jlc3QvdjEvdXNlcnMnKSxcblx0KiAgIHsgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0gfVxuXHQqIClcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCB7IGhlYWRlcnMgPSB7fSwgc2NoZW1hLCBmZXRjaDogZmV0Y2gkMSwgdXJsTGVuZ3RoTGltaXQgPSA4ZTMgfSkge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuXHRcdHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXHRcdHRoaXMuZmV0Y2ggPSBmZXRjaCQxO1xuXHRcdHRoaXMudXJsTGVuZ3RoTGltaXQgPSB1cmxMZW5ndGhMaW1pdDtcblx0fVxuXHQvKipcblx0KiBDbG9uZSBVUkwgYW5kIGhlYWRlcnMgdG8gcHJldmVudCBzaGFyZWQgc3RhdGUgYmV0d2VlbiBvcGVyYXRpb25zLlxuXHQqL1xuXHRjbG9uZVJlcXVlc3RTdGF0ZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJsOiBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCkpLFxuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKVxuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIFNFTEVDVCBxdWVyeSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyBpbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCpcblx0KiBAcmVtYXJrc1xuXHQqIFdoZW4gdXNpbmcgYGNvdW50YCB3aXRoIGAucmFuZ2UoKWAgb3IgYC5saW1pdCgpYCwgdGhlIHJldHVybmVkIGBjb3VudGAgaXMgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzXG5cdCogdGhhdCBtYXRjaCB5b3VyIGZpbHRlcnMsIG5vdCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGN1cnJlbnQgcGFnZS4gVXNlIHRoaXMgdG8gYnVpbGQgcGFnaW5hdGlvbiBVSS5cblx0Ki9cblx0c2VsZWN0KGNvbHVtbnMsIG9wdGlvbnMpIHtcblx0XHRjb25zdCB7IGhlYWQgPSBmYWxzZSwgY291bnQgfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuXHRcdGNvbnN0IG1ldGhvZCA9IGhlYWQgPyBcIkhFQURcIiA6IFwiR0VUXCI7XG5cdFx0bGV0IHF1b3RlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6IFwiKlwiKS5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHtcblx0XHRcdGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHJldHVybiBcIlwiO1xuXHRcdFx0aWYgKGMgPT09IFwiXFxcIlwiKSBxdW90ZWQgPSAhcXVvdGVkO1xuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSkuam9pbihcIlwiKTtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2VsZWN0XCIsIGNsZWFuZWRDb2x1bW5zKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoLFxuXHRcdFx0dXJsTGVuZ3RoTGltaXQ6IHRoaXMudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYC5cblx0KlxuXHQqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuXHQqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cblx0KiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG5cdCogaW5zZXJ0cy5cblx0Ki9cblx0aW5zZXJ0KHZhbHVlcywgeyBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoO1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuXHRcdGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSB0aGlzLmNsb25lUmVxdWVzdFN0YXRlKCk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRpZiAoIWRlZmF1bHRUb051bGwpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBtaXNzaW5nPWRlZmF1bHRgKTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHRjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10pO1xuXHRcdFx0aWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcImNvbHVtbnNcIiwgdW5pcXVlQ29sdW1ucy5qb2luKFwiLFwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGJvZHk6IHZhbHVlcyxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2ggPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaCAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2ggOiBmZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuXHQqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG5cdCogYC5pbnNlcnQoKWAgaWYgYSByb3cgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb25Db25mbGljdGAgY29sdW1ucyBkb2Vzbid0XG5cdCogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuXHQqIGBpZ25vcmVEdXBsaWNhdGVzYC5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcblx0KiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5vbkNvbmZsaWN0IC0gQ29tbWEtc2VwYXJhdGVkIFVOSVFVRSBjb2x1bW4ocykgdG8gc3BlY2lmeSBob3dcblx0KiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuXHQqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuXHQqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cblx0KiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG5cdCogYGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlYC4gVGhpcyBhbHNvIG9ubHkgYXBwbGllcyB3aGVuIGRvaW5nIGJ1bGsgdXBzZXJ0cy5cblx0KlxuXHQqIEBleGFtcGxlIFVwc2VydCBhIHNpbmdsZSByb3cgdXNpbmcgYSB1bmlxdWUga2V5XG5cdCogYGBgdHNcblx0KiAvLyBVcHNlcnRpbmcgYSBzaW5nbGUgcm93LCBvdmVyd3JpdGluZyBiYXNlZCBvbiB0aGUgJ3VzZXJuYW1lJyB1bmlxdWUgY29sdW1uXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAudXBzZXJ0KHsgdXNlcm5hbWU6ICdzdXBhYm90JyB9LCB7IG9uQ29uZmxpY3Q6ICd1c2VybmFtZScgfSlcblx0KlxuXHQqIC8vIEV4YW1wbGUgcmVzcG9uc2U6XG5cdCogLy8ge1xuXHQqIC8vICAgZGF0YTogW1xuXHQqIC8vICAgICB7IGlkOiA0LCBtZXNzYWdlOiAnYmFyJywgdXNlcm5hbWU6ICdzdXBhYm90JyB9XG5cdCogLy8gICBdLFxuXHQqIC8vICAgZXJyb3I6IG51bGxcblx0KiAvLyB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcHNlcnQgd2l0aCBjb25mbGljdCByZXNvbHV0aW9uIGFuZCBleGFjdCByb3cgY291bnRpbmdcblx0KiBgYGB0c1xuXHQqIC8vIFVwc2VydGluZyBhbmQgcmV0dXJuaW5nIGV4YWN0IGNvdW50XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnVwc2VydChcblx0KiAgICAge1xuXHQqICAgICAgIGlkOiAzLFxuXHQqICAgICAgIG1lc3NhZ2U6ICdmb28nLFxuXHQqICAgICAgIHVzZXJuYW1lOiAnc3VwYWJvdCdcblx0KiAgICAgfSxcblx0KiAgICAge1xuXHQqICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VybmFtZScsXG5cdCogICAgICAgY291bnQ6ICdleGFjdCdcblx0KiAgICAgfVxuXHQqICAgKVxuXHQqXG5cdCogLy8gRXhhbXBsZSByZXNwb25zZTpcblx0KiAvLyB7XG5cdCogLy8gICBkYXRhOiBbXG5cdCogLy8gICAgIHtcblx0KiAvLyAgICAgICBpZDogNDIsXG5cdCogLy8gICAgICAgaGFuZGxlOiBcInNhb2lyc2VcIixcblx0KiAvLyAgICAgICBkaXNwbGF5X25hbWU6IFwiU2FvaXJzZVwiXG5cdCogLy8gICAgIH1cblx0KiAvLyAgIF0sXG5cdCogLy8gICBjb3VudDogMSxcblx0KiAvLyAgIGVycm9yOiBudWxsXG5cdCogLy8gfVxuXHQqIGBgYFxuXHQqL1xuXHR1cHNlcnQodmFsdWVzLCB7IG9uQ29uZmxpY3QsIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSwgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDI7XG5cdFx0Y29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyBcImlnbm9yZVwiIDogXCJtZXJnZVwifS1kdXBsaWNhdGVzYCk7XG5cdFx0aWYgKG9uQ29uZmxpY3QgIT09IHZvaWQgMCkgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJvbl9jb25mbGljdFwiLCBvbkNvbmZsaWN0KTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdGlmICghZGVmYXVsdFRvTnVsbCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJtaXNzaW5nPWRlZmF1bHRcIik7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdFx0Y29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcblx0XHRcdGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2x1bW5zXCIsIHVuaXF1ZUNvbHVtbnMuam9pbihcIixcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRib2R5OiB2YWx1ZXMsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoMiA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoMiAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2gyIDogZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYW4gVVBEQVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBkYXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0dXBkYXRlKHZhbHVlcywgeyBjb3VudCB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2gzO1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiUEFUQ0hcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaDMgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaDMgIT09IHZvaWQgMCA/IF90aGlzJGZldGNoMyA6IGZldGNoLFxuXHRcdFx0dXJsTGVuZ3RoTGltaXQ6IHRoaXMudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgREVMRVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBkZWxldGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqL1xuXHRkZWxldGUoeyBjb3VudCB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2g0O1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiREVMRVRFXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2g0ID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2g0ICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaDQgOiBmZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RDbGllbnQudHNcbi8qKlxuKiBQb3N0Z1JFU1QgY2xpZW50LlxuKlxuKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuKlxuKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4qIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuKiBgXCJwdWJsaWNcImAsIHRoaXMgbXVzdCBiZSBzdXBwbGllZCBtYW51YWxseS5cbiovXG52YXIgUG9zdGdyZXN0Q2xpZW50ID0gY2xhc3MgUG9zdGdyZXN0Q2xpZW50IHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG5cdCpcblx0KiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gQ3VzdG9tIGhlYWRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG5cdCogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcblx0KiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IC0gT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGFsbCByZXF1ZXN0cy4gV2hlbiBzZXQsIHJlcXVlc3RzIHdpbGwgYXV0b21hdGljYWxseSBhYm9ydCBhZnRlciB0aGlzIGR1cmF0aW9uIHRvIHByZXZlbnQgaW5kZWZpbml0ZSBoYW5ncy5cblx0KiBAcGFyYW0gb3B0aW9ucy51cmxMZW5ndGhMaW1pdCAtIE1heGltdW0gVVJMIGxlbmd0aCBpbiBjaGFyYWN0ZXJzIGJlZm9yZSB3YXJuaW5ncy9lcnJvcnMgYXJlIHRyaWdnZXJlZC4gRGVmYXVsdHMgdG8gODAwMC5cblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgcG9zdGdyZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3Jlc3QvdjEnLCB7XG5cdCogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcblx0KiAgIHNjaGVtYTogJ3B1YmxpYycsXG5cdCogICB0aW1lb3V0OiAzMDAwMCwgLy8gMzAgc2Vjb25kIHRpbWVvdXRcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoOiBmZXRjaCQxLCB0aW1lb3V0LCB1cmxMZW5ndGhMaW1pdCA9IDhlMyB9ID0ge30pIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWE7XG5cdFx0dGhpcy51cmxMZW5ndGhMaW1pdCA9IHVybExlbmd0aExpbWl0O1xuXHRcdGNvbnN0IG9yaWdpbmFsRmV0Y2ggPSBmZXRjaCQxICE9PSBudWxsICYmIGZldGNoJDEgIT09IHZvaWQgMCA/IGZldGNoJDEgOiBnbG9iYWxUaGlzLmZldGNoO1xuXHRcdGlmICh0aW1lb3V0ICE9PSB2b2lkIDAgJiYgdGltZW91dCA+IDApIHRoaXMuZmV0Y2ggPSAoaW5wdXQsIGluaXQpID0+IHtcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdFx0XHRjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG5cdFx0XHRjb25zdCBleGlzdGluZ1NpZ25hbCA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5zaWduYWw7XG5cdFx0XHRpZiAoZXhpc3RpbmdTaWduYWwpIHtcblx0XHRcdFx0aWYgKGV4aXN0aW5nU2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dElkKTtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxGZXRjaChpbnB1dCwgaW5pdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuYWJvcnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZXhpc3RpbmdTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxGZXRjaChpbnB1dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGluaXQpLCB7fSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKS5maW5hbGx5KCgpID0+IHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dElkKTtcblx0XHRcdFx0XHRleGlzdGluZ1NpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3JpZ2luYWxGZXRjaChpbnB1dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGluaXQpLCB7fSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpKTtcblx0XHR9O1xuXHRcdGVsc2UgdGhpcy5mZXRjaCA9IG9yaWdpbmFsRmV0Y2g7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuXHQqL1xuXHRmcm9tKHJlbGF0aW9uKSB7XG5cdFx0aWYgKCFyZWxhdGlvbiB8fCB0eXBlb2YgcmVsYXRpb24gIT09IFwic3RyaW5nXCIgfHwgcmVsYXRpb24udHJpbSgpID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlbGF0aW9uIG5hbWU6IHJlbGF0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihuZXcgVVJMKGAke3RoaXMudXJsfS8ke3JlbGF0aW9ufWApLCB7XG5cdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cblx0KlxuXHQqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KlxuXHQqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG5cdCovXG5cdHNjaGVtYShzY2hlbWEpIHtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuXHQqXG5cdCogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuXHQqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuXHQqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cblx0KiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG5cdCogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuXHQqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG5cdCogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogLy8gRm9yIGNyb3NzLXNjaGVtYSBmdW5jdGlvbnMgd2hlcmUgdHlwZSBpbmZlcmVuY2UgZmFpbHMsIHVzZSBvdmVycmlkZVR5cGVzOlxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zY2hlbWEoJ3NjaGVtYV9iJylcblx0KiAgIC5ycGMoJ2Z1bmN0aW9uX2EnLCB7fSlcblx0KiAgIC5vdmVycmlkZVR5cGVzPHsgaWQ6IHN0cmluZzsgdXNlcl9pZDogc3RyaW5nIH1bXT4oKVxuXHQqIGBgYFxuXHQqL1xuXHRycGMoZm4sIGFyZ3MgPSB7fSwgeyBoZWFkID0gZmFsc2UsIGdldCA9IGZhbHNlLCBjb3VudCB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2g7XG5cdFx0bGV0IG1ldGhvZDtcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMudXJsfS9ycGMvJHtmbn1gKTtcblx0XHRsZXQgYm9keTtcblx0XHRjb25zdCBfaXNPYmplY3QgPSAodikgPT4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiAoIUFycmF5LmlzQXJyYXkodikgfHwgdi5zb21lKF9pc09iamVjdCkpO1xuXHRcdGNvbnN0IF9oYXNPYmplY3RBcmcgPSBoZWFkICYmIE9iamVjdC52YWx1ZXMoYXJncykuc29tZShfaXNPYmplY3QpO1xuXHRcdGlmIChfaGFzT2JqZWN0QXJnKSB7XG5cdFx0XHRtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRcdGJvZHkgPSBhcmdzO1xuXHRcdH0gZWxzZSBpZiAoaGVhZCB8fCBnZXQpIHtcblx0XHRcdG1ldGhvZCA9IGhlYWQgPyBcIkhFQURcIiA6IFwiR0VUXCI7XG5cdFx0XHRPYmplY3QuZW50cmllcyhhcmdzKS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDApLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW25hbWUsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYHske3ZhbHVlLmpvaW4oXCIsXCIpfX1gIDogYCR7dmFsdWV9YF0pLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1ldGhvZCA9IFwiUE9TVFwiO1xuXHRcdFx0Ym9keSA9IGFyZ3M7XG5cdFx0fVxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpO1xuXHRcdGlmIChfaGFzT2JqZWN0QXJnKSBoZWFkZXJzLnNldChcIlByZWZlclwiLCBjb3VudCA/IGBjb3VudD0ke2NvdW50fSxyZXR1cm49bWluaW1hbGAgOiBcInJldHVybj1taW5pbWFsXCIpO1xuXHRcdGVsc2UgaWYgKGNvdW50KSBoZWFkZXJzLnNldChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuXHRcdFx0Ym9keSxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2ggPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaCAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2ggOiBmZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9pbmRleC50c1xudmFyIHNyY19kZWZhdWx0ID0ge1xuXHRQb3N0Z3Jlc3RDbGllbnQsXG5cdFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcblx0UG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcblx0UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcblx0UG9zdGdyZXN0QnVpbGRlcixcblx0UG9zdGdyZXN0RXJyb3Jcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgUG9zdGdyZXN0QnVpbGRlciwgUG9zdGdyZXN0Q2xpZW50LCBQb3N0Z3Jlc3RFcnJvciwgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciwgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLCBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIlBvc3RncmVzdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJtZXNzYWdlIiwibmFtZSIsImRldGFpbHMiLCJoaW50IiwiY29kZSIsIlBvc3RncmVzdEJ1aWxkZXIiLCJ0aHJvd09uRXJyb3IiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJ2YWx1ZSIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2V0IiwidGhlbiIsIm9uZnVsZmlsbGVkIiwib25yZWplY3RlZCIsIl90aGlzIiwic2NoZW1hIiwiaW5jbHVkZXMiLCJtZXRob2QiLCJfZmV0Y2giLCJmZXRjaCIsInJlcyIsInVybCIsInRvU3RyaW5nIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaWduYWwiLCJyZXMkMSIsImVycm9yIiwiZGF0YSIsImNvdW50Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9rIiwiX3RoaXMkaGVhZGVycyRnZXQyIiwiX3JlcyRoZWFkZXJzJGdldCIsIl90aGlzJGhlYWRlcnMkZ2V0IiwidGV4dCIsImdldCIsInBhcnNlIiwiY291bnRIZWFkZXIiLCJtYXRjaCIsImNvbnRlbnRSYW5nZSIsInNwbGl0IiwibGVuZ3RoIiwicGFyc2VJbnQiLCJpc01heWJlU2luZ2xlIiwiQXJyYXkiLCJpc0FycmF5IiwiX2Vycm9yJGRldGFpbHMiLCJfdW51c2VkIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwiX2ZldGNoRXJyb3IkbmFtZTIiLCJlcnJvckRldGFpbHMiLCJjYXVzZSIsIl9jYXVzZSRtZXNzYWdlIiwiX2NhdXNlJGNvZGUiLCJfZmV0Y2hFcnJvciRuYW1lIiwiX2NhdXNlJG5hbWUiLCJjYXVzZU1lc3NhZ2UiLCJjYXVzZUNvZGUiLCJzdGFjayIsIl9mZXRjaEVycm9yJHN0YWNrIiwidXJsTGVuZ3RoIiwidXJsTGVuZ3RoTGltaXQiLCJyZXR1cm5zIiwib3ZlcnJpZGVUeXBlcyIsImJ1aWxkZXIiLCJfYnVpbGRlciRzaG91bGRUaHJvd08iLCJfYnVpbGRlciRpc01heWJlU2luZ2wiLCJfYnVpbGRlciR1cmxMZW5ndGhMaW0iLCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIiwic2VsZWN0IiwiY29sdW1ucyIsInF1b3RlZCIsImNsZWFuZWRDb2x1bW5zIiwibWFwIiwiYyIsInRlc3QiLCJqb2luIiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwib3JkZXIiLCJjb2x1bW4iLCJhc2NlbmRpbmciLCJudWxsc0ZpcnN0IiwiZm9yZWlnblRhYmxlIiwicmVmZXJlbmNlZFRhYmxlIiwia2V5IiwiZXhpc3RpbmdPcmRlciIsImxpbWl0IiwicmFuZ2UiLCJmcm9tIiwidG8iLCJrZXlPZmZzZXQiLCJrZXlMaW1pdCIsImFib3J0U2lnbmFsIiwic2luZ2xlIiwibWF5YmVTaW5nbGUiLCJjc3YiLCJnZW9qc29uIiwiZXhwbGFpbiIsImFuYWx5emUiLCJ2ZXJib3NlIiwic2V0dGluZ3MiLCJidWZmZXJzIiwid2FsIiwiZm9ybWF0Iiwib3B0aW9ucyIsImZpbHRlciIsIkJvb2xlYW4iLCJmb3JNZWRpYXR5cGUiLCJyb2xsYmFjayIsIm1heEFmZmVjdGVkIiwiUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cCIsIlJlZ0V4cCIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCJlcSIsIm5lcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJsaWtlIiwicGF0dGVybiIsImxpa2VBbGxPZiIsInBhdHRlcm5zIiwibGlrZUFueU9mIiwiaWxpa2UiLCJpbGlrZUFsbE9mIiwiaWxpa2VBbnlPZiIsInJlZ2V4TWF0Y2giLCJyZWdleElNYXRjaCIsImlzIiwiaXNEaXN0aW5jdCIsImluIiwidmFsdWVzIiwiY2xlYW5lZFZhbHVlcyIsIlNldCIsInMiLCJub3RJbiIsImNvbnRhaW5zIiwiY29udGFpbmVkQnkiLCJyYW5nZUd0IiwicmFuZ2VHdGUiLCJyYW5nZUx0IiwicmFuZ2VMdGUiLCJyYW5nZUFkamFjZW50Iiwib3ZlcmxhcHMiLCJ0ZXh0U2VhcmNoIiwicXVlcnkiLCJjb25maWciLCJ0eXBlIiwidHlwZVBhcnQiLCJjb25maWdQYXJ0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJub3QiLCJvcGVyYXRvciIsIm9yIiwiZmlsdGVycyIsIlBvc3RncmVzdFF1ZXJ5QnVpbGRlciIsImNsb25lUmVxdWVzdFN0YXRlIiwiVVJMIiwiaGVhZCIsImluc2VydCIsImRlZmF1bHRUb051bGwiLCJfdGhpcyRmZXRjaCIsInJlZHVjZSIsImFjYyIsIngiLCJjb25jYXQiLCJrZXlzIiwidW5pcXVlQ29sdW1ucyIsInVwc2VydCIsIm9uQ29uZmxpY3QiLCJpZ25vcmVEdXBsaWNhdGVzIiwiX3RoaXMkZmV0Y2gyIiwidXBkYXRlIiwiX3RoaXMkZmV0Y2gzIiwiZGVsZXRlIiwiX3RoaXMkZmV0Y2g0IiwiZmV0Y2gkMSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvJDEiLCJwcm90b3R5cGUiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJQb3N0Z3Jlc3RDbGllbnQiLCJyZWxhdGlvbiIsInRyaW0iLCJzY2hlbWFOYW1lIiwicnBjIiwiZm4iLCJhcmdzIiwiX2lzT2JqZWN0IiwidiIsInNvbWUiLCJfaGFzT2JqZWN0QXJnIiwiXyIsInRpbWVvdXQiLCJvcmlnaW5hbEZldGNoIiwiZ2xvYmFsVGhpcyIsImlucHV0IiwiaW5pdCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJleGlzdGluZ1NpZ25hbCIsImFib3J0ZWQiLCJjbGVhclRpbWVvdXQiLCJhYm9ydEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImZpbmFsbHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3JjX2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: function() { return /* binding */ StorageAnalyticsClient; },\n/* harmony export */   StorageApiError: function() { return /* binding */ StorageApiError; },\n/* harmony export */   StorageClient: function() { return /* binding */ StorageClient; },\n/* harmony export */   StorageError: function() { return /* binding */ StorageError; },\n/* harmony export */   StorageUnknownError: function() { return /* binding */ StorageUnknownError; },\n/* harmony export */   StorageVectorsApiError: function() { return /* binding */ StorageVectorsApiError; },\n/* harmony export */   StorageVectorsClient: function() { return /* binding */ StorageVectorsClient; },\n/* harmony export */   StorageVectorsError: function() { return /* binding */ StorageVectorsError; },\n/* harmony export */   StorageVectorsErrorCode: function() { return /* binding */ StorageVectorsErrorCode; },\n/* harmony export */   StorageVectorsUnknownError: function() { return /* binding */ StorageVectorsUnknownError; },\n/* harmony export */   VectorBucketApi: function() { return /* binding */ VectorBucketApi; },\n/* harmony export */   VectorBucketScope: function() { return /* binding */ VectorBucketScope; },\n/* harmony export */   VectorDataApi: function() { return /* binding */ VectorDataApi; },\n/* harmony export */   VectorIndexApi: function() { return /* binding */ VectorIndexApi; },\n/* harmony export */   VectorIndexScope: function() { return /* binding */ VectorIndexScope; },\n/* harmony export */   isStorageError: function() { return /* binding */ isStorageError; },\n/* harmony export */   isStorageVectorsError: function() { return /* binding */ isStorageVectorsError; }\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(app-pages-browser)/./node_modules/iceberg-js/dist/index.mjs\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n//#region src/lib/common/errors.ts\n/**\n* Base error class for all Storage errors\n* Supports both 'storage' and 'vectors' namespaces\n*/ var StorageError = class extends Error {\n    constructor(message, namespace = \"storage\", status, statusCode){\n        super(message);\n        this.__isStorageError = true;\n        this.namespace = namespace;\n        this.name = namespace === \"vectors\" ? \"StorageVectorsError\" : \"StorageError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n};\n/**\n* Type guard to check if an error is a StorageError\n* @param error - The error to check\n* @returns True if the error is a StorageError\n*/ function isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\n/**\n* API error returned from Storage service\n* Includes HTTP status code and service-specific error code\n*/ var StorageApiError = class extends StorageError {\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n    constructor(message, status, statusCode, namespace = \"storage\"){\n        super(message, namespace, status, statusCode);\n        this.name = namespace === \"vectors\" ? \"StorageVectorsApiError\" : \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageUnknownError = class extends StorageError {\n    constructor(message, originalError, namespace = \"storage\"){\n        super(message, namespace);\n        this.name = namespace === \"vectors\" ? \"StorageVectorsUnknownError\" : \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* @deprecated Use StorageError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsError = class extends StorageError {\n    constructor(message){\n        super(message, \"vectors\");\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return isStorageError(error) && error[\"namespace\"] === \"vectors\";\n}\n/**\n* @deprecated Use StorageApiError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsApiError = class extends StorageApiError {\n    constructor(message, status, statusCode){\n        super(message, status, statusCode, \"vectors\");\n    }\n};\n/**\n* @deprecated Use StorageUnknownError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsUnknownError = class extends StorageUnknownError {\n    constructor(message, originalError){\n        super(message, originalError, \"vectors\");\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/common/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return customFetch(...args);\n    };\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return fetch(...args);\n    };\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Recursively converts object keys from snake_case to camelCase\n* Used for normalizing API responses\n*\n* @param item - Object to convert\n* @returns Converted object with camelCase keys\n*/ const recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach((param)=>{\n        let [key, value] = param;\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/common/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\n/**\n* Handles fetch errors and converts them to Storage error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n* @param namespace - Error namespace ('storage' or 'vectors')\n*/ const handleError = async (error, reject, options, namespace)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const responseError = error;\n        const status = responseError.status || 500;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageApiError(_getErrorMessage(err), status, statusCode, namespace));\n        }).catch(()=>{\n            if (namespace === \"vectors\") {\n                const statusCode = status + \"\";\n                reject(new StorageApiError(responseError.statusText || \"HTTP \".concat(status, \" error\"), status, statusCode, namespace));\n            } else {\n                const statusCode = status + \"\";\n                reject(new StorageApiError(responseError.statusText || \"HTTP \".concat(status, \" error\"), status, statusCode, namespace));\n            }\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageApiError(responseError.statusText || \"HTTP \".concat(status, \" error\"), status, statusCode, namespace));\n        }\n    } else reject(new StorageUnknownError(_getErrorMessage(error), error, namespace));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || method === \"HEAD\" || !body) return _objectSpread2(_objectSpread2({}, params), parameters);\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @param namespace - Error namespace ('storage' or 'vectors')\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body, namespace) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            if (namespace === \"vectors\") {\n                const contentType = result.headers.get(\"content-type\");\n                if (result.headers.get(\"content-length\") === \"0\" || result.status === 204) return {};\n                if (!contentType || !contentType.includes(\"application/json\")) return {};\n            }\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options, namespace));\n    });\n}\n/**\n* Creates a fetch API with the specified namespace\n* @param namespace - Error namespace ('storage' or 'vectors')\n* @returns Object with HTTP method functions\n*/ function createFetchApi() {\n    let namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"storage\";\n    return {\n        get: async (fetcher, url, options, parameters)=>{\n            return _handleRequest(fetcher, \"GET\", url, options, parameters, void 0, namespace);\n        },\n        post: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"POST\", url, options, parameters, body, namespace);\n        },\n        put: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"PUT\", url, options, parameters, body, namespace);\n        },\n        head: async (fetcher, url, options, parameters)=>{\n            return _handleRequest(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n                noResolveJson: true\n            }), parameters, void 0, namespace);\n        },\n        remove: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body, namespace);\n        }\n    };\n}\nconst defaultApi = createFetchApi(\"storage\");\nconst { get, post, put, head, remove } = defaultApi;\nconst vectorsApi = createFetchApi(\"vectors\");\n//#endregion\n//#region src/lib/common/BaseApiClient.ts\n/**\n* @ignore\n* Base API client class for all Storage API classes\n* Provides common infrastructure for error handling and configuration\n*\n* @typeParam TError - The error type (StorageError or subclass)\n*/ var BaseApiClient = class {\n    /**\n\t* Enable throwing errors instead of returning them.\n\t* When enabled, errors are thrown instead of returned in { data, error } format.\n\t*\n\t* @returns this - For method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Handles API operation with standardized error handling\n\t* Eliminates repetitive try-catch blocks across all API methods\n\t*\n\t* This wrapper:\n\t* 1. Executes the operation\n\t* 2. Returns { data, error: null } on success\n\t* 3. Returns { data: null, error } on failure (if shouldThrowOnError is false)\n\t* 4. Throws error on failure (if shouldThrowOnError is true)\n\t*\n\t* @typeParam T - The expected data type from the operation\n\t* @param operation - Async function that performs the API call\n\t* @returns Promise with { data, error } tuple\n\t*\n\t* @example\n\t* ```typescript\n\t* async listBuckets() {\n\t*   return this.handleOperation(async () => {\n\t*     return await get(this.fetch, `${this.url}/bucket`, {\n\t*       headers: this.headers,\n\t*     })\n\t*   })\n\t* }\n\t* ```\n\t*/ async handleOperation(operation) {\n        var _this = this;\n        try {\n            return {\n                data: await operation(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new BaseApiClient instance\n\t* @param url - Base URL for API requests\n\t* @param headers - Default headers for API requests\n\t* @param fetch - Optional custom fetch implementation\n\t* @param namespace - Error namespace ('storage' or 'vectors')\n\t*/ constructor(url, headers = {}, fetch$1, namespace = \"storage\"){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.fetch = resolveFetch(fetch$1);\n        this.namespace = namespace;\n    }\n};\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class extends BaseApiClient {\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = \"max-age=\".concat(options.cacheControl);\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post)(_this.fetch, \"\".concat(_this.url, \"/object/\").concat(_path), body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                path: cleanPath,\n                id: data.Id,\n                fullPath: data.Key\n            };\n        });\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + \"/object/upload/sign/\".concat(_path));\n        url.searchParams.set(\"token\", token);\n        return _this3.handleOperation(async ()=>{\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = \"max-age=\".concat(options.cacheControl);\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                path: cleanPath,\n                fullPath: (await put(_this3.fetch, url.toString(), body, {\n                    headers\n                })).Key\n            };\n        });\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post(_this4.fetch, \"\".concat(_this4.url, \"/object/upload/sign/\").concat(_path), {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                signedUrl: url.toString(),\n                path,\n                token\n            };\n        });\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        return _this6.handleOperation(async ()=>{\n            return await post(_this6.fetch, \"\".concat(_this6.url, \"/object/move\"), {\n                bucketId: _this6.bucketId,\n                sourceKey: fromPath,\n                destinationKey: toPath,\n                destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n            }, {\n                headers: _this6.headers\n            });\n        });\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        return _this7.handleOperation(async ()=>{\n            return {\n                path: (await post(_this7.fetch, \"\".concat(_this7.url, \"/object/copy\"), {\n                    bucketId: _this7.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this7.headers\n                })).Key\n            };\n        });\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        return _this8.handleOperation(async ()=>{\n            let _path = _this8._getFinalPath(path);\n            let data = await post(_this8.fetch, \"\".concat(_this8.url, \"/object/sign/\").concat(_path), _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? \"&download=\".concat(options.download === true ? \"\" : options.download) : \"\";\n            return {\n                signedUrl: encodeURI(\"\".concat(_this8.url).concat(data.signedURL).concat(downloadQueryParam))\n            };\n        });\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        return _this9.handleOperation(async ()=>{\n            const data = await post(_this9.fetch, \"\".concat(_this9.url, \"/object/sign/\").concat(_this9.bucketId), {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? \"&download=\".concat(options.download === true ? \"\" : options.download) : \"\";\n            return data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                    signedUrl: datum.signedURL ? encodeURI(\"\".concat(_this9.url).concat(datum.signedURL).concat(downloadQueryParam)) : null\n                }));\n        });\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @param parameters Additional fetch parameters like signal for cancellation. Supports standard fetch options including cache control.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Download with cache control (useful in Edge Functions)\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {}, { cache: 'no-store' })\n\t* ```\n\t*\n\t* @example Download with abort signal\n\t* ```js\n\t* const controller = new AbortController()\n\t* setTimeout(() => controller.abort(), 5000)\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {}, { signal: controller.signal })\n\t* ```\n\t*/ download(path, options, parameters) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? \"?\".concat(transformationQuery) : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, \"\".concat(this.url, \"/\").concat(renderPath, \"/\").concat(_path).concat(queryString), {\n                headers: this.headers,\n                noResolveJson: true\n            }, parameters);\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        return _this10.handleOperation(async ()=>{\n            return recursiveToCamel(await get(_this10.fetch, \"\".concat(_this10.url, \"/object/info/\").concat(_path), {\n                headers: _this10.headers\n            }));\n        });\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, \"\".concat(_this11.url, \"/object/\").concat(_path), {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? \"download=\".concat(options.download === true ? \"\" : options.download) : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = \"?\".concat(queryString);\n        return {\n            data: {\n                publicUrl: encodeURI(\"\".concat(this.url, \"/\").concat(renderPath, \"/public/\").concat(_path).concat(queryString))\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        return _this12.handleOperation(async ()=>{\n            return await remove(_this12.fetch, \"\".concat(_this12.url, \"/object/\").concat(_this12.bucketId), {\n                prefixes: paths\n            }, {\n                headers: _this12.headers\n            });\n        });\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        return _this13.handleOperation(async ()=>{\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return await post(_this13.fetch, \"\".concat(_this13.url, \"/object/list/\").concat(_this13.bucketId), body, {\n                headers: _this13.headers\n            }, parameters);\n        });\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        return _this14.handleOperation(async ()=>{\n            const body = _objectSpread2({}, options);\n            return await post(_this14.fetch, \"\".concat(_this14.url, \"/object/list-v2/\").concat(_this14.bucketId), body, {\n                headers: _this14.headers\n            }, parameters);\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return \"\".concat(this.bucketId, \"/\").concat(path.replace(/^\\/+/, \"\"));\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(\"width=\".concat(transform.width));\n        if (transform.height) params.push(\"height=\".concat(transform.height));\n        if (transform.resize) params.push(\"resize=\".concat(transform.resize));\n        if (transform.format) params.push(\"format=\".concat(transform.format));\n        if (transform.quality) params.push(\"quality=\".concat(transform.quality));\n        return params.join(\"&\");\n    }\n    constructor(url, headers = {}, bucketId, fetch$1){\n        super(url, headers, fetch$1, \"storage\");\n        this.bucketId = bucketId;\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.95.3\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": \"storage-js/\".concat(version)\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class extends BaseApiClient {\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return await get(_this.fetch, \"\".concat(_this.url, \"/bucket\").concat(queryString), {\n                headers: _this.headers\n            });\n        });\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await get(_this2.fetch, \"\".concat(_this2.url, \"/bucket/\").concat(id), {\n                headers: _this2.headers\n            });\n        });\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            public: false\n        };\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await post(_this3.fetch, \"\".concat(_this3.url, \"/bucket\"), {\n                id,\n                name: id,\n                type: options.type,\n                public: options.public,\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n            }, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await put(_this4.fetch, \"\".concat(_this4.url, \"/bucket/\").concat(id), {\n                id,\n                name: id,\n                public: options.public,\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n            }, {\n                headers: _this4.headers\n            });\n        });\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        return _this5.handleOperation(async ()=>{\n            return await post(_this5.fetch, \"\".concat(_this5.url, \"/bucket/\").concat(id, \"/empty\"), {}, {\n                headers: _this5.headers\n            });\n        });\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        return _this6.handleOperation(async ()=>{\n            return await remove(_this6.fetch, \"\".concat(_this6.url, \"/bucket/\").concat(id), {}, {\n                headers: _this6.headers\n            });\n        });\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n    constructor(url, headers = {}, fetch$1, opts){\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        const finalUrl = baseUrl.href.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        super(finalUrl, finalHeaders, fetch$1, \"storage\");\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class extends BaseApiClient {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await post(_this.fetch, \"\".concat(_this.url, \"/bucket\"), {\n                name\n            }, {\n                headers: _this.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? \"\".concat(_this2.url, \"/bucket?\").concat(queryString) : \"\".concat(_this2.url, \"/bucket\");\n            return await get(_this2.fetch, url, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await remove(_this3.fetch, \"\".concat(_this3.url, \"/bucket/\").concat(bucketName), {}, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        super(finalUrl, finalHeaders, fetch$1, \"storage\");\n    }\n};\n//#endregion\n//#region src/packages/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class extends BaseApiClient {\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, \"\".concat(_this.url, \"/CreateIndex\"), options, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, \"\".concat(_this2.url, \"/GetIndex\"), {\n                vectorBucketName,\n                indexName\n            }, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, \"\".concat(_this3.url, \"/ListIndexes\"), options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, \"\".concat(_this4.url, \"/DeleteIndex\"), {\n                vectorBucketName,\n                indexName\n            }, {\n                headers: _this4.headers\n            }) || {};\n        });\n    }\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n};\n//#endregion\n//#region src/packages/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class extends BaseApiClient {\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, \"\".concat(_this.url, \"/PutVectors\"), options, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, \"\".concat(_this2.url, \"/GetVectors\"), options, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        if (options.segmentCount !== void 0) {\n            if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n            if (options.segmentIndex !== void 0) {\n                if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(\"segmentIndex must be between 0 and \".concat(options.segmentCount - 1));\n            }\n        }\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, \"\".concat(_this3.url, \"/ListVectors\"), options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, \"\".concat(_this4.url, \"/QueryVectors\"), options, {\n                headers: _this4.headers\n            });\n        });\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n        return _this5.handleOperation(async ()=>{\n            return await vectorsApi.post(_this5.fetch, \"\".concat(_this5.url, \"/DeleteVectors\"), options, {\n                headers: _this5.headers\n            }) || {};\n        });\n    }\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n};\n//#endregion\n//#region src/packages/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class extends BaseApiClient {\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, \"\".concat(_this.url, \"/CreateVectorBucket\"), {\n                vectorBucketName\n            }, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, \"\".concat(_this2.url, \"/GetVectorBucket\"), {\n                vectorBucketName\n            }, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, \"\".concat(_this3.url, \"/ListVectorBuckets\"), options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, \"\".concat(_this4.url, \"/DeleteVectorBucket\"), {\n                vectorBucketName\n            }, {\n                headers: _this4.headers\n            }) || {};\n        });\n    }\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n};\n//#endregion\n//#region src/packages/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBRWhELGtDQUFrQztBQUNsQzs7O0FBR0EsR0FDQSxJQUFJQyxlQUFlLGNBQWNDO0lBQ2hDQyxZQUFZQyxPQUFPLEVBQUVDLFlBQVksU0FBUyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUMvRCxLQUFLLENBQUNIO1FBQ04sSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNILFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSSxJQUFJLEdBQUdKLGNBQWMsWUFBWSx3QkFBd0I7UUFDOUQsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO0lBQ25CO0FBQ0Q7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU0csZUFBZUMsS0FBSztJQUM1QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLHNCQUFzQkE7QUFDN0U7QUFDQTs7O0FBR0EsR0FDQSxJQUFJQyxrQkFBa0IsY0FBY1g7SUFPbkNZLFNBQVM7UUFDUixPQUFPO1lBQ05KLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZMLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDNUI7SUFDRDtJQWJBSixZQUFZQyxPQUFPLEVBQUVFLE1BQU0sRUFBRUMsVUFBVSxFQUFFRixZQUFZLFNBQVMsQ0FBRTtRQUMvRCxLQUFLLENBQUNELFNBQVNDLFdBQVdDLFFBQVFDO1FBQ2xDLElBQUksQ0FBQ0UsSUFBSSxHQUFHSixjQUFjLFlBQVksMkJBQTJCO1FBQ2pFLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtJQUNuQjtBQVNEO0FB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Q0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ2pGLEtBQUs7SUFDbEY7SUE3REE7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBdEIsWUFBWTJHLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXdCLE9BQU8sRUFBRWdJLElBQUksQ0FBRTtRQUM3QyxLQUFLLENBQUNwSixLQUFLSixTQUFTd0IsU0FBU2dJO0lBQzlCO0FBOENEO0FBRUEsWUFBWTtBQUM2VSxDQUN6VixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvaW5kZXgubWpzP2ViMzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWNlYmVyZ1Jlc3RDYXRhbG9nIH0gZnJvbSBcImljZWJlcmctanNcIjtcblxuLy8jcmVnaW9uIHNyYy9saWIvY29tbW9uL2Vycm9ycy50c1xuLyoqXG4qIEJhc2UgZXJyb3IgY2xhc3MgZm9yIGFsbCBTdG9yYWdlIGVycm9yc1xuKiBTdXBwb3J0cyBib3RoICdzdG9yYWdlJyBhbmQgJ3ZlY3RvcnMnIG5hbWVzcGFjZXNcbiovXG52YXIgU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWVzcGFjZSA9IFwic3RvcmFnZVwiLCBzdGF0dXMsIHN0YXR1c0NvZGUpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdHRoaXMubmFtZSA9IG5hbWVzcGFjZSA9PT0gXCJ2ZWN0b3JzXCIgPyBcIlN0b3JhZ2VWZWN0b3JzRXJyb3JcIiA6IFwiU3RvcmFnZUVycm9yXCI7XG5cdFx0dGhpcy5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0fVxufTtcbi8qKlxuKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgU3RvcmFnZUVycm9yXG4qIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFN0b3JhZ2VFcnJvclxuKi9cbmZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yKSB7XG5cdHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJfX2lzU3RvcmFnZUVycm9yXCIgaW4gZXJyb3I7XG59XG4vKipcbiogQVBJIGVycm9yIHJldHVybmVkIGZyb20gU3RvcmFnZSBzZXJ2aWNlXG4qIEluY2x1ZGVzIEhUVFAgc3RhdHVzIGNvZGUgYW5kIHNlcnZpY2Utc3BlY2lmaWMgZXJyb3IgY29kZVxuKi9cbnZhciBTdG9yYWdlQXBpRXJyb3IgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSwgbmFtZXNwYWNlID0gXCJzdG9yYWdlXCIpIHtcblx0XHRzdXBlcihtZXNzYWdlLCBuYW1lc3BhY2UsIHN0YXR1cywgc3RhdHVzQ29kZSk7XG5cdFx0dGhpcy5uYW1lID0gbmFtZXNwYWNlID09PSBcInZlY3RvcnNcIiA/IFwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvclwiIDogXCJTdG9yYWdlQXBpRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZVxuXHRcdH07XG5cdH1cbn07XG4vKipcbiogVW5rbm93biBlcnJvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggZXhwZWN0ZWQgZXJyb3IgcGF0dGVybnNcbiogV3JhcHMgdGhlIG9yaWdpbmFsIGVycm9yIGZvciBkZWJ1Z2dpbmdcbiovXG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvciwgbmFtZXNwYWNlID0gXCJzdG9yYWdlXCIpIHtcblx0XHRzdXBlcihtZXNzYWdlLCBuYW1lc3BhY2UpO1xuXHRcdHRoaXMubmFtZSA9IG5hbWVzcGFjZSA9PT0gXCJ2ZWN0b3JzXCIgPyBcIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yXCIgOiBcIlN0b3JhZ2VVbmtub3duRXJyb3JcIjtcblx0XHR0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXHR9XG59O1xuLyoqXG4qIEBkZXByZWNhdGVkIFVzZSBTdG9yYWdlRXJyb3Igd2l0aCBuYW1lc3BhY2U9J3ZlY3RvcnMnIGluc3RlYWRcbiogQWxpYXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyB2ZWN0b3Igc3RvcmFnZSBjb2RlXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzRXJyb3IgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlLCBcInZlY3RvcnNcIik7XG5cdH1cbn07XG4vKipcbiogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrXG4qIEByZXR1cm5zIFRydWUgaWYgdGhlIGVycm9yIGlzIGEgU3RvcmFnZVZlY3RvcnNFcnJvclxuKi9cbmZ1bmN0aW9uIGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yW1wibmFtZXNwYWNlXCJdID09PSBcInZlY3RvcnNcIjtcbn1cbi8qKlxuKiBAZGVwcmVjYXRlZCBVc2UgU3RvcmFnZUFwaUVycm9yIHdpdGggbmFtZXNwYWNlPSd2ZWN0b3JzJyBpbnN0ZWFkXG4qIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgdmVjdG9yIHN0b3JhZ2UgY29kZVxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlQXBpRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUpIHtcblx0XHRzdXBlcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUsIFwidmVjdG9yc1wiKTtcblx0fVxufTtcbi8qKlxuKiBAZGVwcmVjYXRlZCBVc2UgU3RvcmFnZVVua25vd25FcnJvciB3aXRoIG5hbWVzcGFjZT0ndmVjdG9ycycgaW5zdGVhZFxuKiBBbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIHZlY3RvciBzdG9yYWdlIGNvZGVcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VVbmtub3duRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgb3JpZ2luYWxFcnJvciwgXCJ2ZWN0b3JzXCIpO1xuXHR9XG59O1xuLyoqXG4qIEVycm9yIGNvZGVzIHNwZWNpZmljIHRvIFMzIFZlY3RvcnMgQVBJXG4qIE1hcHMgQVdTIHNlcnZpY2UgZXJyb3JzIHRvIGFwcGxpY2F0aW9uLWZyaWVuZGx5IGVycm9yIGNvZGVzXG4qL1xubGV0IFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEpIHtcblx0LyoqIEludGVybmFsIHNlcnZlciBmYXVsdCAoSFRUUCA1MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJJbnRlcm5hbEVycm9yXCJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG5cdC8qKiBSZXNvdXJjZSBhbHJlYWR5IGV4aXN0cyAvIGNvbmZsaWN0IChIVFRQIDQwOSkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIl0gPSBcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIjtcblx0LyoqIFJlc291cmNlIG5vdCBmb3VuZCAoSFRUUCA0MDQpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCJdID0gXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCI7XG5cdC8qKiBEZWxldGUgYnVja2V0IHdoaWxlIG5vdCBlbXB0eSAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCJdID0gXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCI7XG5cdC8qKiBFeGNlZWRzIGJ1Y2tldCBxdW90YS9saW1pdCAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck1heEJ1Y2tldHNFeGNlZWRlZFwiXSA9IFwiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIjtcblx0LyoqIEV4Y2VlZHMgaW5kZXggcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhJbmRleGVzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCI7XG5cdHJldHVybiBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxO1xufSh7fSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29tbW9uL2hlbHBlcnMudHNcbi8qKlxuKiBSZXNvbHZlcyB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlXG4qIFVzZXMgY3VzdG9tIGZldGNoIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlcyBuYXRpdmUgZmV0Y2hcbipcbiogQHBhcmFtIGN1c3RvbUZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG4qIEByZXR1cm5zIFJlc29sdmVkIGZldGNoIGZ1bmN0aW9uXG4qL1xuY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG5cdGlmIChjdXN0b21GZXRjaCkgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcblx0cmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbipcbiogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdFxuKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqXG4qL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogUmVjdXJzaXZlbHkgY29udmVydHMgb2JqZWN0IGtleXMgZnJvbSBzbmFrZV9jYXNlIHRvIGNhbWVsQ2FzZVxuKiBVc2VkIGZvciBub3JtYWxpemluZyBBUEkgcmVzcG9uc2VzXG4qXG4qIEBwYXJhbSBpdGVtIC0gT2JqZWN0IHRvIGNvbnZlcnRcbiogQHJldHVybnMgQ29udmVydGVkIG9iamVjdCB3aXRoIGNhbWVsQ2FzZSBrZXlzXG4qL1xuY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG5cdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSk7XG5cdGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSByZXR1cm4gaXRlbTtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpKTtcblx0XHRyZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4qIE1pcnJvcnMgYmFja2VuZCB2YWxpZGF0aW9uIGZyb206IHN0b3JhZ2Uvc3JjL3N0b3JhZ2UvbGltaXRzLnRzOmlzVmFsaWRCdWNrZXROYW1lKClcbipcbiogUnVsZXM6XG4qIC0gTGVuZ3RoOiAxLTEwMCBjaGFyYWN0ZXJzXG4qIC0gQWxsb3dlZCBjaGFyYWN0ZXJzOiBhbHBoYW51bWVyaWMgKGEteiwgQS1aLCAwLTkpLCB1bmRlcnNjb3JlIChfKSwgYW5kIHNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4qIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiogLSBGb3JiaWRkZW46IHBhdGggc2VwYXJhdG9ycyAoLywgXFwpLCBwYXRoIHRyYXZlcnNhbCAoLi4pLCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbipcbiogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuKlxuKiBAcGFyYW0gYnVja2V0TmFtZSAtIFRoZSBidWNrZXQgbmFtZSB0byB2YWxpZGF0ZVxuKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiovXG5jb25zdCBpc1ZhbGlkQnVja2V0TmFtZSA9IChidWNrZXROYW1lKSA9PiB7XG5cdGlmICghYnVja2V0TmFtZSB8fCB0eXBlb2YgYnVja2V0TmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5sZW5ndGggPT09IDAgfHwgYnVja2V0TmFtZS5sZW5ndGggPiAxMDApIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUudHJpbSgpICE9PSBidWNrZXROYW1lKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmluY2x1ZGVzKFwiL1wiKSB8fCBidWNrZXROYW1lLmluY2x1ZGVzKFwiXFxcXFwiKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC8udGVzdChidWNrZXROYW1lKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29tbW9uL2ZldGNoLnRzXG4vKipcbiogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuKiBAcGFyYW0gZXJyIC0gRXJyb3Igb2JqZWN0IGZyb20gQVBJXG4qIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4ge1xuXHR2YXIgX2VyciRlcnJvcjtcblx0cmV0dXJuIGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8ICh0eXBlb2YgZXJyLmVycm9yID09PSBcInN0cmluZ1wiID8gZXJyLmVycm9yIDogKF9lcnIkZXJyb3IgPSBlcnIuZXJyb3IpID09PSBudWxsIHx8IF9lcnIkZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnIkZXJyb3IubWVzc2FnZSkgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbn07XG4vKipcbiogSGFuZGxlcyBmZXRjaCBlcnJvcnMgYW5kIGNvbnZlcnRzIHRoZW0gdG8gU3RvcmFnZSBlcnJvciB0eXBlc1xuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1Z2h0IGZyb20gZmV0Y2hcbiogQHBhcmFtIHJlamVjdCAtIFByb21pc2UgcmVqZWN0aW9uIGZ1bmN0aW9uXG4qIEBwYXJhbSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9ucyB0aGF0IG1heSBhZmZlY3QgZXJyb3IgaGFuZGxpbmdcbiogQHBhcmFtIG5hbWVzcGFjZSAtIEVycm9yIG5hbWVzcGFjZSAoJ3N0b3JhZ2UnIG9yICd2ZWN0b3JzJylcbiovXG5jb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zLCBuYW1lc3BhY2UpID0+IHtcblx0aWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInN0YXR1c1wiIGluIGVycm9yICYmIFwib2tcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pKSB7XG5cdFx0Y29uc3QgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xuXHRcdGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlRXJyb3Iuc3RhdHVzIHx8IDUwMDtcblx0XHRpZiAodHlwZW9mIHJlc3BvbnNlRXJyb3IuanNvbiA9PT0gXCJmdW5jdGlvblwiKSByZXNwb25zZUVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29kZSkgfHwgc3RhdHVzICsgXCJcIjtcblx0XHRcdHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgc3RhdHVzLCBzdGF0dXNDb2RlLCBuYW1lc3BhY2UpKTtcblx0XHR9KS5jYXRjaCgoKSA9PiB7XG5cdFx0XHRpZiAobmFtZXNwYWNlID09PSBcInZlY3RvcnNcIikge1xuXHRcdFx0XHRjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICsgXCJcIjtcblx0XHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSwgbmFtZXNwYWNlKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICsgXCJcIjtcblx0XHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSwgbmFtZXNwYWNlKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICsgXCJcIjtcblx0XHRcdHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSkpO1xuXHRcdH1cblx0fSBlbHNlIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3IsIG5hbWVzcGFjZSkpO1xufTtcbi8qKlxuKiBCdWlsZHMgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBmZXRjaCBjYWxsc1xuKiBAcGFyYW0gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBsaWtlIEFib3J0U2lnbmFsXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5ICh3aWxsIGJlIEpTT04gc3RyaW5naWZpZWQgaWYgcGxhaW4gb2JqZWN0KVxuKiBAcmV0dXJucyBDb21wbGV0ZSBmZXRjaCByZXF1ZXN0IHBhcmFtZXRlcnNcbiovXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgbWV0aG9kID09PSBcIkhFQURcIiB8fCAhYm9keSkgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCBwYXJhbWV0ZXJzKTtcblx0aWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuLyoqXG4qIEludGVybmFsIHJlcXVlc3QgaGFuZGxlciB0aGF0IHdyYXBzIGZldGNoIHdpdGggZXJyb3IgaGFuZGxpbmdcbiogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiogQHBhcmFtIG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4qIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4qIEBwYXJhbSBuYW1lc3BhY2UgLSBFcnJvciBuYW1lc3BhY2UgKCdzdG9yYWdlJyBvciAndmVjdG9ycycpXG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2Ugb3IgZXJyb3JcbiovXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSwgbmFtZXNwYWNlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdDtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcblx0XHRcdGlmIChuYW1lc3BhY2UgPT09IFwidmVjdG9yc1wiKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuXHRcdFx0XHRpZiAocmVzdWx0LmhlYWRlcnMuZ2V0KFwiY29udGVudC1sZW5ndGhcIikgPT09IFwiMFwiIHx8IHJlc3VsdC5zdGF0dXMgPT09IDIwNCkgcmV0dXJuIHt9O1xuXHRcdFx0XHRpZiAoIWNvbnRlbnRUeXBlIHx8ICFjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucywgbmFtZXNwYWNlKSk7XG5cdH0pO1xufVxuLyoqXG4qIENyZWF0ZXMgYSBmZXRjaCBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZVxuKiBAcGFyYW0gbmFtZXNwYWNlIC0gRXJyb3IgbmFtZXNwYWNlICgnc3RvcmFnZScgb3IgJ3ZlY3RvcnMnKVxuKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBIVFRQIG1ldGhvZCBmdW5jdGlvbnNcbiovXG5mdW5jdGlvbiBjcmVhdGVGZXRjaEFwaShuYW1lc3BhY2UgPSBcInN0b3JhZ2VcIikge1xuXHRyZXR1cm4ge1xuXHRcdGdldDogYXN5bmMgKGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykgPT4ge1xuXHRcdFx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIFwiR0VUXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgdm9pZCAwLCBuYW1lc3BhY2UpO1xuXHRcdH0sXG5cdFx0cG9zdDogYXN5bmMgKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykgPT4ge1xuXHRcdFx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIFwiUE9TVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHksIG5hbWVzcGFjZSk7XG5cdFx0fSxcblx0XHRwdXQ6IGFzeW5jIChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpID0+IHtcblx0XHRcdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIlBVVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHksIG5hbWVzcGFjZSk7XG5cdFx0fSxcblx0XHRoZWFkOiBhc3luYyAoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSA9PiB7XG5cdFx0XHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJIRUFEXCIsIHVybCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyBub1Jlc29sdmVKc29uOiB0cnVlIH0pLCBwYXJhbWV0ZXJzLCB2b2lkIDAsIG5hbWVzcGFjZSk7XG5cdFx0fSxcblx0XHRyZW1vdmU6IGFzeW5jIChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpID0+IHtcblx0XHRcdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIkRFTEVURVwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHksIG5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9O1xufVxuY29uc3QgZGVmYXVsdEFwaSA9IGNyZWF0ZUZldGNoQXBpKFwic3RvcmFnZVwiKTtcbmNvbnN0IHsgZ2V0LCBwb3N0LCBwdXQsIGhlYWQsIHJlbW92ZSB9ID0gZGVmYXVsdEFwaTtcbmNvbnN0IHZlY3RvcnNBcGkgPSBjcmVhdGVGZXRjaEFwaShcInZlY3RvcnNcIik7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29tbW9uL0Jhc2VBcGlDbGllbnQudHNcbi8qKlxuKiBAaWdub3JlXG4qIEJhc2UgQVBJIGNsaWVudCBjbGFzcyBmb3IgYWxsIFN0b3JhZ2UgQVBJIGNsYXNzZXNcbiogUHJvdmlkZXMgY29tbW9uIGluZnJhc3RydWN0dXJlIGZvciBlcnJvciBoYW5kbGluZyBhbmQgY29uZmlndXJhdGlvblxuKlxuKiBAdHlwZVBhcmFtIFRFcnJvciAtIFRoZSBlcnJvciB0eXBlIChTdG9yYWdlRXJyb3Igb3Igc3ViY2xhc3MpXG4qL1xudmFyIEJhc2VBcGlDbGllbnQgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgQmFzZUFwaUNsaWVudCBpbnN0YW5jZVxuXHQqIEBwYXJhbSB1cmwgLSBCYXNlIFVSTCBmb3IgQVBJIHJlcXVlc3RzXG5cdCogQHBhcmFtIGhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgZm9yIEFQSSByZXF1ZXN0c1xuXHQqIEBwYXJhbSBmZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuXHQqIEBwYXJhbSBuYW1lc3BhY2UgLSBFcnJvciBuYW1lc3BhY2UgKCdzdG9yYWdlJyBvciAndmVjdG9ycycpXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBuYW1lc3BhY2UgPSBcInN0b3JhZ2VcIikge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHRcdHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHR9XG5cdC8qKlxuXHQqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cblx0KiBXaGVuIGVuYWJsZWQsIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgcmV0dXJuZWQgaW4geyBkYXRhLCBlcnJvciB9IGZvcm1hdC5cblx0KlxuXHQqIEByZXR1cm5zIHRoaXMgLSBGb3IgbWV0aG9kIGNoYWluaW5nXG5cdCovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogSGFuZGxlcyBBUEkgb3BlcmF0aW9uIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG5cdCogRWxpbWluYXRlcyByZXBldGl0aXZlIHRyeS1jYXRjaCBibG9ja3MgYWNyb3NzIGFsbCBBUEkgbWV0aG9kc1xuXHQqXG5cdCogVGhpcyB3cmFwcGVyOlxuXHQqIDEuIEV4ZWN1dGVzIHRoZSBvcGVyYXRpb25cblx0KiAyLiBSZXR1cm5zIHsgZGF0YSwgZXJyb3I6IG51bGwgfSBvbiBzdWNjZXNzXG5cdCogMy4gUmV0dXJucyB7IGRhdGE6IG51bGwsIGVycm9yIH0gb24gZmFpbHVyZSAoaWYgc2hvdWxkVGhyb3dPbkVycm9yIGlzIGZhbHNlKVxuXHQqIDQuIFRocm93cyBlcnJvciBvbiBmYWlsdXJlIChpZiBzaG91bGRUaHJvd09uRXJyb3IgaXMgdHJ1ZSlcblx0KlxuXHQqIEB0eXBlUGFyYW0gVCAtIFRoZSBleHBlY3RlZCBkYXRhIHR5cGUgZnJvbSB0aGUgb3BlcmF0aW9uXG5cdCogQHBhcmFtIG9wZXJhdGlvbiAtIEFzeW5jIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIEFQSSBjYWxsXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHsgZGF0YSwgZXJyb3IgfSB0dXBsZVxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogYXN5bmMgbGlzdEJ1Y2tldHMoKSB7XG5cdCogICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHQqICAgICByZXR1cm4gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7XG5cdCogICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHQqICAgICB9KVxuXHQqICAgfSlcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGhhbmRsZU9wZXJhdGlvbihvcGVyYXRpb24pIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBvcGVyYXRpb24oKSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIudHNcbnZhciBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRhc3luYyBleGVjdXRlKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IChhd2FpdCBfdGhpcy5kb3dubG9hZEZuKCkpLmJvZHksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci50c1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWc7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIEJsb2JEb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0dGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9IFwiQmxvYkRvd25sb2FkQnVpbGRlclwiO1xuXHRcdHRoaXMucHJvbWlzZSA9IG51bGw7XG5cdH1cblx0YXNTdHJlYW0oKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIodGhpcy5kb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcik7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcblx0fVxuXHRnZXRQcm9taXNlKCkge1xuXHRcdGlmICghdGhpcy5wcm9taXNlKSB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcblx0XHRyZXR1cm4gdGhpcy5wcm9taXNlO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYmxvYigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuXHRsaW1pdDogMTAwLFxuXHRvZmZzZXQ6IDAsXG5cdHNvcnRCeToge1xuXHRcdGNvbHVtbjogXCJuYW1lXCIsXG5cdFx0b3JkZXI6IFwiYXNjXCJcblx0fVxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuXHRjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxuXHRjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcblx0dXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IGNsYXNzIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBidWNrZXRJZCwgZmV0Y2gkMSkge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSwgXCJzdG9yYWdlXCIpO1xuXHRcdHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcblx0fVxuXHQvKipcblx0KiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG5cdCpcblx0KiBAcGFyYW0gbWV0aG9kIEhUVFAgbWV0aG9kLlxuXHQqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCovXG5cdGFzeW5jIHVwbG9hZE9yVXBkYXRlKG1ldGhvZCwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0ZJTEVfT1BUSU9OUyksIGZpbGVPcHRpb25zKTtcblx0XHRcdGxldCBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmhlYWRlcnMpLCBtZXRob2QgPT09IFwiUE9TVFwiICYmIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0aWYgKG1ldGFkYXRhKSBib2R5LmFwcGVuZChcIm1ldGFkYXRhXCIsIF90aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiXCIsIGZpbGVCb2R5KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRpZiAoIWJvZHkuaGFzKFwiY2FjaGVDb250cm9sXCIpKSBib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSAmJiAhYm9keS5oYXMoXCJtZXRhZGF0YVwiKSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcblx0XHRcdFx0aGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgaGVhZGVyc1tcIngtbWV0YWRhdGFcIl0gPSBfdGhpcy50b0Jhc2U2NChfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRpZiAoKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgYm9keSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBcInBpcGVcIiBpbiBib2R5ICYmIHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIikgJiYgIW9wdGlvbnMuZHVwbGV4KSBvcHRpb25zLmR1cGxleCA9IFwiaGFsZlwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpbGVPcHRpb25zID09PSBudWxsIHx8IGZpbGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlT3B0aW9ucy5oZWFkZXJzKSBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGhlYWRlcnMpLCBmaWxlT3B0aW9ucy5oZWFkZXJzKTtcblx0XHRcdGNvbnN0IGNsZWFuUGF0aCA9IF90aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0XHRjb25zdCBfcGF0aCA9IF90aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCAobWV0aG9kID09IFwiUFVUXCIgPyBwdXQgOiBwb3N0KShfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBfb2JqZWN0U3ByZWFkMih7IGhlYWRlcnMgfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aDogY2xlYW5QYXRoLFxuXHRcdFx0XHRpZDogZGF0YS5JZCxcblx0XHRcdFx0ZnVsbFBhdGg6IGRhdGEuS2V5XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0KiBAcGFyYW0gZmlsZU9wdGlvbnMgT3B0aW9uYWwgZmlsZSB1cGxvYWQgb3B0aW9ucyBpbmNsdWRpbmcgY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgdXBzZXJ0LCBhbmQgbWV0YWRhdGEuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoLCBpZCwgYW5kIGZ1bGxQYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBVcGxvYWQgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgYXZhdGFyRmlsZSA9IGV2ZW50LnRhcmdldC5maWxlc1swXVxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwbG9hZCgncHVibGljL2F2YXRhcjEucG5nJywgYXZhdGFyRmlsZSwge1xuXHQqICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcblx0KiAgICAgdXBzZXJ0OiBmYWxzZVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJwdWJsaWMvYXZhdGFyMS5wbmdcIixcblx0KiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvcHVibGljL2F2YXRhcjEucG5nXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcGxvYWQgZmlsZSB1c2luZyBgQXJyYXlCdWZmZXJgIGZyb20gYmFzZTY0IGZpbGUgZGF0YVxuXHQqIGBgYGpzXG5cdCogaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnYmFzZTY0LWFycmF5YnVmZmVyJ1xuXHQqXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBkZWNvZGUoJ2Jhc2U2NEZpbGVEYXRhJyksIHtcblx0KiAgICAgY29udGVudFR5cGU6ICdpbWFnZS9wbmcnXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWQocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoXCJQT1NUXCIsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cblx0KiBAcGFyYW0gdG9rZW4gVGhlIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBIVFRQIGhlYWRlcnMgKGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIGV0Yy4pLlxuXHQqICoqTm90ZToqKiBUaGUgYHVwc2VydGAgb3B0aW9uIGhhcyBubyBlZmZlY3QgaGVyZS4gVG8gZW5hYmxlIHVwc2VydCBiZWhhdmlvcixcblx0KiBwYXNzIGB7IHVwc2VydDogdHJ1ZSB9YCB3aGVuIGNhbGxpbmcgYGNyZWF0ZVNpZ25lZFVwbG9hZFVybCgpYCBpbnN0ZWFkLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCB0byBhIHNpZ25lZCBVUkxcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwbG9hZFRvU2lnbmVkVXJsKCdmb2xkZXIvY2F0LmpwZycsICd0b2tlbi1mcm9tLWNyZWF0ZVNpZ25lZFVwbG9hZFVybCcsIGZpbGUpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2NhdC5qcGdcIixcblx0KiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvZm9sZGVyL2NhdC5qcGdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBsb2FkVG9TaWduZWRVcmwocGF0aCwgdG9rZW4sIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdGNvbnN0IGNsZWFuUGF0aCA9IF90aGlzMy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuXHRcdGNvbnN0IF9wYXRoID0gX3RoaXMzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKF90aGlzMy51cmwgKyBgL29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWApO1xuXHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidG9rZW5cIiwgdG9rZW4pO1xuXHRcdHJldHVybiBfdGhpczMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczMuaGVhZGVycyksIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aDogY2xlYW5QYXRoLFxuXHRcdFx0XHRmdWxsUGF0aDogKGF3YWl0IHB1dChfdGhpczMuZmV0Y2gsIHVybC50b1N0cmluZygpLCBib2R5LCB7IGhlYWRlcnMgfSkpLktleVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG5cdCogU2lnbmVkIHVwbG9hZCBVUkxzIGNhbiBiZSB1c2VkIHRvIHVwbG9hZCBmaWxlcyB0byB0aGUgYnVja2V0IHdpdGhvdXQgZnVydGhlciBhdXRoZW50aWNhdGlvbi5cblx0KiBUaGV5IGFyZSB2YWxpZCBmb3IgMiBob3Vycy5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc2lnbmVkIHVwbG9hZCBVUkwsIHRva2VuLCBhbmQgcGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVcGxvYWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcGxvYWRVcmwoJ2ZvbGRlci9jYXQuanBnJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC91cGxvYWQvc2lnbi9hdmF0YXJzL2ZvbGRlci9jYXQuanBnP3Rva2VuPTxUT0tFTj5cIixcblx0KiAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2NhdC5qcGdcIixcblx0KiAgICAgXCJ0b2tlblwiOiBcIjxUT0tFTj5cIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKHBhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM0LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgX3BhdGggPSBfdGhpczQuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXM0LmhlYWRlcnMpO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHNlcnQpIGhlYWRlcnNbXCJ4LXVwc2VydFwiXSA9IFwidHJ1ZVwiO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLCB7fSwgeyBoZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgdXJsID0gbmV3IFVSTChfdGhpczQudXJsICsgZGF0YS51cmwpO1xuXHRcdFx0Y29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInRva2VuXCIpO1xuXHRcdFx0aWYgKCF0b2tlbikgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcIk5vIHRva2VuIHJldHVybmVkIGJ5IEFQSVwiKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNpZ25lZFVybDogdXJsLnRvU3RyaW5nKCksXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHRva2VuXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIE9wdGlvbmFsIGZpbGUgdXBsb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIHVwc2VydCwgYW5kIG1ldGFkYXRhLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCwgaWQsIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGF2YXRhckZpbGUgPSBldmVudC50YXJnZXQuZmlsZXNbMF1cblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGF2YXRhckZpbGUsIHtcblx0KiAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG5cdCogICAgIHVwc2VydDogdHJ1ZVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJwdWJsaWMvYXZhdGFyMS5wbmdcIixcblx0KiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvcHVibGljL2F2YXRhcjEucG5nXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcGRhdGUgZmlsZSB1c2luZyBgQXJyYXlCdWZmZXJgIGZyb20gYmFzZTY0IGZpbGUgZGF0YVxuXHQqIGBgYGpzXG5cdCogaW1wb3J0IHtkZWNvZGV9IGZyb20gJ2Jhc2U2NC1hcnJheWJ1ZmZlcidcblx0KlxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwZGF0ZSgncHVibGljL2F2YXRhcjEucG5nJywgZGVjb2RlKCdiYXNlNjRGaWxlRGF0YScpLCB7XG5cdCogICAgIGNvbnRlbnRUeXBlOiAnaW1hZ2UvcG5nJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBkYXRlKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKFwiUFVUXCIsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1uZXcucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIE1vdmUgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubW92ZSgncHVibGljL2F2YXRhcjEucG5nJywgJ3ByaXZhdGUvYXZhdGFyMi5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBtb3ZlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBtb3ZlKGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM2ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM2LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcG9zdChfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L29iamVjdC9tb3ZlYCwge1xuXHRcdFx0XHRidWNrZXRJZDogX3RoaXM2LmJ1Y2tldElkLFxuXHRcdFx0XHRzb3VyY2VLZXk6IGZyb21QYXRoLFxuXHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uQnVja2V0XG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDb3B5IGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNvcHkoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJhdmF0YXJzL3ByaXZhdGUvYXZhdGFyMi5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzNy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHsgcGF0aDogKGF3YWl0IHBvc3QoX3RoaXM3LmZldGNoLCBgJHtfdGhpczcudXJsfS9vYmplY3QvY29weWAsIHtcblx0XHRcdFx0YnVja2V0SWQ6IF90aGlzNy5idWNrZXRJZCxcblx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0ZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcblx0XHRcdFx0ZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldFxuXHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczcuaGVhZGVycyB9KSkuS2V5IH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTCBleHBpcmVzLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgYSBVUkwgd2hpY2ggaXMgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzaWduZWQgVVJMIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MClcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC9zaWduL2F2YXRhcnMvZm9sZGVyL2F2YXRhcjEucG5nP3Rva2VuPTxUT0tFTj5cIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBhIHNpZ25lZCBVUkwgZm9yIGFuIGFzc2V0IHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBhIHNpZ25lZCBVUkwgd2hpY2ggdHJpZ2dlcnMgdGhlIGRvd25sb2FkIG9mIHRoZSBhc3NldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwLCB7XG5cdCogICAgIGRvd25sb2FkOiB0cnVlLFxuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlU2lnbmVkVXJsKHBhdGgsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczggPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczguaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzOC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0bGV0IGRhdGEgPSBhd2FpdCBwb3N0KF90aGlzOC5mZXRjaCwgYCR7X3RoaXM4LnVybH0vb2JqZWN0L3NpZ24vJHtfcGF0aH1gLCBfb2JqZWN0U3ByZWFkMih7IGV4cGlyZXNJbiB9LCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgPyB7IHRyYW5zZm9ybTogb3B0aW9ucy50cmFuc2Zvcm0gfSA6IHt9KSwgeyBoZWFkZXJzOiBfdGhpczguaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyBcIlwiIDogb3B0aW9ucy5kb3dubG9hZH1gIDogXCJcIjtcblx0XHRcdHJldHVybiB7IHNpZ25lZFVybDogZW5jb2RlVVJJKGAke190aGlzOC51cmx9JHtkYXRhLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKSB9O1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgbXVsdGlwbGUgc2lnbmVkIFVSTHMuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG5cdCogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkxzIGV4cGlyZS4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIFVSTHMgd2hpY2ggYXJlIHZhbGlkIGZvciBvbmUgbWludXRlLlxuXHQqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIG9iamVjdHMgd2l0aCBzaWduZWRVcmwsIHBhdGgsIGFuZCBlcnJvciBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVUkxzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmxzKFsnZm9sZGVyL2F2YXRhcjEucG5nJywgJ2ZvbGRlci9hdmF0YXIyLnBuZyddLCA2MClcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJlcnJvclwiOiBudWxsLFxuXHQqICAgICAgIFwicGF0aFwiOiBcImZvbGRlci9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICAgIFwic2lnbmVkVVJMXCI6IFwiL29iamVjdC9zaWduL2F2YXRhcnMvZm9sZGVyL2F2YXRhcjEucG5nP3Rva2VuPTxUT0tFTj5cIixcblx0KiAgICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC9zaWduL2F2YXRhcnMvZm9sZGVyL2F2YXRhcjEucG5nP3Rva2VuPTxUT0tFTj5cIlxuXHQqICAgICB9LFxuXHQqICAgICB7XG5cdCogICAgICAgXCJlcnJvclwiOiBudWxsLFxuXHQqICAgICAgIFwicGF0aFwiOiBcImZvbGRlci9hdmF0YXIyLnBuZ1wiLFxuXHQqICAgICAgIFwic2lnbmVkVVJMXCI6IFwiL29iamVjdC9zaWduL2F2YXRhcnMvZm9sZGVyL2F2YXRhcjIucG5nP3Rva2VuPTxUT0tFTj5cIixcblx0KiAgICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC9zaWduL2F2YXRhcnMvZm9sZGVyL2F2YXRhcjIucG5nP3Rva2VuPTxUT0tFTj5cIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmxzKHBhdGhzLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM5ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM5LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdChfdGhpczkuZmV0Y2gsIGAke190aGlzOS51cmx9L29iamVjdC9zaWduLyR7X3RoaXM5LmJ1Y2tldElkfWAsIHtcblx0XHRcdFx0ZXhwaXJlc0luLFxuXHRcdFx0XHRwYXRoc1xuXHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczkuaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyBcIlwiIDogb3B0aW9ucy5kb3dubG9hZH1gIDogXCJcIjtcblx0XHRcdHJldHVybiBkYXRhLm1hcCgoZGF0dW0pID0+IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkYXR1bSksIHt9LCB7IHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMID8gZW5jb2RlVVJJKGAke190aGlzOS51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YCkgOiBudWxsIH0pKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHBhcmFtIHBhcmFtZXRlcnMgQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzIGxpa2Ugc2lnbmFsIGZvciBjYW5jZWxsYXRpb24uIFN1cHBvcnRzIHN0YW5kYXJkIGZldGNoIG9wdGlvbnMgaW5jbHVkaW5nIGNhY2hlIGNvbnRyb2wuXG5cdCogQHJldHVybnMgQmxvYkRvd25sb2FkQnVpbGRlciBpbnN0YW5jZSBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGVcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiA8QkxPQj4sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCBmaWxlIHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICAgIHF1YWxpdHk6IDgwXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCB3aXRoIGNhY2hlIGNvbnRyb2wgKHVzZWZ1bCBpbiBFZGdlIEZ1bmN0aW9ucylcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7fSwgeyBjYWNoZTogJ25vLXN0b3JlJyB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgRG93bmxvYWQgd2l0aCBhYm9ydCBzaWduYWxcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblx0KiBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNTAwMClcblx0KlxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7fSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pXG5cdCogYGBgXG5cdCovXG5cdGRvd25sb2FkKHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWRcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogXCJcIjtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRub1Jlc29sdmVKc29uOiB0cnVlXG5cdFx0fSwgcGFyYW1ldGVycyk7XG5cdFx0cmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmluZm8oJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGluZm8ocGF0aCkge1xuXHRcdHZhciBfdGhpczEwID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTAuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRyZXR1cm4gX3RoaXMxMC5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHJlY3Vyc2l2ZVRvQ2FtZWwoYXdhaXQgZ2V0KF90aGlzMTAuZmV0Y2gsIGAke190aGlzMTAudXJsfS9vYmplY3QvaW5mby8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMC5oZWFkZXJzIH0pKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBDaGVja3MgdGhlIGV4aXN0ZW5jZSBvZiBhIGZpbGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBib29sZWFuIGluZGljYXRpbmcgZmlsZSBleGlzdGVuY2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENoZWNrIGZpbGUgZXhpc3RlbmNlXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5leGlzdHMoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGV4aXN0cyhwYXRoKSB7XG5cdFx0dmFyIF90aGlzMTEgPSB0aGlzO1xuXHRcdGNvbnN0IF9wYXRoID0gX3RoaXMxMS5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBoZWFkKF90aGlzMTEuZmV0Y2gsIGAke190aGlzMTEudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7IGhlYWRlcnM6IF90aGlzMTEuaGVhZGVycyB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHRydWUsXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMS5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiBlcnJvciBpbnN0YW5jZW9mIFN0b3JhZ2VVbmtub3duRXJyb3IpIHtcblx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxFcnJvciA9IGVycm9yLm9yaWdpbmFsRXJyb3I7XG5cdFx0XHRcdGlmIChbNDAwLCA0MDRdLmluY2x1ZGVzKG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxFcnJvci5zdGF0dXMpKSByZXR1cm4ge1xuXHRcdFx0XHRcdGRhdGE6IGZhbHNlLFxuXHRcdFx0XHRcdGVycm9yXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQSBzaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLCB5b3UgY2FuIGNvbnN0cnVjdCB0aGUgcHVibGljIFVSTCBieSBjb25jYXRlbmF0aW5nIHRoZSBidWNrZXQgVVJMIHdpdGggdGhlIHBhdGggdG8gdGhlIGFzc2V0LlxuXHQqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdmVyaWZ5IGlmIHRoZSBidWNrZXQgaXMgcHVibGljLiBJZiBhIHB1YmxpYyBVUkwgaXMgY3JlYXRlZCBmb3IgYSBidWNrZXQgd2hpY2ggaXMgbm90IHB1YmxpYywgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQgdGhlIGFzc2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgT2JqZWN0IHdpdGggcHVibGljIFVSTFxuXHQqXG5cdCogQGV4YW1wbGUgUmV0dXJucyB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgncHVibGljLWJ1Y2tldCcpXG5cdCogICAuZ2V0UHVibGljVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicHVibGljVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3B1YmxpYy9wdWJsaWMtYnVja2V0L2ZvbGRlci9hdmF0YXIxLnBuZ1wiXG5cdCogICB9XG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgUmV0dXJucyB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgncHVibGljLWJ1Y2tldCcpXG5cdCogICAuZ2V0UHVibGljVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7XG5cdCogICAgIHRyYW5zZm9ybToge1xuXHQqICAgICAgIHdpZHRoOiAxMDAsXG5cdCogICAgICAgaGVpZ2h0OiAxMDAsXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgd2hpY2ggdHJpZ2dlcnMgdGhlIGRvd25sb2FkIG9mIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRnZXRQdWJsaWNVcmwocGF0aCwgb3B0aW9ucykge1xuXHRcdGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdGNvbnN0IF9xdWVyeVN0cmluZyA9IFtdO1xuXHRcdGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpID8gYGRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKGRvd25sb2FkUXVlcnlQYXJhbSk7XG5cdFx0Y29uc3QgcmVuZGVyUGF0aCA9IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgIT09IFwidW5kZWZpbmVkXCIgPyBcInJlbmRlci9pbWFnZVwiIDogXCJvYmplY3RcIjtcblx0XHRjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuXHRcdGlmICh0cmFuc2Zvcm1hdGlvblF1ZXJ5ICE9PSBcIlwiKSBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KTtcblx0XHRsZXQgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbihcIiZcIik7XG5cdFx0aWYgKHF1ZXJ5U3RyaW5nICE9PSBcIlwiKSBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gO1xuXHRcdHJldHVybiB7IGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9IH07XG5cdH1cblx0LyoqXG5cdCogRGVsZXRlcyBmaWxlcyB3aXRoaW4gdGhlIHNhbWUgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIEFuIGFycmF5IG9mIGZpbGVzIHRvIGRlbGV0ZSwgaW5jbHVkaW5nIHRoZSBwYXRoIGFuZCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIFtgJ2ZvbGRlci9pbWFnZS5wbmcnYF0uXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZGVsZXRlZCBmaWxlIG9iamVjdHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIERlbGV0ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5yZW1vdmUoWydmb2xkZXIvYXZhdGFyMS5wbmcnXSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW10sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHJlbW92ZShwYXRocykge1xuXHRcdHZhciBfdGhpczEyID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMxMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHJlbW92ZShfdGhpczEyLmZldGNoLCBgJHtfdGhpczEyLnVybH0vb2JqZWN0LyR7X3RoaXMxMi5idWNrZXRJZH1gLCB7IHByZWZpeGVzOiBwYXRocyB9LCB7IGhlYWRlcnM6IF90aGlzMTIuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBHZXQgZmlsZSBtZXRhZGF0YVxuXHQqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuXHQqL1xuXHQvKipcblx0KiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuXHQqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gbWV0YSB0aGUgbmV3IGZpbGUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogTGlzdHMgYWxsIHRoZSBmaWxlcyBhbmQgZm9sZGVycyB3aXRoaW4gYSBwYXRoIG9mIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuXHQqIEBwYXJhbSBvcHRpb25zIFNlYXJjaCBvcHRpb25zIGluY2x1ZGluZyBsaW1pdCAoZGVmYXVsdHMgdG8gMTAwKSwgb2Zmc2V0LCBzb3J0QnksIGFuZCBzZWFyY2hcblx0KiBAcGFyYW0gcGFyYW1ldGVycyBPcHRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBzaWduYWwgZm9yIGNhbmNlbGxhdGlvblxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGZpbGVzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGZpbGVzIGluIGEgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5saXN0KCdmb2xkZXInLCB7XG5cdCogICAgIGxpbWl0OiAxMDAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydEJ5OiB7IGNvbHVtbjogJ25hbWUnLCBvcmRlcjogJ2FzYycgfSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IFtcblx0KiAgICAge1xuXHQqICAgICAgIFwibmFtZVwiOiBcImF2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJpZFwiOiBcImU2NjhjZjdmLTgyMWItNGEyZi05ZGNlLTdkZmE1ZGQxY2ZkMlwiLFxuXHQqICAgICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTgwWlwiLFxuXHQqICAgICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDQ6MzQuNDQzWlwiLFxuXHQqICAgICAgIFwibGFzdF9hY2Nlc3NlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDQ6MzQuNDQzWlwiLFxuXHQqICAgICAgIFwibWV0YWRhdGFcIjoge1xuXHQqICAgICAgICAgXCJlVGFnXCI6IFwiXFxcImM1ZThjNTUzMjM1ZDlhZjMwZWY0ZjZlMjgwNzkwYjkyXFxcIlwiLFxuXHQqICAgICAgICAgXCJzaXplXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJtaW1ldHlwZVwiOiBcImltYWdlL3BuZ1wiLFxuXHQqICAgICAgICAgXCJjYWNoZUNvbnRyb2xcIjogXCJtYXgtYWdlPTM2MDBcIixcblx0KiAgICAgICAgIFwibGFzdE1vZGlmaWVkXCI6IFwiMjAyNC0wNS0yMlQyMzowNjowNS41NzRaXCIsXG5cdCogICAgICAgICBcImNvbnRlbnRMZW5ndGhcIjogMzIxNzUsXG5cdCogICAgICAgICBcImh0dHBTdGF0dXNDb2RlXCI6IDIwMFxuXHQqICAgICAgIH1cblx0KiAgICAgfVxuXHQqICAgXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFNlYXJjaCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICAgIHNlYXJjaDogJ2pvbidcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3QocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczEzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMxMy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX1NFQVJDSF9PUFRJT05TKSwgb3B0aW9ucyksIHt9LCB7IHByZWZpeDogcGF0aCB8fCBcIlwiIH0pO1xuXHRcdFx0cmV0dXJuIGF3YWl0IHBvc3QoX3RoaXMxMy5mZXRjaCwgYCR7X3RoaXMxMy51cmx9L29iamVjdC9saXN0LyR7X3RoaXMxMy5idWNrZXRJZH1gLCBib2R5LCB7IGhlYWRlcnM6IF90aGlzMTMuaGVhZGVycyB9LCBwYXJhbWV0ZXJzKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBAZXhwZXJpbWVudGFsIHRoaXMgbWV0aG9kIHNpZ25hdHVyZSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZVxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIHNlYXJjaCBvcHRpb25zXG5cdCogQHBhcmFtIHBhcmFtZXRlcnNcblx0Ki9cblx0YXN5bmMgbGlzdFYyKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgX3RoaXMxNCA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMTQuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IGJvZHkgPSBfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcG9zdChfdGhpczE0LmZldGNoLCBgJHtfdGhpczE0LnVybH0vb2JqZWN0L2xpc3QtdjIvJHtfdGhpczE0LmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxNC5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpO1xuXHRcdH0pO1xuXHR9XG5cdGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcblx0fVxuXHR0b0Jhc2U2NChkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHRyZXR1cm4gYnRvYShkYXRhKTtcblx0fVxuXHRfZ2V0RmluYWxQYXRoKHBhdGgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgXCJcIil9YDtcblx0fVxuXHRfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG5cdH1cblx0dHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cdFx0aWYgKHRyYW5zZm9ybS53aWR0aCkgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuXHRcdGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcblx0XHRpZiAodHJhbnNmb3JtLnJlc2l6ZSkgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5mb3JtYXQpIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjIuOTUuM1wiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbnN0YW50cy50c1xuY29uc3QgREVGQVVMVF9IRUFERVJTID0geyBcIlgtQ2xpZW50LUluZm9cIjogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAgfTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkudHNcbnZhciBTdG9yYWdlQnVja2V0QXBpID0gY2xhc3MgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEsIG9wdHMpIHtcblx0XHRjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuXHRcdGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlTmV3SG9zdG5hbWUpIHtcblx0XHRcdGlmICgvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSkgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoXCJzdG9yYWdlLnN1cGFiYXNlLlwiKSkgYmFzZVVybC5ob3N0bmFtZSA9IGJhc2VVcmwuaG9zdG5hbWUucmVwbGFjZShcInN1cGFiYXNlLlwiLCBcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpO1xuXHRcdH1cblx0XHRjb25zdCBmaW5hbFVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0Y29uc3QgZmluYWxIZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuXHRcdHN1cGVyKGZpbmFsVXJsLCBmaW5hbEhlYWRlcnMsIGZldGNoJDEsIFwic3RvcmFnZVwiKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ2lkJywgJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cygpXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHMgd2l0aCBvcHRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuXHQqICAgICBzZWFyY2g6ICdwcm9kJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBxdWVyeVN0cmluZyA9IF90aGlzLmxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKTtcblx0XHRcdHJldHVybiBhd2FpdCBnZXQoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vYnVja2V0JHtxdWVyeVN0cmluZ31gLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIFN0b3JhZ2UgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBidWNrZXQgZGV0YWlscyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgR2V0IGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZ2V0QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcImlkXCI6IFwiYXZhdGFyc1wiLFxuXHQqICAgICBcIm5hbWVcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwib3duZXJcIjogXCJcIixcblx0KiAgICAgXCJwdWJsaWNcIjogZmFsc2UsXG5cdCogICAgIFwiZmlsZV9zaXplX2xpbWl0XCI6IDEwMjQsXG5cdCogICAgIFwiYWxsb3dlZF9taW1lX3R5cGVzXCI6IFtcblx0KiAgICAgICBcImltYWdlL3BuZ1wiXG5cdCogICAgIF0sXG5cdCogICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiLFxuXHQqICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0QnVja2V0KGlkKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IGdldChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L2J1Y2tldC8ke2lkfWAsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlIGJ1Y2tldFxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy4gQnkgZGVmYXVsdCwgYnVja2V0cyBhcmUgcHJpdmF0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cblx0KiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG5cdCogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cblx0KiBAcGFyYW0gb3B0aW9ucy50eXBlIChwcml2YXRlLWJldGEpIHNwZWNpZmllcyB0aGUgYnVja2V0IHR5cGUuIHNlZSBgQnVja2V0VHlwZWAgZm9yIG1vcmUgZGV0YWlscy5cblx0KiAgIC0gZGVmYXVsdCBidWNrZXQgdHlwZSBpcyBgU1RBTkRBUkRgXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBidWNrZXQgbmFtZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuY3JlYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KGlkLCBvcHRpb25zID0geyBwdWJsaWM6IGZhbHNlIH0pIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldGAsIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG5hbWU6IGlkLFxuXHRcdFx0XHR0eXBlOiBvcHRpb25zLnR5cGUsXG5cdFx0XHRcdHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG5cdFx0XHRcdGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuXHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIHVwZGF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBVcGRhdGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC51cGRhdGVCdWNrZXQoJ2F2YXRhcnMnLCB7XG5cdCogICAgIHB1YmxpYzogZmFsc2UsXG5cdCogICAgIGFsbG93ZWRNaW1lVHlwZXM6IFsnaW1hZ2UvcG5nJ10sXG5cdCogICAgIGZpbGVTaXplTGltaXQ6IDEwMjRcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IHVwZGF0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBkYXRlQnVja2V0KGlkLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzNC5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHB1dChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L2J1Y2tldC8ke2lkfWAsIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG5hbWU6IGlkLFxuXHRcdFx0XHRwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuXHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0YWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXNcblx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBFbXB0eSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmVtcHR5QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBlbXB0eUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczUuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCBwb3N0KF90aGlzNS5mZXRjaCwgYCR7X3RoaXM1LnVybH0vYnVja2V0LyR7aWR9L2VtcHR5YCwge30sIHsgaGVhZGVyczogX3RoaXM1LmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogRGVsZXRlcyBhbiBleGlzdGluZyBidWNrZXQuIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdC5cblx0KiBZb3UgbXVzdCBmaXJzdCBgZW1wdHkoKWAgdGhlIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIERlbGV0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnYXZhdGFycycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGlkKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzNi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHJlbW92ZShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L2J1Y2tldC8ke2lkfWAsIHt9LCB7IGhlYWRlcnM6IF90aGlzNi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykgcGFyYW1zLmxpbWl0ID0gU3RyaW5nKG9wdGlvbnMubGltaXQpO1xuXHRcdFx0aWYgKFwib2Zmc2V0XCIgaW4gb3B0aW9ucykgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG5cdFx0XHRpZiAob3B0aW9ucy5zZWFyY2gpIHBhcmFtcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcblx0XHRcdGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHBhcmFtcy5zb3J0Q29sdW1uID0gb3B0aW9ucy5zb3J0Q29sdW1uO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydE9yZGVyKSBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogXCJcIjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NDbGllbnQudHNcbi8qKlxuKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4qIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgYW5hbHl0aWNzIGJ1Y2tldHNcbiovXG52YXIgU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IGNsYXNzIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IGluc3RhbmNlXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIHVybCAtIFRoZSBiYXNlIFVSTCBmb3IgdGhlIHN0b3JhZ2UgQVBJXG5cdCogQHBhcmFtIGhlYWRlcnMgLSBIVFRQIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiByZXF1ZXN0c1xuXHQqIEBwYXJhbSBmZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgY2xpZW50ID0gbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQodXJsLCBoZWFkZXJzKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdGNvbnN0IGZpbmFsVXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHRjb25zdCBmaW5hbEhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG5cdFx0c3VwZXIoZmluYWxVcmwsIGZpbmFsSGVhZGVycywgZmV0Y2gkMSwgXCJzdG9yYWdlXCIpO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyBhbmFseXRpY3MgYnVja2V0IHVzaW5nIEljZWJlcmcgdGFibGVzXG5cdCogQW5hbHl0aWNzIGJ1Y2tldHMgYXJlIG9wdGltaXplZCBmb3IgYW5hbHl0aWNhbCBxdWVyaWVzIGFuZCBkYXRhIHByb2Nlc3Npbmdcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gbmFtZSBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmdcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBuZXdseSBjcmVhdGVkIGFuYWx5dGljcyBidWNrZXQgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBhbmFseXRpY3MgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhbmFseXRpY3MtZGF0YVwiLFxuXHQqICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgXCJmb3JtYXRcIjogXCJpY2ViZXJnXCIsXG5cdCogICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiLFxuXHQqICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KG5hbWUpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vYnVja2V0YCwgeyBuYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgQW5hbHl0aWNzIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdFxuXHQqIE9ubHkgcmV0dXJucyBidWNrZXRzIG9mIHR5cGUgJ0FOQUxZVElDUydcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYW5hbHl0aWNzIGJ1Y2tldHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgYW5hbHl0aWNzIGJ1Y2tldHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmFuYWx5dGljc1xuXHQqICAgLmxpc3RCdWNrZXRzKHtcblx0KiAgICAgbGltaXQ6IDEwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRDb2x1bW46ICdjcmVhdGVkX2F0Jyxcblx0KiAgICAgc29ydE9yZGVyOiAnZGVzYydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IFtcblx0KiAgICAge1xuXHQqICAgICAgIFwibmFtZVwiOiBcImFuYWx5dGljcy1kYXRhXCIsXG5cdCogICAgICAgXCJ0eXBlXCI6IFwiQU5BTFlUSUNTXCIsXG5cdCogICAgICAgXCJmb3JtYXRcIjogXCJpY2ViZXJnXCIsXG5cdCogICAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgICAgfVxuXHQqICAgXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczIuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXHRcdFx0aWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBvcHRpb25zLm9mZnNldC50b1N0cmluZygpKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydENvbHVtbikgcXVlcnlQYXJhbXMuc2V0KFwic29ydENvbHVtblwiLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0T3JkZXIpIHF1ZXJ5UGFyYW1zLnNldChcInNvcnRPcmRlclwiLCBvcHRpb25zLnNvcnRPcmRlcik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KFwic2VhcmNoXCIsIG9wdGlvbnMuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7X3RoaXMyLnVybH0vYnVja2V0PyR7cXVlcnlTdHJpbmd9YCA6IGAke190aGlzMi51cmx9L2J1Y2tldGA7XG5cdFx0XHRyZXR1cm4gYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgdXJsLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhbiBleGlzdGluZyBhbmFseXRpY3MgYnVja2V0XG5cdCogQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0XG5cdCogWW91IG11c3QgZmlyc3QgZW1wdHkgdGhlIGJ1Y2tldCBiZWZvcmUgZGVsZXRpb25cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gYnVja2V0TmFtZSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIERlbGV0ZSBhbmFseXRpY3MgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5kZWxldGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZGVsZXRlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQoYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCByZW1vdmUoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9idWNrZXQvJHtidWNrZXROYW1lfWAsIHt9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcblx0KiBVc2UgdGhpcyB0byBwZXJmb3JtIGFkdmFuY2VkIHRhYmxlIGFuZCBuYW1lc3BhY2Ugb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqIFRoZSByZXR1cm5lZCBjbGllbnQgcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gdGhlIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUElcblx0KiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFuYWx5dGljcyBidWNrZXQgKHdhcmVob3VzZSkgdG8gY29ubmVjdCB0b1xuXHQqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcblx0KiBAdGhyb3dzIHtTdG9yYWdlRXJyb3J9IElmIHRoZSBidWNrZXQgbmFtZSBpcyBpbnZhbGlkXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG5cdCogYGBganNcblx0KiAvLyBGaXJzdCwgY3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcblx0KiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIEdldCB0aGUgSWNlYmVyZyBjYXRhbG9nIGZvciB0aGF0IGJ1Y2tldFxuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBDcmVhdGUgYSBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KlxuXHQqIC8vIENyZWF0ZSBhIHRhYmxlIHdpdGggc2NoZW1hXG5cdCogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9LFxuXHQqICAge1xuXHQqICAgICBuYW1lOiAnZXZlbnRzJyxcblx0KiAgICAgc2NoZW1hOiB7XG5cdCogICAgICAgdHlwZTogJ3N0cnVjdCcsXG5cdCogICAgICAgZmllbGRzOiBbXG5cdCogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuXHQqICAgICAgIF0sXG5cdCogICAgICAgJ3NjaGVtYS1pZCc6IDAsXG5cdCogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG5cdCogICAgIH0sXG5cdCogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcblx0KiAgICAgICAnc3BlYy1pZCc6IDAsXG5cdCogICAgICAgZmllbGRzOiBbXVxuXHQqICAgICB9LFxuXHQqICAgICAnd3JpdGUtb3JkZXInOiB7XG5cdCogICAgICAgJ29yZGVyLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgIHByb3BlcnRpZXM6IHtcblx0KiAgICAgICAnd3JpdGUuZm9ybWF0LmRlZmF1bHQnOiAncGFycXVldCdcblx0KiAgICAgfVxuXHQqICAgfVxuXHQqIClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgdGFibGVzIGluIG5hbWVzcGFjZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlcywgZXJyb3I6IGxpc3RFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGlmIChsaXN0RXJyb3IpIHtcblx0KiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG5cdCogICAgIGNvbnNvbGUubG9nKCdOYW1lc3BhY2Ugbm90IGZvdW5kJylcblx0KiAgIH1cblx0KiAgIHJldHVyblxuXHQqIH1cblx0KiBjb25zb2xlLmxvZyh0YWJsZXMpIC8vIFt7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH1dXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBXb3JraW5nIHdpdGggbmFtZXNwYWNlc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcblx0KiBjb25zdCB7IGRhdGE6IG5hbWVzcGFjZXMgfSA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKVxuXHQqXG5cdCogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcblx0KiBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ3Byb2R1Y3Rpb24nXSB9LFxuXHQqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ2xlYW51cCBvcGVyYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gRHJvcCB0YWJsZSB3aXRoIHB1cmdlIG9wdGlvbiAocmVtb3ZlcyBhbGwgZGF0YSlcblx0KiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddLCBuYW1lOiAnZXZlbnRzJyB9LFxuXHQqICAgeyBwdXJnZTogdHJ1ZSB9XG5cdCogKVxuXHQqXG5cdCogaWYgKGRyb3BFcnJvcj8uaXNOb3RGb3VuZCgpKSB7XG5cdCogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuXHQqIH1cblx0KlxuXHQqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuXHQqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KiBgYGBcblx0KlxuXHQqIEByZW1hcmtzXG5cdCogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBTdXBhYmFzZSdzIGJ1Y2tldCBtYW5hZ2VtZW50IGFuZCB0aGUgc3RhbmRhcmRcblx0KiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuXHQqIEFsbCBhdXRoZW50aWNhdGlvbiBhbmQgY29uZmlndXJhdGlvbiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBTdXBhYmFzZSBjcmVkZW50aWFscy5cblx0KlxuXHQqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG5cdCogb3BlcmF0aW9ucyByZXR1cm4gYHsgZGF0YSwgZXJyb3IgfWAgd2hlcmUgZXJyb3JzIGFyZSBgSWNlYmVyZ0Vycm9yYCBpbnN0YW5jZXMgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIFVzZSBoZWxwZXIgbWV0aG9kcyBsaWtlIGBlcnJvci5pc05vdEZvdW5kKClgIG9yIGNoZWNrIGBlcnJvci5zdGF0dXNgIGZvciBzcGVjaWZpYyBlcnJvciBoYW5kbGluZy5cblx0KiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKkNsZWFudXAgT3BlcmF0aW9ucyoqOiBXaGVuIHVzaW5nIGBkcm9wVGFibGVgLCB0aGUgYHB1cmdlOiB0cnVlYCBvcHRpb24gcGVybWFuZW50bHlcblx0KiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cblx0KlxuXHQqICoqTGlicmFyeSBEZXBlbmRlbmN5Kio6IFRoZSByZXR1cm5lZCBjYXRhbG9nIHdyYXBzIGBJY2ViZXJnUmVzdENhdGFsb2dgIGZyb20gaWNlYmVyZy1qcy5cblx0KiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcblx0KiBbaWNlYmVyZy1qcyBkb2N1bWVudGF0aW9uXShodHRwczovL3N1cGFiYXNlLmdpdGh1Yi5pby9pY2ViZXJnLWpzLykuXG5cdCovXG5cdGZyb20oYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdGlmICghaXNWYWxpZEJ1Y2tldE5hbWUoYnVja2V0TmFtZSkpIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIGJ1Y2tldCBuYW1lOiBGaWxlLCBmb2xkZXIsIGFuZCBidWNrZXQgbmFtZXMgbXVzdCBmb2xsb3cgQVdTIG9iamVjdCBrZXkgbmFtaW5nIGd1aWRlbGluZXMgYW5kIHNob3VsZCBhdm9pZCB0aGUgdXNlIG9mIGFueSBvdGhlciBjaGFyYWN0ZXJzLlwiKTtcblx0XHRjb25zdCBjYXRhbG9nID0gbmV3IEljZWJlcmdSZXN0Q2F0YWxvZyh7XG5cdFx0XHRiYXNlVXJsOiB0aGlzLnVybCxcblx0XHRcdGNhdGFsb2dOYW1lOiBidWNrZXROYW1lLFxuXHRcdFx0YXV0aDoge1xuXHRcdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0XHRnZXRIZWFkZXJzOiBhc3luYyAoKSA9PiBfdGhpczQuaGVhZGVyc1xuXHRcdFx0fSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdFx0Y29uc3Qgc2hvdWxkVGhyb3dPbkVycm9yID0gdGhpcy5zaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0cmV0dXJuIG5ldyBQcm94eShjYXRhbG9nLCB7IGdldCh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdmFsdWU7XG5cdFx0XHRyZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogYXdhaXQgdmFsdWUuYXBwbHkodGFyZ2V0LCBhcmdzKSxcblx0XHRcdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAoc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0XHRcdGVycm9yXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvVmVjdG9ySW5kZXhBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBpbmRleCBvcGVyYXRpb25zLlxuKiBVc2Uge0BsaW5rIFZlY3RvckJ1Y2tldFNjb3BlfSB2aWEgYHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdidWNrZXQnKWAgaW5zdGVhZC5cbiovXG52YXIgVmVjdG9ySW5kZXhBcGkgPSBjbGFzcyBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JJbmRleEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdGNvbnN0IGZpbmFsVXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHRjb25zdCBmaW5hbEhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwge30sIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgaGVhZGVycyk7XG5cdFx0c3VwZXIoZmluYWxVcmwsIGZpbmFsSGVhZGVycywgZmV0Y2gkMSwgXCJ2ZWN0b3JzXCIpO1xuXHR9XG5cdC8qKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCB3aXRoaW4gYSBidWNrZXQgKi9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L0NyZWF0ZUluZGV4YCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pIHx8IHt9O1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4ICovXG5cdGFzeW5jIGdldEluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczIuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMyLmZldGNoLCBgJHtfdGhpczIudXJsfS9HZXRJbmRleGAsIHtcblx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3IgaW5kZXhlcyB3aXRoaW4gYSBidWNrZXQgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gKi9cblx0YXN5bmMgbGlzdEluZGV4ZXMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0SW5kZXhlc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgaW5kZXggYW5kIGFsbCBpdHMgZGF0YSAqL1xuXHRhc3luYyBkZWxldGVJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM0LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlSW5kZXhgLCB7XG5cdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdGluZGV4TmFtZVxuXHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSB8fCB7fTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1ZlY3RvckRhdGFBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9ySW5kZXhTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JykuaW5kZXgoJ2lkeCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JEYXRhQXBpID0gY2xhc3MgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yRGF0YUFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdGNvbnN0IGZpbmFsVXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHRjb25zdCBmaW5hbEhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwge30sIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgaGVhZGVycyk7XG5cdFx0c3VwZXIoZmluYWxVcmwsIGZpbmFsSGVhZGVycywgZmV0Y2gkMSwgXCJ2ZWN0b3JzXCIpO1xuXHR9XG5cdC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgdmVjdG9ycyBpbiBiYXRjaCAoMS01MDAgcGVyIHJlcXVlc3QpICovXG5cdGFzeW5jIHB1dFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0aWYgKG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPCAxIHx8IG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIlZlY3RvciBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0cmV0dXJuIF90aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L1B1dFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge307XG5cdFx0fSk7XG5cdH1cblx0LyoqIFJldHJpZXZlcyB2ZWN0b3JzIGJ5IHRoZWlyIGtleXMgaW4gYmF0Y2ggKi9cblx0YXN5bmMgZ2V0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3JzIGluIGFuIGluZGV4IHdpdGggcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50ICE9PSB2b2lkIDApIHtcblx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCA8IDEgfHwgb3B0aW9ucy5zZWdtZW50Q291bnQgPiAxNikgdGhyb3cgbmV3IEVycm9yKFwic2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNlwiKTtcblx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRJbmRleCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRJbmRleCA8IDAgfHwgb3B0aW9ucy5zZWdtZW50SW5kZXggPj0gb3B0aW9ucy5zZWdtZW50Q291bnQpIHRocm93IG5ldyBFcnJvcihgc2VnbWVudEluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke29wdGlvbnMuc2VnbWVudENvdW50IC0gMX1gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF90aGlzMy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIHVzaW5nIGFwcHJveGltYXRlIG5lYXJlc3QgbmVpZ2hib3Igc2VhcmNoICovXG5cdGFzeW5jIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzNC5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L1F1ZXJ5VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIERlbGV0ZXMgdmVjdG9ycyBieSB0aGVpciBrZXlzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cblx0YXN5bmMgZGVsZXRlVmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cdFx0aWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIktleXMgYmF0Y2ggc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAwIGl0ZW1zXCIpO1xuXHRcdHJldHVybiBfdGhpczUuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9EZWxldGVWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KSB8fCB7fTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1ZlY3RvckJ1Y2tldEFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGJ1Y2tldCBvcGVyYXRpb25zLlxuKiBVc2Uge0BsaW5rIFN0b3JhZ2VWZWN0b3JzQ2xpZW50fSB2aWEgYHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9yc2AgaW5zdGVhZC5cbiovXG52YXIgVmVjdG9yQnVja2V0QXBpID0gY2xhc3MgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yQnVja2V0QXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0Y29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGZpbmFsSGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCB7fSwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBoZWFkZXJzKTtcblx0XHRzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCQxLCBcInZlY3RvcnNcIik7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L0NyZWF0ZVZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge307XG5cdFx0fSk7XG5cdH1cblx0LyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldFZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3IgYnVja2V0cyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vTGlzdFZlY3RvckJ1Y2tldHNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAobXVzdCBiZSBlbXB0eSBmaXJzdCkgKi9cblx0YXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM0LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge307XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdG9yYWdlVmVjdG9yc0NsaWVudC50c1xuLyoqXG4qXG4qIEBhbHBoYVxuKlxuKiBNYWluIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBTMyBWZWN0b3JzIEFQSVxuKiBQcm92aWRlcyBhY2Nlc3MgdG8gYnVja2V0LCBpbmRleCwgYW5kIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbipcbiogKipVc2FnZSBQYXR0ZXJuczoqKlxuKlxuKiBgYGB0eXBlc2NyaXB0XG4qIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4qICAuc3RvcmFnZVxuKiAgLnZlY3RvcnNcbiogIC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4qXG4qIC8vIEFjY2VzcyBpbmRleCBvcGVyYXRpb25zIHZpYSBidWNrZXRzXG4qIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cycsXG4qICAgZGF0YVR5cGU6ICdmbG9hdDMyJyxcbiogICBkaW1lbnNpb246IDE1MzYsXG4qICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnXG4qIH0pXG4qXG4qIC8vIEFjY2VzcyB2ZWN0b3Igb3BlcmF0aW9ucyB2aWEgaW5kZXhcbiogY29uc3QgaW5kZXggPSBidWNrZXQuaW5kZXgoJ2RvY3VtZW50cycpXG4qIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuKiAgIHZlY3RvcnM6IFtcbiogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuKiAgIF1cbiogfSlcbipcbiogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG4qIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcbiogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuKiAgIHRvcEs6IDUsXG4qICAgcmV0dXJuRGlzdGFuY2U6IHRydWVcbiogfSlcbiogYGBgXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JCdWNrZXRBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBTdG9yYWdlVmVjdG9yc0NsaWVudCB0aGF0IGNhbiBtYW5hZ2UgYnVja2V0cywgaW5kZXhlcywgYW5kIHZlY3RvcnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHVybCAtIEJhc2UgVVJMIG9mIHRoZSBTdG9yYWdlIFZlY3RvcnMgUkVTVCBBUEkuXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIE9wdGlvbmFsIGhlYWRlcnMgKGZvciBleGFtcGxlIGBBdXRob3JpemF0aW9uYCkgYXBwbGllZCB0byBldmVyeSByZXF1ZXN0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gZm9yIG5vbi1icm93c2VyIHJ1bnRpbWVzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgY2xpZW50ID0gbmV3IFN0b3JhZ2VWZWN0b3JzQ2xpZW50KHVybCwgb3B0aW9ucylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcih1cmwsIG9wdGlvbnMuaGVhZGVycyB8fCB7fSwgb3B0aW9ucy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0XG5cdCogQHJldHVybnMgQnVja2V0LXNjb3BlZCBjbGllbnQgd2l0aCBpbmRleCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IFZlY3RvckJ1Y2tldFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIHRoaXMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBidWNrZXRcblx0KiBWZWN0b3IgYnVja2V0cyBhcmUgY29udGFpbmVycyBmb3IgdmVjdG9yIGluZGV4ZXMgYW5kIHRoZWlyIGRhdGFcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIFVuaXF1ZSBuYW1lIGZvciB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmNyZWF0ZUJ1Y2tldCwgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCgpLmNhbGwoX3RoaXMsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBidWNrZXQgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5nZXRCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCpcblx0KiBjb25zb2xlLmxvZygnQnVja2V0IGNyZWF0ZWQ6JywgZGF0YT8udmVjdG9yQnVja2V0LmNyZWF0aW9uVGltZSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRCdWNrZXQgPSAoKSA9PiBzdXBlci5nZXRCdWNrZXQsIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0KCkuY2FsbChfdGhpczIsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBhbGwgdmVjdG9yIGJ1Y2tldHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGZpbHRlcnMgKHByZWZpeCwgbWF4UmVzdWx0cywgbmV4dFRva2VuKVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBsaXN0IG9mIGJ1Y2tldHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5saXN0QnVja2V0cyh7IHByZWZpeDogJ2VtYmVkZGluZ3MtJyB9KVxuXHQqXG5cdCogZGF0YT8udmVjdG9yQnVja2V0cy5mb3JFYWNoKGJ1Y2tldCA9PiB7XG5cdCogICBjb25zb2xlLmxvZyhidWNrZXQudmVjdG9yQnVja2V0TmFtZSlcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyA9ICgpID0+IHN1cGVyLmxpc3RCdWNrZXRzLCBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldExpc3RCdWNrZXRzKCkuY2FsbChfdGhpczMsIG9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAoYnVja2V0IG11c3QgYmUgZW1wdHkpXG5cdCogQWxsIGluZGV4ZXMgbXVzdCBiZSBkZWxldGVkIGJlZm9yZSBkZWxldGluZyB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZGVsZXRlQnVja2V0KCdlbWJlZGRpbmdzLW9sZCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0ID0gKCkgPT4gc3VwZXIuZGVsZXRlQnVja2V0LCBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCgpLmNhbGwoX3RoaXM0LCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG4qIFByb3ZpZGVzIGluZGV4IG1hbmFnZW1lbnQgYW5kIGFjY2VzcyB0byB2ZWN0b3Igb3BlcmF0aW9uc1xuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRTY29wZSA9IGNsYXNzIGV4dGVuZHMgVmVjdG9ySW5kZXhBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgaW5kZXggb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0LlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIEluZGV4IGNvbmZpZ3VyYXRpb24gKHZlY3RvckJ1Y2tldE5hbWUgaXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG5cdCogICBpbmRleE5hbWU6ICdkb2N1bWVudHMtb3BlbmFpJyxcblx0KiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG5cdCogICBkaW1lbnNpb246IDE1MzYsXG5cdCogICBkaXN0YW5jZU1ldHJpYzogJ2Nvc2luZScsXG5cdCogICBtZXRhZGF0YUNvbmZpZ3VyYXRpb246IHtcblx0KiAgICAgbm9uRmlsdGVyYWJsZU1ldGFkYXRhS2V5czogWydyYXdfdGV4dCddXG5cdCogICB9XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4ID0gKCkgPT4gc3VwZXIuY3JlYXRlSW5kZXgsIF90aGlzNSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgoKS5jYWxsKF90aGlzNSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczUudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIExpc3RzIGluZGV4ZXMgaW4gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGluZGV4ZXMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0Lmxpc3RJbmRleGVzKHsgcHJlZml4OiAnZG9jdW1lbnRzLScgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEluZGV4ZXMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMgPSAoKSA9PiBzdXBlci5saXN0SW5kZXhlcywgX3RoaXM2ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0SW5kZXhlcygpLmNhbGwoX3RoaXM2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzNi52ZWN0b3JCdWNrZXROYW1lIH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gcmV0cmlldmVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggaW5kZXggbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0LmdldEluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zb2xlLmxvZygnRGltZW5zaW9uOicsIGRhdGE/LmluZGV4LmRpbWVuc2lvbilcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0SW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXggPSAoKSA9PiBzdXBlci5nZXRJbmRleCwgX3RoaXM3ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRJbmRleCgpLmNhbGwoX3RoaXM3LCBfdGhpczcudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhbiBpbmRleCBmcm9tIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5kZWxldGVJbmRleCgnb2xkLWluZGV4Jylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlSW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXggPSAoKSA9PiBzdXBlci5kZWxldGVJbmRleCwgX3RoaXM4ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCgpLmNhbGwoX3RoaXM4LCBfdGhpczgudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIG9wZXJhdGlvbnMgZm9yIGEgc3BlY2lmaWMgaW5kZXggd2l0aGluIHRoaXMgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcblx0KiBAcmV0dXJucyBJbmRleC1zY29wZWQgY2xpZW50IHdpdGggdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqXG5cdCogLy8gSW5zZXJ0IHZlY3RvcnNcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAgeyBrZXk6ICdkb2MtMScsIGRhdGE6IHsgZmxvYXQzMjogWy4uLl0gfSwgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRybycgfSB9XG5cdCogICBdXG5cdCogfSlcblx0KlxuXHQqIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFsuLi5dIH0sXG5cdCogICB0b3BLOiA1XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0aW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JJbmRleFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHRoaXMudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCB0aGlzLmZldGNoKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXhcbiogUHJvdmlkZXMgdmVjdG9yIGRhdGEgb3BlcmF0aW9ucyAocHV0LCBnZXQsIGxpc3QsIHF1ZXJ5LCBkZWxldGUpXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qL1xudmFyIFZlY3RvckluZGV4U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckRhdGFBcGkge1xuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIGhlbHBlciB0aGF0IGF1dG9tYXRpY2FsbHkgc2NvcGVzIGFsbCB2ZWN0b3Igb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0L2luZGV4IG5hbWVzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdFx0dGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciBpbnNlcnRpb24gb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuXHQqICAgdmVjdG9yczogW1xuXHQqICAgICB7XG5cdCogICAgICAga2V5OiAnZG9jLTEnLFxuXHQqICAgICAgIGRhdGE6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAuLi5dIH0sXG5cdCogICAgICAgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRyb2R1Y3Rpb24nLCBwYWdlOiAxIH1cblx0KiAgICAgfVxuXHQqICAgXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHB1dFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMgPSAoKSA9PiBzdXBlci5wdXRWZWN0b3JzLCBfdGhpczkgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMoKS5jYWxsKF90aGlzOSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXM5LnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzOS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgcmV0cmlldmFsIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXguZ2V0VmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJ10sXG5cdCogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMgPSAoKSA9PiBzdXBlci5nZXRWZWN0b3JzLCBfdGhpczEwID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzKCkuY2FsbChfdGhpczEwLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEwLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTAuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyB2ZWN0b3JzIGluIHRoaXMgaW5kZXggd2l0aCBwYWdpbmF0aW9uXG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBMaXN0aW5nIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBhbmQgcGFnaW5hdGlvbiB0b2tlbiBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgubGlzdFZlY3RvcnMoe1xuXHQqICAgbWF4UmVzdWx0czogNTAwLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycyA9ICgpID0+IHN1cGVyLmxpc3RWZWN0b3JzLCBfdGhpczExID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycygpLmNhbGwoX3RoaXMxMSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczExLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXJ5IG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbWF0Y2hlcyBhcnJheSBvZiBzaW1pbGFyIHZlY3RvcnMgb3JkZXJlZCBieSBkaXN0YW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgdG9wSzogNSxcblx0KiAgIGZpbHRlcjogeyBjYXRlZ29yeTogJ3RlY2huaWNhbCcgfSxcblx0KiAgIHJldHVybkRpc3RhbmNlOiB0cnVlLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyA9ICgpID0+IHN1cGVyLnF1ZXJ5VmVjdG9ycywgX3RoaXMxMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0UXVlcnlWZWN0b3JzKCkuY2FsbChfdGhpczEyLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEyLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTIuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIHZlY3RvcnMgYnkga2V5cyBmcm9tIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIERlbGV0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5kZWxldGVWZWN0b3JzKHtcblx0KiAgIGtleXM6IFsnZG9jLTEnLCAnZG9jLTInLCAnZG9jLTMnXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMgPSAoKSA9PiBzdXBlci5kZWxldGVWZWN0b3JzLCBfdGhpczEzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzKCkuY2FsbChfdGhpczEzLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEzLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTMuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvU3RvcmFnZUNsaWVudC50c1xudmFyIFN0b3JhZ2VDbGllbnQgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgY2xpZW50IGZvciBTdG9yYWdlIGJ1Y2tldHMsIGZpbGVzLCBhbmFseXRpY3MsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgeyBTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5cdCpcblx0KiBjb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxJywge1xuXHQqICAgYXBpa2V5OiAncHVibGljLWFub24ta2V5Jyxcblx0KiB9KVxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSwgb3B0cykge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSwgb3B0cyk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYXZhdGFycyA9IHN1cGFiYXNlLnN0b3JhZ2UuZnJvbSgnYXZhdGFycycpXG5cdCogYGBgXG5cdCovXG5cdGZyb20oaWQpIHtcblx0XHRyZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIHZlY3RvciBzdG9yYWdlIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlVmVjdG9yc0NsaWVudCBpbnN0YW5jZSBjb25maWd1cmVkIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBzZXR0aW5ncy5cblx0Ki9cblx0Z2V0IHZlY3RvcnMoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh0aGlzLnVybCArIFwiL3ZlY3RvclwiLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3MgYW5hbHl0aWNzIHN0b3JhZ2Ugb3BlcmF0aW9ucyB1c2luZyBJY2ViZXJnIHRhYmxlcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBBIFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCBhbmFseXRpY3MoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50KHRoaXMudXJsICsgXCIvaWNlYmVyZ1wiLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQsIFN0b3JhZ2VBcGlFcnJvciwgU3RvcmFnZUNsaWVudCwgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yLCBTdG9yYWdlVmVjdG9yc0FwaUVycm9yLCBTdG9yYWdlVmVjdG9yc0NsaWVudCwgU3RvcmFnZVZlY3RvcnNFcnJvciwgU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUsIFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yLCBWZWN0b3JCdWNrZXRBcGksIFZlY3RvckJ1Y2tldFNjb3BlLCBWZWN0b3JEYXRhQXBpLCBWZWN0b3JJbmRleEFwaSwgVmVjdG9ySW5kZXhTY29wZSwgaXNTdG9yYWdlRXJyb3IsIGlzU3RvcmFnZVZlY3RvcnNFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJJY2ViZXJnUmVzdENhdGFsb2ciLCJTdG9yYWdlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWVzcGFjZSIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJfX2lzU3RvcmFnZUVycm9yIiwibmFtZSIsImlzU3RvcmFnZUVycm9yIiwiZXJyb3IiLCJTdG9yYWdlQXBpRXJyb3IiLCJ0b0pTT04iLCJTdG9yYWdlVW5rbm93bkVycm9yIiwib3JpZ2luYWxFcnJvciIsIlN0b3JhZ2VWZWN0b3JzRXJyb3IiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0FwaUVycm9yIiwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSIsIlN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpdGVyYXRvciIsInJlY3Vyc2l2ZVRvQ2FtZWwiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZWwiLCJyZXN1bHQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsIm5ld0tleSIsInJlcGxhY2UiLCJjIiwidG9VcHBlckNhc2UiLCJpc1ZhbGlkQnVja2V0TmFtZSIsImJ1Y2tldE5hbWUiLCJsZW5ndGgiLCJ0cmltIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiX3R5cGVvZiIsIm8iLCJvJDEiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2dldEVycm9yTWVzc2FnZSIsImVyciIsIl9lcnIkZXJyb3IiLCJtc2ciLCJlcnJvcl9kZXNjcmlwdGlvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYW5kbGVFcnJvciIsInJlamVjdCIsIm9wdGlvbnMiLCJub1Jlc29sdmVKc29uIiwicmVzcG9uc2VFcnJvciIsImpzb24iLCJ0aGVuIiwiY29kZSIsImNhdGNoIiwic3RhdHVzVGV4dCIsIl9nZXRSZXF1ZXN0UGFyYW1zIiwibWV0aG9kIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZHVwbGV4IiwiX2hhbmRsZVJlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvayIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiZGF0YSIsImNyZWF0ZUZldGNoQXBpIiwicG9zdCIsInB1dCIsImhlYWQiLCJyZW1vdmUiLCJkZWZhdWx0QXBpIiwidmVjdG9yc0FwaSIsIkJhc2VBcGlDbGllbnQiLCJ0aHJvd09uRXJyb3IiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJoYW5kbGVPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJfdGhpcyIsImZldGNoJDEiLCJTdHJlYW1Eb3dubG9hZEJ1aWxkZXIiLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJleGVjdXRlIiwiZG93bmxvYWRGbiIsIl9TeW1ib2wkdG9TdHJpbmdUYWciLCJCbG9iRG93bmxvYWRCdWlsZGVyIiwiYXNTdHJlYW0iLCJnZXRQcm9taXNlIiwiZmluYWxseSIsIm9uZmluYWxseSIsInByb21pc2UiLCJibG9iIiwiREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyIsImxpbWl0Iiwib2Zmc2V0Iiwic29ydEJ5IiwiY29sdW1uIiwib3JkZXIiLCJERUZBVUxUX0ZJTEVfT1BUSU9OUyIsImNhY2hlQ29udHJvbCIsInVwc2VydCIsIlN0b3JhZ2VGaWxlQXBpIiwidXBsb2FkT3JVcGRhdGUiLCJwYXRoIiwiZmlsZUJvZHkiLCJmaWxlT3B0aW9ucyIsIm1ldGFkYXRhIiwiQmxvYiIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiZW5jb2RlTWV0YWRhdGEiLCJoYXMiLCJ0b0Jhc2U2NCIsIlJlYWRhYmxlU3RyZWFtIiwicGlwZSIsImNsZWFuUGF0aCIsIl9yZW1vdmVFbXB0eUZvbGRlcnMiLCJfcGF0aCIsIl9nZXRGaW5hbFBhdGgiLCJpZCIsIklkIiwiZnVsbFBhdGgiLCJLZXkiLCJ1cGxvYWQiLCJ1cGxvYWRUb1NpZ25lZFVybCIsInRva2VuIiwiX3RoaXMzIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJjcmVhdGVTaWduZWRVcGxvYWRVcmwiLCJfdGhpczQiLCJzaWduZWRVcmwiLCJ1cGRhdGUiLCJtb3ZlIiwiZnJvbVBhdGgiLCJ0b1BhdGgiLCJfdGhpczYiLCJidWNrZXRJZCIsInNvdXJjZUtleSIsImRlc3RpbmF0aW9uS2V5IiwiZGVzdGluYXRpb25CdWNrZXQiLCJjb3B5IiwiX3RoaXM3IiwiY3JlYXRlU2lnbmVkVXJsIiwiZXhwaXJlc0luIiwiX3RoaXM4IiwidHJhbnNmb3JtIiwiZG93bmxvYWRRdWVyeVBhcmFtIiwiZG93bmxvYWQiLCJlbmNvZGVVUkkiLCJzaWduZWRVUkwiLCJjcmVhdGVTaWduZWRVcmxzIiwicGF0aHMiLCJfdGhpczkiLCJkYXR1bSIsInJlbmRlclBhdGgiLCJ0cmFuc2Zvcm1hdGlvblF1ZXJ5IiwidHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmciLCJxdWVyeVN0cmluZyIsImluZm8iLCJfdGhpczEwIiwiZXhpc3RzIiwiX3RoaXMxMSIsImdldFB1YmxpY1VybCIsIl9xdWVyeVN0cmluZyIsImpvaW4iLCJwdWJsaWNVcmwiLCJfdGhpczEyIiwicHJlZml4ZXMiLCJsaXN0IiwiX3RoaXMxMyIsInByZWZpeCIsImxpc3RWMiIsIl90aGlzMTQiLCJCdWZmZXIiLCJmcm9tIiwiYnRvYSIsIndpZHRoIiwiaGVpZ2h0IiwicmVzaXplIiwiZm9ybWF0IiwicXVhbGl0eSIsInZlcnNpb24iLCJERUZBVUxUX0hFQURFUlMiLCJTdG9yYWdlQnVja2V0QXBpIiwibGlzdEJ1Y2tldHMiLCJsaXN0QnVja2V0T3B0aW9uc1RvUXVlcnlTdHJpbmciLCJnZXRCdWNrZXQiLCJfdGhpczIiLCJjcmVhdGVCdWNrZXQiLCJwdWJsaWMiLCJ0eXBlIiwiZmlsZV9zaXplX2xpbWl0IiwiZmlsZVNpemVMaW1pdCIsImFsbG93ZWRfbWltZV90eXBlcyIsImFsbG93ZWRNaW1lVHlwZXMiLCJ1cGRhdGVCdWNrZXQiLCJlbXB0eUJ1Y2tldCIsIl90aGlzNSIsImRlbGV0ZUJ1Y2tldCIsInNlYXJjaCIsInNvcnRDb2x1bW4iLCJzb3J0T3JkZXIiLCJVUkxTZWFyY2hQYXJhbXMiLCJvcHRzIiwiYmFzZVVybCIsInVzZU5ld0hvc3RuYW1lIiwiaG9zdG5hbWUiLCJmaW5hbFVybCIsImhyZWYiLCJmaW5hbEhlYWRlcnMiLCJTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IiwicXVlcnlQYXJhbXMiLCJjYXRhbG9nIiwiY2F0YWxvZ05hbWUiLCJhdXRoIiwiZ2V0SGVhZGVycyIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsIlZlY3RvckluZGV4QXBpIiwiY3JlYXRlSW5kZXgiLCJnZXRJbmRleCIsInZlY3RvckJ1Y2tldE5hbWUiLCJpbmRleE5hbWUiLCJsaXN0SW5kZXhlcyIsImRlbGV0ZUluZGV4IiwiVmVjdG9yRGF0YUFwaSIsInB1dFZlY3RvcnMiLCJ2ZWN0b3JzIiwiZ2V0VmVjdG9ycyIsImxpc3RWZWN0b3JzIiwic2VnbWVudENvdW50Iiwic2VnbWVudEluZGV4IiwicXVlcnlWZWN0b3JzIiwiZGVsZXRlVmVjdG9ycyIsIlZlY3RvckJ1Y2tldEFwaSIsIlN0b3JhZ2VWZWN0b3JzQ2xpZW50IiwiVmVjdG9yQnVja2V0U2NvcGUiLCJfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0R2V0QnVja2V0IiwiX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0IiwiX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCIsIl9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMiLCJfc3VwZXJwcm9wX2dldEdldEluZGV4IiwiX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCIsImluZGV4IiwiVmVjdG9ySW5kZXhTY29wZSIsIl9zdXBlcnByb3BfZ2V0UHV0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycyIsIlN0b3JhZ2VDbGllbnQiLCJhbmFseXRpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/index.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthAdminApi; },\n/* harmony export */   AuthApiError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthApiError; },\n/* harmony export */   AuthClient: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient; },\n/* harmony export */   AuthError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthError; },\n/* harmony export */   AuthImplicitGrantRedirectError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError; },\n/* harmony export */   AuthInvalidCredentialsError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError; },\n/* harmony export */   AuthInvalidJwtError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError; },\n/* harmony export */   AuthInvalidTokenResponseError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError; },\n/* harmony export */   AuthPKCECodeVerifierMissingError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError; },\n/* harmony export */   AuthPKCEGrantCodeExchangeError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError; },\n/* harmony export */   AuthRetryableFetchError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError; },\n/* harmony export */   AuthSessionMissingError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError; },\n/* harmony export */   AuthUnknownError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError; },\n/* harmony export */   AuthWeakPasswordError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError; },\n/* harmony export */   CustomAuthError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.CustomAuthError; },\n/* harmony export */   FunctionRegion: function() { return /* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionRegion; },\n/* harmony export */   FunctionsError: function() { return /* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsError; },\n/* harmony export */   FunctionsFetchError: function() { return /* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsFetchError; },\n/* harmony export */   FunctionsHttpError: function() { return /* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsHttpError; },\n/* harmony export */   FunctionsRelayError: function() { return /* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsRelayError; },\n/* harmony export */   GoTrueAdminApi: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueAdminApi; },\n/* harmony export */   GoTrueClient: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueClient; },\n/* harmony export */   NavigatorLockAcquireTimeoutError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.NavigatorLockAcquireTimeoutError; },\n/* harmony export */   PostgrestError: function() { return /* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestError; },\n/* harmony export */   REALTIME_CHANNEL_STATES: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES; },\n/* harmony export */   REALTIME_LISTEN_TYPES: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES; },\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT; },\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_PRESENCE_LISTEN_EVENTS; },\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES; },\n/* harmony export */   RealtimeChannel: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeChannel; },\n/* harmony export */   RealtimeClient: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient; },\n/* harmony export */   RealtimePresence: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimePresence; },\n/* harmony export */   SIGN_OUT_SCOPES: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES; },\n/* harmony export */   SupabaseClient: function() { return /* binding */ SupabaseClient; },\n/* harmony export */   WebSocketFactory: function() { return /* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketFactory; },\n/* harmony export */   createClient: function() { return /* binding */ createClient; },\n/* harmony export */   isAuthApiError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError; },\n/* harmony export */   isAuthError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthError; },\n/* harmony export */   isAuthImplicitGrantRedirectError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError; },\n/* harmony export */   isAuthPKCECodeVerifierMissingError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthPKCECodeVerifierMissingError; },\n/* harmony export */   isAuthRetryableFetchError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError; },\n/* harmony export */   isAuthSessionMissingError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError; },\n/* harmony export */   isAuthWeakPasswordError: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthWeakPasswordError; },\n/* harmony export */   lockInternals: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.lockInternals; },\n/* harmony export */   navigatorLock: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.navigatorLock; },\n/* harmony export */   processLock: function() { return /* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.processLock; }\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/index.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/storage-js */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/auth-js */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\n\n\n\n\n\n\n//#region src/lib/version.ts\nconst version = \"2.95.3\";\n//#endregion\n//#region src/lib/constants.ts\nlet JS_ENV = \"\";\nif (typeof Deno !== \"undefined\") JS_ENV = \"deno\";\nelse if (typeof document !== \"undefined\") JS_ENV = \"web\";\nelse if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") JS_ENV = \"react-native\";\nelse JS_ENV = \"node\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": \"supabase-js-\".concat(JS_ENV, \"/\").concat(version)\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return customFetch(...args);\n    };\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return fetch(...args);\n    };\n};\nconst resolveHeadersConstructor = ()=>{\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch$1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _await$getAccessToken;\n        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) headers.set(\"apikey\", supabaseKey);\n        if (!headers.has(\"Authorization\")) headers.set(\"Authorization\", \"Bearer \".concat(accessToken));\n        return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {\n            headers\n        }));\n    };\n};\n//#endregion\n//#region src/lib/helpers.ts\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nfunction applySettingDefaults(options, defaults) {\n    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;\n    const result = {\n        db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),\n        auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),\n        realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),\n        storage: {},\n        global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {\n            headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) result.accessToken = options.accessToken;\n    else delete result.accessToken;\n    return result;\n}\n/**\n* Validates a Supabase client URL\n*\n* @param {string} supabaseUrl - The Supabase client URL string.\n* @returns {URL} - The validated base URL.\n* @throws {Error}\n*/ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) throw new Error(\"supabaseUrl is required.\");\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_unused) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n}\n//#endregion\n//#region src/lib/SupabaseAuthClient.ts\nvar SupabaseAuthClient = class extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n};\n//#endregion\n//#region src/SupabaseClient.ts\n/**\n* Supabase Client.\n*\n* An isomorphic Javascript client for interacting with Postgres.\n*/ var SupabaseClient = class {\n    /**\n\t* Supabase Functions allows you to deploy and invoke edge functions.\n\t*/ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_3__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        return this.rest.from(relation);\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ rpc(fn) {\n        let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n            head: false,\n            get: false,\n            count: void 0\n        };\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n\t* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n\t*\n\t* @param {string} name - The name of the Realtime channel.\n\t* @param {Object} opts - The options to pass to the Realtime channel.\n\t*\n\t*/ channel(name) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            config: {}\n        };\n        return this.realtime.channel(name, opts);\n    }\n    /**\n\t* Returns all Realtime channels.\n\t*/ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n\t* Unsubscribes and removes Realtime channel from Realtime client.\n\t*\n\t* @param {RealtimeChannel} channel - The name of the Realtime channel.\n\t*\n\t*/ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n\t* Unsubscribes and removes all Realtime channels from Realtime client.\n\t*/ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _this = this;\n        var _data$session$access_, _data$session;\n        if (_this.accessToken) return await _this.accessToken();\n        const { data } = await _this.auth.getSession();\n        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;\n    }\n    _initSupabaseAuthClient(param, headers, fetch$1) {\n        let { autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError } = param;\n        const authHeaders = {\n            Authorization: \"Bearer \".concat(this.supabaseKey),\n            apikey: \"\".concat(this.supabaseKey)\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),\n            storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            throwOnError,\n            fetch: fetch$1,\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {\n            params: _objectSpread2(_objectSpread2({}, {\n                apikey: this.supabaseKey\n            }), options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        return this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = void 0;\n        }\n    }\n    /**\n\t* Create a new client for use in the browser.\n\t* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n\t* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n\t* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n\t* @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n\t* @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n\t* @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n\t* @param options.realtime Options passed along to realtime-js constructor.\n\t* @param options.storage Options passed along to the storage-js constructor.\n\t* @param options.global.fetch A custom fetch implementation.\n\t* @param options.global.headers Any additional headers to send with each network request.\n\t* @example\n\t* ```ts\n\t* import { createClient } from '@supabase/supabase-js'\n\t*\n\t* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n\t* const { data } = await supabase.from('profiles').select('*')\n\t* ```\n\t*/ constructor(supabaseUrl, supabaseKey, options){\n        var _settings$auth$storag, _settings$global$head;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = validateSupabaseUrl(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        const defaultStorageKey = \"sb-\".concat(baseUrl.hostname.split(\".\")[0], \"-auth-token\");\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {\n                storageKey: defaultStorageKey\n            }),\n            global: DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : \"\";\n        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};\n        if (!settings.accessToken) {\n            var _settings$auth;\n            this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(\"@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.\".concat(String(prop), \" is not possible\"));\n                }\n            });\n        }\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(_objectSpread2({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        if (this.accessToken) Promise.resolve(this.accessToken()).then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn(\"Failed to set initial Realtime auth token:\", e));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch,\n            timeout: settings.db.timeout,\n            urlLengthLimit: settings.db.urlLengthLimit\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_4__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) this._listenForAuthEvents();\n    }\n};\n//#endregion\n//#region src/index.ts\n/**\n* Creates a new Supabase Client.\n*\n* @example\n* ```ts\n* import { createClient } from '@supabase/supabase-js'\n*\n* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n* const { data, error } = await supabase.from('profiles').select('*')\n* ```\n*/ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nfunction shouldShowDeprecationWarning() {\n    if (true) return false;\n    const _process = globalThis[\"process\"];\n    if (!_process) return false;\n    const processVersion = _process[\"version\"];\n    if (processVersion === void 0 || processVersion === null) return false;\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) return false;\n    return parseInt(versionMatch[1], 10) <= 18;\n}\nif (shouldShowDeprecationWarning()) console.warn(\"  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217\");\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1SjtBQUM5RTtBQUNsQjtBQUNGO0FBQ047QUFFVjtBQUVKO0FBRWpDLDRCQUE0QjtBQUM1QixNQUFNVyxVQUFVO0FBRWhCLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSUMsU0FBUztBQUNiLElBQUksT0FBT0MsU0FBUyxhQUFhRCxTQUFTO0tBQ3JDLElBQUksT0FBT0UsYUFBYSxhQUFhRixTQUFTO0tBQzlDLElBQUksT0FBT0csY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZUosU0FBUztLQUN0RkEsU0FBUztBQUNkLE1BQU1LLGtCQUFrQjtJQUFFLGlCQUFpQixlQUF5Qk4sT0FBVkMsUUFBTyxLQUFXLE9BQVJEO0FBQVU7QUFDOUUsTUFBTU8seUJBQXlCO0lBQUVDLFNBQVNGO0FBQWdCO0FBQzFELE1BQU1HLHFCQUFxQjtJQUFFQyxRQUFRO0FBQVM7QUFDOUMsTUFBTUMsdUJBQXVCO0lBQzVCQyxrQkFBa0I7SUFDbEJDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0lBQ3BCQyxVQUFVO0FBQ1g7QUFDQSxNQUFNQywyQkFBMkIsQ0FBQztBQUVsQyxZQUFZO0FBQ1osMERBQTBEO0FBQzFELFNBQVNDLFFBQVFDLENBQUM7SUFDakI7SUFDQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFTQyxHQUFHO1FBQ2hHLE9BQU8sT0FBT0E7SUFDZixJQUFJLFNBQVNBLEdBQUc7UUFDZixPQUFPQSxPQUFPLGNBQWMsT0FBT0YsVUFBVUUsSUFBSUMsV0FBVyxLQUFLSCxVQUFVRSxRQUFRRixPQUFPSSxTQUFTLEdBQUcsV0FBVyxPQUFPRjtJQUN6SCxHQUFHSixR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QUMxQixPQUFPQyxTQUFTRCxZQUFZLENBQUMsRUFBRSxFQUFFLE9BQU87QUFDekM7QUFDQSxJQUFJSixnQ0FBZ0NMLFFBQVFDLElBQUksQ0FBQztBQUVqRCxZQUFZO0FBQzBJLENBQ3RKLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXgubWpzPzQ5M2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnVuY3Rpb25SZWdpb24sIEZ1bmN0aW9uc0NsaWVudCwgRnVuY3Rpb25zRXJyb3IsIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciB9IGZyb20gXCJAc3VwYWJhc2UvZnVuY3Rpb25zLWpzXCI7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RDbGllbnQsIFBvc3RncmVzdEVycm9yIH0gZnJvbSBcIkBzdXBhYmFzZS9wb3N0Z3Jlc3QtanNcIjtcbmltcG9ydCB7IFJlYWx0aW1lQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9yZWFsdGltZS1qc1wiO1xuaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3RvcmFnZS1qc1wiO1xuaW1wb3J0IHsgQXV0aENsaWVudCB9IGZyb20gXCJAc3VwYWJhc2UvYXV0aC1qc1wiO1xuXG5leHBvcnQgKiBmcm9tIFwiQHN1cGFiYXNlL3JlYWx0aW1lLWpzXCJcblxuZXhwb3J0ICogZnJvbSBcIkBzdXBhYmFzZS9hdXRoLWpzXCJcblxuLy8jcmVnaW9uIHNyYy9saWIvdmVyc2lvbi50c1xuY29uc3QgdmVyc2lvbiA9IFwiMi45NS4zXCI7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29uc3RhbnRzLnRzXG5sZXQgSlNfRU5WID0gXCJcIjtcbmlmICh0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIikgSlNfRU5WID0gXCJkZW5vXCI7XG5lbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIEpTX0VOViA9IFwid2ViXCI7XG5lbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIpIEpTX0VOViA9IFwicmVhY3QtbmF0aXZlXCI7XG5lbHNlIEpTX0VOViA9IFwibm9kZVwiO1xuY29uc3QgREVGQVVMVF9IRUFERVJTID0geyBcIlgtQ2xpZW50LUluZm9cIjogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9O1xuY29uc3QgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHsgaGVhZGVyczogREVGQVVMVF9IRUFERVJTIH07XG5jb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7IHNjaGVtYTogXCJwdWJsaWNcIiB9O1xuY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlMgPSB7XG5cdGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG5cdHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuXHRkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG5cdGZsb3dUeXBlOiBcImltcGxpY2l0XCJcbn07XG5jb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMgPSB7fTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3R5cGVvZi5qc1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG5cdFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblx0cmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gdHlwZW9mIG8kMTtcblx0fSA6IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiBvJDEgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgbyQxLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyQxICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvJDE7XG5cdH0sIF90eXBlb2Yobyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1ByaW1pdGl2ZS5qc1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuXHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcblx0dmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cdGlmICh2b2lkIDAgIT09IGUpIHtcblx0XHR2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcblx0XHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG5cdH1cblx0cmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanNcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuXHR2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuXHRyZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG5cdHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuXHRcdHZhbHVlOiB0LFxuXHRcdGVudW1lcmFibGU6ICEwLFxuXHRcdGNvbmZpZ3VyYWJsZTogITAsXG5cdFx0d3JpdGFibGU6ICEwXG5cdH0pIDogZVtyXSA9IHQsIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcblx0dmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHR2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG5cdFx0ciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgciQxKS5lbnVtZXJhYmxlO1xuXHRcdH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuXHR9XG5cdHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuXHRmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuXHRcdHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcblx0XHRyICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdF9kZWZpbmVQcm9wZXJ0eShlLCByJDEsIHRbciQxXSk7XG5cdFx0fSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIkMSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByJDEpKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9mZXRjaC50c1xuY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG5cdGlmIChjdXN0b21GZXRjaCkgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcblx0cmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG5jb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuXHRyZXR1cm4gSGVhZGVycztcbn07XG5jb25zdCBmZXRjaFdpdGhBdXRoID0gKHN1cGFiYXNlS2V5LCBnZXRBY2Nlc3NUb2tlbiwgY3VzdG9tRmV0Y2gpID0+IHtcblx0Y29uc3QgZmV0Y2gkMSA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCk7XG5cdGNvbnN0IEhlYWRlcnNDb25zdHJ1Y3RvciA9IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IoKTtcblx0cmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuXHRcdHZhciBfYXdhaXQkZ2V0QWNjZXNzVG9rZW47XG5cdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSAoX2F3YWl0JGdldEFjY2Vzc1Rva2VuID0gYXdhaXQgZ2V0QWNjZXNzVG9rZW4oKSkgIT09IG51bGwgJiYgX2F3YWl0JGdldEFjY2Vzc1Rva2VuICE9PSB2b2lkIDAgPyBfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gOiBzdXBhYmFzZUtleTtcblx0XHRsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpO1xuXHRcdGlmICghaGVhZGVycy5oYXMoXCJhcGlrZXlcIikpIGhlYWRlcnMuc2V0KFwiYXBpa2V5XCIsIHN1cGFiYXNlS2V5KTtcblx0XHRpZiAoIWhlYWRlcnMuaGFzKFwiQXV0aG9yaXphdGlvblwiKSkgaGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcblx0XHRyZXR1cm4gZmV0Y2gkMShpbnB1dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGluaXQpLCB7fSwgeyBoZWFkZXJzIH0pKTtcblx0fTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuZnVuY3Rpb24gZW5zdXJlVHJhaWxpbmdTbGFzaCh1cmwpIHtcblx0cmV0dXJuIHVybC5lbmRzV2l0aChcIi9cIikgPyB1cmwgOiB1cmwgKyBcIi9cIjtcbn1cbmZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdHZhciBfREVGQVVMVF9HTE9CQUxfT1BUSU8sIF9nbG9iYWxPcHRpb25zJGhlYWRlcjtcblx0Y29uc3QgeyBkYjogZGJPcHRpb25zLCBhdXRoOiBhdXRoT3B0aW9ucywgcmVhbHRpbWU6IHJlYWx0aW1lT3B0aW9ucywgZ2xvYmFsOiBnbG9iYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuXHRjb25zdCB7IGRiOiBERUZBVUxUX0RCX09QVElPTlMkMSwgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMkMSwgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxLCBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSB9ID0gZGVmYXVsdHM7XG5cdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRkYjogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfREJfT1BUSU9OUyQxKSwgZGJPcHRpb25zKSxcblx0XHRhdXRoOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMkMSksIGF1dGhPcHRpb25zKSxcblx0XHRyZWFsdGltZTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxKSwgcmVhbHRpbWVPcHRpb25zKSxcblx0XHRzdG9yYWdlOiB7fSxcblx0XHRnbG9iYWw6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEpLCBnbG9iYWxPcHRpb25zKSwge30sIHsgaGVhZGVyczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIChfREVGQVVMVF9HTE9CQUxfT1BUSU8gPSBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEgPT09IG51bGwgfHwgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEuaGVhZGVycykgIT09IG51bGwgJiYgX0RFRkFVTFRfR0xPQkFMX09QVElPICE9PSB2b2lkIDAgPyBfREVGQVVMVF9HTE9CQUxfT1BUSU8gOiB7fSksIChfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgPSBnbG9iYWxPcHRpb25zID09PSBudWxsIHx8IGdsb2JhbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbE9wdGlvbnMuaGVhZGVycykgIT09IG51bGwgJiYgX2dsb2JhbE9wdGlvbnMkaGVhZGVyICE9PSB2b2lkIDAgPyBfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgOiB7fSkgfSksXG5cdFx0YWNjZXNzVG9rZW46IGFzeW5jICgpID0+IFwiXCJcblx0fTtcblx0aWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHJlc3VsdC5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW47XG5cdGVsc2UgZGVsZXRlIHJlc3VsdC5hY2Nlc3NUb2tlbjtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuKiBWYWxpZGF0ZXMgYSBTdXBhYmFzZSBjbGllbnQgVVJMXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBzdXBhYmFzZVVybCAtIFRoZSBTdXBhYmFzZSBjbGllbnQgVVJMIHN0cmluZy5cbiogQHJldHVybnMge1VSTH0gLSBUaGUgdmFsaWRhdGVkIGJhc2UgVVJMLlxuKiBAdGhyb3dzIHtFcnJvcn1cbiovXG5mdW5jdGlvbiB2YWxpZGF0ZVN1cGFiYXNlVXJsKHN1cGFiYXNlVXJsKSB7XG5cdGNvbnN0IHRyaW1tZWRVcmwgPSBzdXBhYmFzZVVybCA9PT0gbnVsbCB8fCBzdXBhYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VwYWJhc2VVcmwudHJpbSgpO1xuXHRpZiAoIXRyaW1tZWRVcmwpIHRocm93IG5ldyBFcnJvcihcInN1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLlwiKTtcblx0aWYgKCF0cmltbWVkVXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy9pKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdXBhYmFzZVVybDogTXVzdCBiZSBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLlwiKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFVSTChlbnN1cmVUcmFpbGluZ1NsYXNoKHRyaW1tZWRVcmwpKTtcblx0fSBjYXRjaCAoX3VudXNlZCkge1xuXHRcdHRocm93IEVycm9yKFwiSW52YWxpZCBzdXBhYmFzZVVybDogUHJvdmlkZWQgVVJMIGlzIG1hbGZvcm1lZC5cIik7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQudHNcbnZhciBTdXBhYmFzZUF1dGhDbGllbnQgPSBjbGFzcyBleHRlbmRzIEF1dGhDbGllbnQge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9TdXBhYmFzZUNsaWVudC50c1xuLyoqXG4qIFN1cGFiYXNlIENsaWVudC5cbipcbiogQW4gaXNvbW9ycGhpYyBKYXZhc2NyaXB0IGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBQb3N0Z3Jlcy5cbiovXG52YXIgU3VwYWJhc2VDbGllbnQgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cblx0KiBAcGFyYW0gc3VwYWJhc2VVcmwgVGhlIHVuaXF1ZSBTdXBhYmFzZSBVUkwgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gc3VwYWJhc2VLZXkgVGhlIHVuaXF1ZSBTdXBhYmFzZSBLZXkgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5hdXRvUmVmcmVzaFRva2VuIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLnBlcnNpc3RTZXNzaW9uIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG5cdCogQHBhcmFtIG9wdGlvbnMucmVhbHRpbWUgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gcmVhbHRpbWUtanMgY29uc3RydWN0b3IuXG5cdCogQHBhcmFtIG9wdGlvbnMuc3RvcmFnZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byB0aGUgc3RvcmFnZS1qcyBjb25zdHJ1Y3Rvci5cblx0KiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblx0KlxuXHQqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5Jylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG5cdFx0dmFyIF9zZXR0aW5ncyRhdXRoJHN0b3JhZywgX3NldHRpbmdzJGdsb2JhbCRoZWFkO1xuXHRcdHRoaXMuc3VwYWJhc2VVcmwgPSBzdXBhYmFzZVVybDtcblx0XHR0aGlzLnN1cGFiYXNlS2V5ID0gc3VwYWJhc2VLZXk7XG5cdFx0Y29uc3QgYmFzZVVybCA9IHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpO1xuXHRcdGlmICghc3VwYWJhc2VLZXkpIHRocm93IG5ldyBFcnJvcihcInN1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLlwiKTtcblx0XHR0aGlzLnJlYWx0aW1lVXJsID0gbmV3IFVSTChcInJlYWx0aW1lL3YxXCIsIGJhc2VVcmwpO1xuXHRcdHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wgPSB0aGlzLnJlYWx0aW1lVXJsLnByb3RvY29sLnJlcGxhY2UoXCJodHRwXCIsIFwid3NcIik7XG5cdFx0dGhpcy5hdXRoVXJsID0gbmV3IFVSTChcImF1dGgvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5zdG9yYWdlVXJsID0gbmV3IFVSTChcInN0b3JhZ2UvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5mdW5jdGlvbnNVcmwgPSBuZXcgVVJMKFwiZnVuY3Rpb25zL3YxXCIsIGJhc2VVcmwpO1xuXHRcdGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7YmFzZVVybC5ob3N0bmFtZS5zcGxpdChcIi5cIilbMF19LWF1dGgtdG9rZW5gO1xuXHRcdGNvbnN0IERFRkFVTFRTID0ge1xuXHRcdFx0ZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcblx0XHRcdHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG5cdFx0XHRhdXRoOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMpLCB7fSwgeyBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9KSxcblx0XHRcdGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OU1xuXHRcdH07XG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgREVGQVVMVFMpO1xuXHRcdHRoaXMuc3RvcmFnZUtleSA9IChfc2V0dGluZ3MkYXV0aCRzdG9yYWcgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRhdXRoJHN0b3JhZyAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGgkc3RvcmFnIDogXCJcIjtcblx0XHR0aGlzLmhlYWRlcnMgPSAoX3NldHRpbmdzJGdsb2JhbCRoZWFkID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMpICE9PSBudWxsICYmIF9zZXR0aW5ncyRnbG9iYWwkaGVhZCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGdsb2JhbCRoZWFkIDoge307XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuXHRcdFx0dmFyIF9zZXR0aW5ncyRhdXRoO1xuXHRcdFx0dGhpcy5hdXRoID0gdGhpcy5faW5pdFN1cGFiYXNlQXV0aENsaWVudCgoX3NldHRpbmdzJGF1dGggPSBzZXR0aW5ncy5hdXRoKSAhPT0gbnVsbCAmJiBfc2V0dGluZ3MkYXV0aCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGggOiB7fSwgdGhpcy5oZWFkZXJzLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjY2Vzc1Rva2VuID0gc2V0dGluZ3MuYWNjZXNzVG9rZW47XG5cdFx0XHR0aGlzLmF1dGggPSBuZXcgUHJveHkoe30sIHsgZ2V0OiAoXywgcHJvcCkgPT4ge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9zdXBhYmFzZS1qczogU3VwYWJhc2UgQ2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYWNjZXNzVG9rZW4gb3B0aW9uLCBhY2Nlc3Npbmcgc3VwYWJhc2UuYXV0aC4ke1N0cmluZyhwcm9wKX0gaXMgbm90IHBvc3NpYmxlYCk7XG5cdFx0XHR9IH0pO1xuXHRcdH1cblx0XHR0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KF9vYmplY3RTcHJlYWQyKHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGFjY2Vzc1Rva2VuOiB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpXG5cdFx0fSwgc2V0dGluZ3MucmVhbHRpbWUpKTtcblx0XHRpZiAodGhpcy5hY2Nlc3NUb2tlbikgUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjZXNzVG9rZW4oKSkudGhlbigodG9rZW4pID0+IHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbikpLmNhdGNoKChlKSA9PiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2V0IGluaXRpYWwgUmVhbHRpbWUgYXV0aCB0b2tlbjpcIiwgZSkpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQobmV3IFVSTChcInJlc3QvdjFcIiwgYmFzZVVybCkuaHJlZiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdHRpbWVvdXQ6IHNldHRpbmdzLmRiLnRpbWVvdXQsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogc2V0dGluZ3MuZGIudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0XHR0aGlzLnN0b3JhZ2UgPSBuZXcgU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwuaHJlZiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmFnZSk7XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuXHR9XG5cdC8qKlxuXHQqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuXHQqL1xuXHRnZXQgZnVuY3Rpb25zKCkge1xuXHRcdHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLmhyZWYsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGN1c3RvbUZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuXHQqL1xuXHRmcm9tKHJlbGF0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKTtcblx0fVxuXHQvKipcblx0KiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuXHQqXG5cdCogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuXHQqXG5cdCogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcblx0Ki9cblx0c2NoZW1hKHNjaGVtYSkge1xuXHRcdHJldHVybiB0aGlzLnJlc3Quc2NoZW1hKHNjaGVtYSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG5cdCpcblx0KiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG5cdCogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG5cdCogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuXHQqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcblx0KiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG5cdCogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcblx0KiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIG9wdGlvbnMgPSB7XG5cdFx0aGVhZDogZmFsc2UsXG5cdFx0Z2V0OiBmYWxzZSxcblx0XHRjb3VudDogdm9pZCAwXG5cdH0pIHtcblx0XHRyZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cblx0KlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuXHQqXG5cdCovXG5cdGNoYW5uZWwobmFtZSwgb3B0cyA9IHsgY29uZmlnOiB7fSB9KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcblx0fVxuXHQvKipcblx0KiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cblx0Ki9cblx0Z2V0Q2hhbm5lbHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cblx0KlxuXHQqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCpcblx0Ki9cblx0cmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuXHQqL1xuXHRyZW1vdmVBbGxDaGFubmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpO1xuXHR9XG5cdGFzeW5jIF9nZXRBY2Nlc3NUb2tlbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBfZGF0YSRzZXNzaW9uJGFjY2Vzc18sIF9kYXRhJHNlc3Npb247XG5cdFx0aWYgKF90aGlzLmFjY2Vzc1Rva2VuKSByZXR1cm4gYXdhaXQgX3RoaXMuYWNjZXNzVG9rZW4oKTtcblx0XHRjb25zdCB7IGRhdGEgfSA9IGF3YWl0IF90aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuXHRcdHJldHVybiAoX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfID0gKF9kYXRhJHNlc3Npb24gPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9kYXRhJHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhJHNlc3Npb24uYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZGF0YSRzZXNzaW9uJGFjY2Vzc18gIT09IHZvaWQgMCA/IF9kYXRhJHNlc3Npb24kYWNjZXNzXyA6IF90aGlzLnN1cGFiYXNlS2V5O1xuXHR9XG5cdF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KHsgYXV0b1JlZnJlc2hUb2tlbiwgcGVyc2lzdFNlc3Npb24sIGRldGVjdFNlc3Npb25JblVybCwgc3RvcmFnZSwgdXNlclN0b3JhZ2UsIHN0b3JhZ2VLZXksIGZsb3dUeXBlLCBsb2NrLCBkZWJ1ZywgdGhyb3dPbkVycm9yIH0sIGhlYWRlcnMsIGZldGNoJDEpIHtcblx0XHRjb25zdCBhdXRoSGVhZGVycyA9IHtcblx0XHRcdEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG5cdFx0XHRhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YFxuXHRcdH07XG5cdFx0cmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuXHRcdFx0dXJsOiB0aGlzLmF1dGhVcmwuaHJlZixcblx0XHRcdGhlYWRlcnM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhdXRoSGVhZGVycyksIGhlYWRlcnMpLFxuXHRcdFx0c3RvcmFnZUtleSxcblx0XHRcdGF1dG9SZWZyZXNoVG9rZW4sXG5cdFx0XHRwZXJzaXN0U2Vzc2lvbixcblx0XHRcdGRldGVjdFNlc3Npb25JblVybCxcblx0XHRcdHN0b3JhZ2UsXG5cdFx0XHR1c2VyU3RvcmFnZSxcblx0XHRcdGZsb3dUeXBlLFxuXHRcdFx0bG9jayxcblx0XHRcdGRlYnVnLFxuXHRcdFx0dGhyb3dPbkVycm9yLFxuXHRcdFx0ZmV0Y2g6IGZldGNoJDEsXG5cdFx0XHRoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLnNvbWUoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0aG9yaXphdGlvblwiKVxuXHRcdH0pO1xuXHR9XG5cdF9pbml0UmVhbHRpbWVDbGllbnQob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybC5ocmVmLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHBhcmFtczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHsgYXBpa2V5OiB0aGlzLnN1cGFiYXNlS2V5IH0pLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB9KSk7XG5cdH1cblx0X2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgoZXZlbnQsIHNlc3Npb24pID0+IHtcblx0XHRcdHRoaXMuX2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgXCJDTElFTlRcIiwgc2Vzc2lvbiA9PT0gbnVsbCB8fCBzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uLmFjY2Vzc190b2tlbik7XG5cdFx0fSk7XG5cdH1cblx0X2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgc291cmNlLCB0b2tlbikge1xuXHRcdGlmICgoZXZlbnQgPT09IFwiVE9LRU5fUkVGUkVTSEVEXCIgfHwgZXZlbnQgPT09IFwiU0lHTkVEX0lOXCIpICYmIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuXHRcdFx0dGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlbjtcblx0XHRcdHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbik7XG5cdFx0fSBlbHNlIGlmIChldmVudCA9PT0gXCJTSUdORURfT1VUXCIpIHtcblx0XHRcdHRoaXMucmVhbHRpbWUuc2V0QXV0aCgpO1xuXHRcdFx0aWYgKHNvdXJjZSA9PSBcIlNUT1JBR0VcIikgdGhpcy5hdXRoLnNpZ25PdXQoKTtcblx0XHRcdHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdm9pZCAwO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG4vKipcbiogQ3JlYXRlcyBhIG5ldyBTdXBhYmFzZSBDbGllbnQuXG4qXG4qIEBleGFtcGxlXG4qIGBgYHRzXG4qIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbipcbiogY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jbycsICdwdWJsaWMtYW5vbi1rZXknKVxuKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnNlbGVjdCgnKicpXG4qIGBgYFxuKi9cbmNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcblx0cmV0dXJuIG5ldyBTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpO1xufTtcbmZ1bmN0aW9uIHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IF9wcm9jZXNzID0gZ2xvYmFsVGhpc1tcInByb2Nlc3NcIl07XG5cdGlmICghX3Byb2Nlc3MpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgcHJvY2Vzc1ZlcnNpb24gPSBfcHJvY2Vzc1tcInZlcnNpb25cIl07XG5cdGlmIChwcm9jZXNzVmVyc2lvbiA9PT0gdm9pZCAwIHx8IHByb2Nlc3NWZXJzaW9uID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHZlcnNpb25NYXRjaCA9IHByb2Nlc3NWZXJzaW9uLm1hdGNoKC9edihcXGQrKVxcLi8pO1xuXHRpZiAoIXZlcnNpb25NYXRjaCkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gcGFyc2VJbnQodmVyc2lvbk1hdGNoWzFdLCAxMCkgPD0gMTg7XG59XG5pZiAoc2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZygpKSBjb25zb2xlLndhcm4oXCLimqDvuI8gIE5vZGUuanMgMTggYW5kIGJlbG93IGFyZSBkZXByZWNhdGVkIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEBzdXBhYmFzZS9zdXBhYmFzZS1qcy4gUGxlYXNlIHVwZ3JhZGUgdG8gTm9kZS5qcyAyMCBvciBsYXRlci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiBodHRwczovL2dpdGh1Yi5jb20vb3Jncy9zdXBhYmFzZS9kaXNjdXNzaW9ucy8zNzIxN1wiKTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBGdW5jdGlvblJlZ2lvbiwgRnVuY3Rpb25zRXJyb3IsIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciwgUG9zdGdyZXN0RXJyb3IsIFN1cGFiYXNlQ2xpZW50LCBjcmVhdGVDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiRnVuY3Rpb25SZWdpb24iLCJGdW5jdGlvbnNDbGllbnQiLCJGdW5jdGlvbnNFcnJvciIsIkZ1bmN0aW9uc0ZldGNoRXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNSZWxheUVycm9yIiwiUG9zdGdyZXN0Q2xpZW50IiwiUG9zdGdyZXN0RXJyb3IiLCJSZWFsdGltZUNsaWVudCIsIlN0b3JhZ2VDbGllbnQiLCJBdXRoQ2xpZW50IiwidmVyc2lvbiIsIkpTX0VOViIsIkRlbm8iLCJkb2N1bWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJERUZBVUxUX0hFQURFUlMiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TIiwiaGVhZGVycyIsIkRFRkFVTFRfREJfT1BUSU9OUyIsInNjaGVtYSIsIkRFRkFVTFRfQVVUSF9PUFRJT05TIiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwiZmxvd1R5cGUiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibyQxIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJhcmdzIiwiZmV0Y2giLCJyZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yIiwiSGVhZGVycyIsImZldGNoV2l0aEF1dGgiLCJzdXBhYmFzZUtleSIsImdldEFjY2Vzc1Rva2VuIiwiZmV0Y2gkMSIsIkhlYWRlcnNDb25zdHJ1Y3RvciIsImlucHV0IiwiaW5pdCIsIl9hd2FpdCRnZXRBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwiaGFzIiwic2V0IiwiZW5zdXJlVHJhaWxpbmdTbGFzaCIsInVybCIsImVuZHNXaXRoIiwiYXBwbHlTZXR0aW5nRGVmYXVsdHMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJfREVGQVVMVF9HTE9CQUxfT1BUSU8iLCJfZ2xvYmFsT3B0aW9ucyRoZWFkZXIiLCJkYiIsImRiT3B0aW9ucyIsImF1dGgiLCJhdXRoT3B0aW9ucyIsInJlYWx0aW1lIiwicmVhbHRpbWVPcHRpb25zIiwiZ2xvYmFsIiwiZ2xvYmFsT3B0aW9ucyIsIkRFRkFVTFRfREJfT1BUSU9OUyQxIiwiREVGQVVMVF9BVVRIX09QVElPTlMkMSIsIkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxIiwicmVzdWx0Iiwic3RvcmFnZSIsInZhbGlkYXRlU3VwYWJhc2VVcmwiLCJzdXBhYmFzZVVybCIsInRyaW1tZWRVcmwiLCJ0cmltIiwiRXJyb3IiLCJtYXRjaCIsIlVSTCIsIl91bnVzZWQiLCJTdXBhYmFzZUF1dGhDbGllbnQiLCJTdXBhYmFzZUNsaWVudCIsImZ1bmN0aW9ucyIsImZ1bmN0aW9uc1VybCIsImhyZWYiLCJmcm9tIiwicmVsYXRpb24iLCJyZXN0IiwicnBjIiwiZm4iLCJoZWFkIiwiZ2V0IiwiY291bnQiLCJjaGFubmVsIiwibmFtZSIsIm9wdHMiLCJjb25maWciLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJyZW1vdmVBbGxDaGFubmVscyIsIl9nZXRBY2Nlc3NUb2tlbiIsIl90aGlzIiwiX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfIiwiX2RhdGEkc2Vzc2lvbiIsImRhdGEiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsIl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50IiwidXNlclN0b3JhZ2UiLCJzdG9yYWdlS2V5IiwibG9jayIsImRlYnVnIiwidGhyb3dPbkVycm9yIiwiYXV0aEhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYXBpa2V5IiwiYXV0aFVybCIsImhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIiLCJzb21lIiwia2V5IiwidG9Mb3dlckNhc2UiLCJfaW5pdFJlYWx0aW1lQ2xpZW50IiwicmVhbHRpbWVVcmwiLCJwYXJhbXMiLCJfbGlzdGVuRm9yQXV0aEV2ZW50cyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJfaGFuZGxlVG9rZW5DaGFuZ2VkIiwic291cmNlIiwidG9rZW4iLCJjaGFuZ2VkQWNjZXNzVG9rZW4iLCJzZXRBdXRoIiwic2lnbk91dCIsIl9zZXR0aW5ncyRhdXRoJHN0b3JhZyIsIl9zZXR0aW5ncyRnbG9iYWwkaGVhZCIsImJhc2VVcmwiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJzdG9yYWdlVXJsIiwiZGVmYXVsdFN0b3JhZ2VLZXkiLCJob3N0bmFtZSIsInNwbGl0IiwiREVGQVVMVFMiLCJzZXR0aW5ncyIsIl9zZXR0aW5ncyRhdXRoIiwiUHJveHkiLCJfIiwicHJvcCIsImJpbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsImNvbnNvbGUiLCJ3YXJuIiwidGltZW91dCIsInVybExlbmd0aExpbWl0IiwiY3JlYXRlQ2xpZW50Iiwic2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZyIsIl9wcm9jZXNzIiwiZ2xvYmFsVGhpcyIsInByb2Nlc3NWZXJzaW9uIiwidmVyc2lvbk1hdGNoIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: function() { return /* binding */ IcebergError; },\n/* harmony export */   IcebergRestCatalog: function() { return /* binding */ IcebergRestCatalog; },\n/* harmony export */   getCurrentSchema: function() { return /* binding */ getCurrentSchema; },\n/* harmony export */   isDecimalType: function() { return /* binding */ isDecimalType; },\n/* harmony export */   isFixedType: function() { return /* binding */ isFixedType; },\n/* harmony export */   parseDecimalType: function() { return /* binding */ parseDecimalType; },\n/* harmony export */   parseFixedType: function() { return /* binding */ parseFixedType; },\n/* harmony export */   typesEqual: function() { return /* binding */ typesEqual; }\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n    constructor(message, opts){\n        var _opts_icebergType;\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && ((_opts_icebergType = opts.icebergType) === null || _opts_icebergType === void 0 ? void 0 : _opts_icebergType.includes(\"CommitState\")) === true;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: \"Bearer \".concat(auth.token)\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    var _options_fetchImpl;\n    const fetchFn = (_options_fetchImpl = options.fetchImpl) !== null && _options_fetchImpl !== void 0 ? _options_fetchImpl : globalThis.fetch;\n    return {\n        async request (param) {\n            let { method, path, query, body, headers } = param;\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody === null || errBody === void 0 ? void 0 : errBody.error;\n                var _errorDetail_message;\n                throw new IcebergError((_errorDetail_message = errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.message) !== null && _errorDetail_message !== void 0 ? _errorDetail_message : \"Request failed with status \".concat(res.status), {\n                    status: res.status,\n                    icebergType: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.type,\n                    icebergCode: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: \"\".concat(this.prefix, \"/namespaces\"),\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata === null || metadata === void 0 ? void 0 : metadata.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: \"\".concat(this.prefix, \"/namespaces\"),\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(namespace.namespace), \"/tables\")\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(namespace.namespace), \"/tables\"),\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        var _options_purge;\n        await this.client.request({\n            method: \"DELETE\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n            query: {\n                purgeRequested: String((_options_purge = options === null || options === void 0 ? void 0 : options.purge) !== null && _options_purge !== void 0 ? _options_purge : false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        var _options_accessDelegation;\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += \"/\".concat(options.catalogName);\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : \"\".concat(options.baseUrl, \"/\");\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = (_options_accessDelegation = options.accessDelegation) === null || _options_accessDelegation === void 0 ? void 0 : _options_accessDelegation.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLElBQUlBLGVBQWUsY0FBY0M7SUFVL0I7O0dBRUMsR0FDREMsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDQyxNQUFNLEtBQUs7SUFDekI7SUFDQTs7R0FFQyxHQUNEQyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNELE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RFLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQ0YsTUFBTSxLQUFLO0lBQ3pCO0lBMUJBRyxZQUFZQyxPQUFPLEVBQUVDLElBQUksQ0FBRTtZQU9rR0E7UUFOM0gsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTixNQUFNLEdBQUdLLEtBQUtMLE1BQU07UUFDekIsSUFBSSxDQUFDTyxXQUFXLEdBQUdGLEtBQUtFLFdBQVc7UUFDbkMsSUFBSSxDQUFDQyxXQUFXLEdBQUdILEtBQUtHLFdBQVc7UUFDbkMsSUFBSSxDQUFDQyxPQUFPLEdBQUdKLEtBQUtJLE9BQU87UUFDM0IsSUFBSSxDQUFDQyxvQkFBb0IsR0FBR0wsS0FBS0UsV0FBVyxLQUFLLGlDQUFpQztZQUFDO1lBQUs7WUFBSztTQUFJLENBQUNJLFFBQVEsQ0FBQ04sS0FBS0wsTUFBTSxLQUFLSyxFQUFBQSxvQkFBQUEsS0FBS0UsV0FBVyxjQUFoQkYsd0NBQUFBLGtCQUFrQk0sUUFBUSxDQUFDLG9CQUFtQjtJQUMzSztBQW1CRjtBQUVBLG1CQUFtQjtBQUNuQixTQUFTQyxTQUFTQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUNwQyxNQUFNQyxNQUFNLElBQUlDLElBQUlILE1BQU1EO0lBQzFCLElBQUlFLE9BQU87UUFDVCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFP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QSxDQUFDLENBQUMsWUFBWSxLQUFLL0MsUUFBUSxDQUFDLG9CQUFvQjtBQUN0RjtBQUV3SSxDQUN4SSxrQ0FBa0M7Q0FDbEMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL2Rpc3QvaW5kZXgubWpzP2ZjYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9JY2ViZXJnRXJyb3IudHNcbnZhciBJY2ViZXJnRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0cykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSWNlYmVyZ0Vycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRzLnN0YXR1cztcbiAgICB0aGlzLmljZWJlcmdUeXBlID0gb3B0cy5pY2ViZXJnVHlwZTtcbiAgICB0aGlzLmljZWJlcmdDb2RlID0gb3B0cy5pY2ViZXJnQ29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRzLmRldGFpbHM7XG4gICAgdGhpcy5pc0NvbW1pdFN0YXRlVW5rbm93biA9IG9wdHMuaWNlYmVyZ1R5cGUgPT09IFwiQ29tbWl0U3RhdGVVbmtub3duRXhjZXB0aW9uXCIgfHwgWzUwMCwgNTAyLCA1MDRdLmluY2x1ZGVzKG9wdHMuc3RhdHVzKSAmJiBvcHRzLmljZWJlcmdUeXBlPy5pbmNsdWRlcyhcIkNvbW1pdFN0YXRlXCIpID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA0IE5vdCBGb3VuZCBlcnJvci5cbiAgICovXG4gIGlzTm90Rm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MDQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDkgQ29uZmxpY3QgZXJyb3IuXG4gICAqL1xuICBpc0NvbmZsaWN0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDE5IEF1dGhlbnRpY2F0aW9uIFRpbWVvdXQgZXJyb3IuXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0aW9uVGltZW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQxOTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3VybC50c1xuZnVuY3Rpb24gYnVpbGRVcmwoYmFzZVVybCwgcGF0aCwgcXVlcnkpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvaHR0cC9jcmVhdGVGZXRjaENsaWVudC50c1xuYXN5bmMgZnVuY3Rpb24gYnVpbGRBdXRoSGVhZGVycyhhdXRoKSB7XG4gIGlmICghYXV0aCB8fCBhdXRoLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiYmVhcmVyXCIpIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJoZWFkZXJcIikge1xuICAgIHJldHVybiB7IFthdXRoLm5hbWVdOiBhdXRoLnZhbHVlIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgIHJldHVybiBhd2FpdCBhdXRoLmdldEhlYWRlcnMoKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGZldGNoRm4gPSBvcHRpb25zLmZldGNoSW1wbCA/PyBnbG9iYWxUaGlzLmZldGNoO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIHJlcXVlc3Qoe1xuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnNcbiAgICB9KSB7XG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChvcHRpb25zLmJhc2VVcmwsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgYnVpbGRBdXRoSGVhZGVycyhvcHRpb25zLmF1dGgpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2hGbih1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uYm9keSA/IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSA6IHt9LFxuICAgICAgICAgIC4uLmF1dGhIZWFkZXJzLFxuICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgY29uc3QgaXNKc29uID0gKHJlcy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiKS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBkYXRhID0gaXNKc29uICYmIHRleHQgPyBKU09OLnBhcnNlKHRleHQpIDogdGV4dDtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGVyckJvZHkgPSBpc0pzb24gPyBkYXRhIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbCA9IGVyckJvZHk/LmVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgSWNlYmVyZ0Vycm9yKFxuICAgICAgICAgIGVycm9yRGV0YWlsPy5tZXNzYWdlID8/IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBpY2ViZXJnVHlwZTogZXJyb3JEZXRhaWw/LnR5cGUsXG4gICAgICAgICAgICBpY2ViZXJnQ29kZTogZXJyb3JEZXRhaWw/LmNvZGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJCb2R5XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBoZWFkZXJzOiByZXMuaGVhZGVycywgZGF0YSB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2NhdGFsb2cvbmFtZXNwYWNlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoKG5hbWVzcGFjZSkge1xuICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oXCJcdTAwMWZcIik7XG59XG52YXIgTmFtZXNwYWNlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cbiAgYXN5bmMgbGlzdE5hbWVzcGFjZXMocGFyZW50KSB7XG4gICAgY29uc3QgcXVlcnkgPSBwYXJlbnQgPyB7IHBhcmVudDogbmFtZXNwYWNlVG9QYXRoKHBhcmVudC5uYW1lc3BhY2UpIH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIHF1ZXJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubmFtZXNwYWNlcy5tYXAoKG5zKSA9PiAoeyBuYW1lc3BhY2U6IG5zIH0pKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIG5hbWVzcGFjZTogaWQubmFtZXNwYWNlLFxuICAgICAgcHJvcGVydGllczogbWV0YWRhdGE/LnByb3BlcnRpZXNcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXNgLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIGRyb3BOYW1lc3BhY2UoaWQpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydGllczogcmVzcG9uc2UuZGF0YS5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBuYW1lc3BhY2VFeGlzdHMoaWQpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3RhYmxlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoMihuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIFRhYmxlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiLCBhY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uID0gYWNjZXNzRGVsZWdhdGlvbjtcbiAgfVxuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2BcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZGVudGlmaWVycztcbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuYWNjZXNzRGVsZWdhdGlvbikge1xuICAgICAgaGVhZGVyc1tcIlgtSWNlYmVyZy1BY2Nlc3MtRGVsZWdhdGlvblwiXSA9IHRoaXMuYWNjZXNzRGVsZWdhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2AsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBcIm1ldGFkYXRhLWxvY2F0aW9uXCI6IHJlc3BvbnNlLmRhdGFbXCJtZXRhZGF0YS1sb2NhdGlvblwiXSxcbiAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5kYXRhLm1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICBxdWVyeTogeyBwdXJnZVJlcXVlc3RlZDogU3RyaW5nKG9wdGlvbnM/LnB1cmdlID8/IGZhbHNlKSB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9hZFRhYmxlKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIixcbiAgICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UubmFtZXNwYWNlLCBuYW1lOiByZXF1ZXN0Lm5hbWUgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL0ljZWJlcmdSZXN0Q2F0YWxvZy50c1xudmFyIEljZWJlcmdSZXN0Q2F0YWxvZyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSWNlYmVyZyBSRVNUIENhdGFsb2cgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNhdGFsb2cgY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHByZWZpeCA9IFwidjFcIjtcbiAgICBpZiAob3B0aW9ucy5jYXRhbG9nTmFtZSkge1xuICAgICAgcHJlZml4ICs9IGAvJHtvcHRpb25zLmNhdGFsb2dOYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpID8gb3B0aW9ucy5iYXNlVXJsIDogYCR7b3B0aW9ucy5iYXNlVXJsfS9gO1xuICAgIHRoaXMuY2xpZW50ID0gY3JlYXRlRmV0Y2hDbGllbnQoe1xuICAgICAgYmFzZVVybCxcbiAgICAgIGF1dGg6IG9wdGlvbnMuYXV0aCxcbiAgICAgIGZldGNoSW1wbDogb3B0aW9ucy5mZXRjaFxuICAgIH0pO1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IG9wdGlvbnMuYWNjZXNzRGVsZWdhdGlvbj8uam9pbihcIixcIik7XG4gICAgdGhpcy5uYW1lc3BhY2VPcHMgPSBuZXcgTmFtZXNwYWNlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4KTtcbiAgICB0aGlzLnRhYmxlT3BzID0gbmV3IFRhYmxlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4LCB0aGlzLmFjY2Vzc0RlbGVnYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbmFtZXNwYWNlcyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCAtIE9wdGlvbmFsIHBhcmVudCBuYW1lc3BhY2UgdG8gbGlzdCBjaGlsZHJlbiB1bmRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBuYW1lc3BhY2UgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBMaXN0IGFsbCB0b3AtbGV2ZWwgbmFtZXNwYWNlc1xuICAgKiBjb25zdCBuYW1lc3BhY2VzID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpO1xuICAgKlxuICAgKiAvLyBMaXN0IG5hbWVzcGFjZXMgdW5kZXIgYSBwYXJlbnRcbiAgICogY29uc3QgY2hpbGRyZW4gPSBhd2FpdCBjYXRhbG9nLmxpc3ROYW1lc3BhY2VzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5saXN0TmFtZXNwYWNlcyhwYXJlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG5hbWVzcGFjZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgY3JlYXRlZCBuYW1lc3BhY2UgYW5kIGl0cyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLm5hbWVzcGFjZSk7IC8vIFsnYW5hbHl0aWNzJ11cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UucHJvcGVydGllcyk7IC8vIHsgb3duZXI6ICdkYXRhLXRlYW0nLCAuLi4gfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgbmFtZXNwYWNlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIFRoZSBuYW1lc3BhY2UgbXVzdCBiZSBlbXB0eSAoY29udGFpbiBubyB0YWJsZXMpIGJlZm9yZSBpdCBjYW4gYmUgZHJvcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5uYW1lc3BhY2VPcHMuZHJvcE5hbWVzcGFjZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBOYW1lc3BhY2UgbWV0YWRhdGEgaW5jbHVkaW5nIHByb3BlcnRpZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZE5hbWVzcGFjZU1ldGFkYXRhKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhtZXRhZGF0YS5wcm9wZXJ0aWVzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIHRhYmxlcyBpbiBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxpc3QgdGFibGVzIGZyb21cbiAgICogQHJldHVybnMgQXJyYXkgb2YgdGFibGUgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB0YWJsZXMgPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGNvbnNvbGUubG9nKHRhYmxlcyk7IC8vIFt7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSwgLi4uXVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RUYWJsZXMobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMubGlzdFRhYmxlcyhuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRhYmxlIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHtcbiAgICogICAgIG5hbWU6ICdldmVudHMnLFxuICAgKiAgICAgc2NoZW1hOiB7XG4gICAqICAgICAgIHR5cGU6ICdzdHJ1Y3QnLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAqICAgICAgICAgeyBpZDogMiwgbmFtZTogJ3RpbWVzdGFtcCcsIHR5cGU6ICd0aW1lc3RhbXAnLCByZXF1aXJlZDogdHJ1ZSB9XG4gICAqICAgICAgIF0sXG4gICAqICAgICAgICdzY2hlbWEtaWQnOiAwXG4gICAqICAgICB9LFxuICAgKiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuICAgKiAgICAgICAnc3BlYy1pZCc6IDAsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgc291cmNlX2lkOiAyLCBmaWVsZF9pZDogMTAwMCwgbmFtZTogJ3RzX2RheScsIHRyYW5zZm9ybTogJ2RheScgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGFibGUncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQ2FuIHVwZGF0ZSB0aGUgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgb3IgcHJvcGVydGllcyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFVwZGF0ZSByZXF1ZXN0IHdpdGggZmllbGRzIHRvIG1vZGlmeVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBsb2NhdGlvbiBhbmQgdXBkYXRlZCB0YWJsZSBtZXRhZGF0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy51cGRhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSxcbiAgICogICB7XG4gICAqICAgICBwcm9wZXJ0aWVzOiB7ICdyZWFkLnNwbGl0LnRhcmdldC1zaXplJzogJzEzNDIxNzcyOCcgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2VbJ21ldGFkYXRhLWxvY2F0aW9uJ10pOyAvLyBzMzovLy4uLlxuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5tZXRhZGF0YSk7IC8vIFRhYmxlTWV0YWRhdGEgb2JqZWN0XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy51cGRhdGVUYWJsZShpZCwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgdGFibGUgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBkcm9wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZShpZCwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMudGFibGVPcHMuZHJvcFRhYmxlKGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgbWV0YWRhdGEgZm9yIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBpbmNsdWRpbmcgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgbG9jYXRpb24sIGV0Yy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEuc2NoZW1hKTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEubG9jYXRpb24pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxvYWRUYWJsZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG5hbWVzcGFjZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5hbWVzcGFjZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cubmFtZXNwYWNlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLm5hbWVzcGFjZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHRhYmxlIGV4aXN0cyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0YWJsZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cudGFibGVFeGlzdHMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdGFibGVFeGlzdHMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy50YWJsZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuYW1lc3BhY2UgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIElmIHRoZSBuYW1lc3BhY2UgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgdm9pZC4gSWYgY3JlYXRlZCwgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllcywgb3Igdm9pZCBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGlmIChyZXNwb25zZSkge1xuICAgKiAgIGNvbnNvbGUubG9nKCdDcmVhdGVkOicsIHJlc3BvbnNlLm5hbWVzcGFjZSk7XG4gICAqIH0gZWxzZSB7XG4gICAqICAgY29uc29sZS5sb2coJ0FscmVhZHkgZXhpc3RzJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhYmxlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgdGFibGUgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgaXRzIG1ldGFkYXRhIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgdG8gY3JlYXRlIHRoZSB0YWJsZSBpblxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRhYmxlIGNyZWF0aW9uIHJlcXVlc3QgaW5jbHVkaW5nIG5hbWUsIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGV0Yy5cbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgZm9yIHRoZSBjcmVhdGVkIG9yIGV4aXN0aW5nIHRhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgfVxufTtcblxuLy8gc3JjL2NhdGFsb2cvdHlwZXMudHNcbnZhciBERUNJTUFMX1JFR0VYID0gL15kZWNpbWFsXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpJC87XG52YXIgRklYRURfUkVHRVggPSAvXmZpeGVkXFxzKlxcW1xccyooXFxkKylcXHMqXFxdJC87XG5mdW5jdGlvbiBwYXJzZURlY2ltYWxUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKERFQ0lNQUxfUkVHRVgpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgc2NhbGU6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRml4ZWRUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKEZJWEVEX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBwYXJzZUludChtYXRjaFsxXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIERFQ0lNQUxfUkVHRVgudGVzdCh0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIEZJWEVEX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiB0eXBlc0VxdWFsKGEsIGIpIHtcbiAgY29uc3QgZGVjaW1hbEEgPSBwYXJzZURlY2ltYWxUeXBlKGEpO1xuICBjb25zdCBkZWNpbWFsQiA9IHBhcnNlRGVjaW1hbFR5cGUoYik7XG4gIGlmIChkZWNpbWFsQSAmJiBkZWNpbWFsQikge1xuICAgIHJldHVybiBkZWNpbWFsQS5wcmVjaXNpb24gPT09IGRlY2ltYWxCLnByZWNpc2lvbiAmJiBkZWNpbWFsQS5zY2FsZSA9PT0gZGVjaW1hbEIuc2NhbGU7XG4gIH1cbiAgY29uc3QgZml4ZWRBID0gcGFyc2VGaXhlZFR5cGUoYSk7XG4gIGNvbnN0IGZpeGVkQiA9IHBhcnNlRml4ZWRUeXBlKGIpO1xuICBpZiAoZml4ZWRBICYmIGZpeGVkQikge1xuICAgIHJldHVybiBmaXhlZEEubGVuZ3RoID09PSBmaXhlZEIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjaGVtYShtZXRhZGF0YSkge1xuICByZXR1cm4gbWV0YWRhdGEuc2NoZW1hcy5maW5kKChzKSA9PiBzW1wic2NoZW1hLWlkXCJdID09PSBtZXRhZGF0YVtcImN1cnJlbnQtc2NoZW1hLWlkXCJdKTtcbn1cblxuZXhwb3J0IHsgSWNlYmVyZ0Vycm9yLCBJY2ViZXJnUmVzdENhdGFsb2csIGdldEN1cnJlbnRTY2hlbWEsIGlzRGVjaW1hbFR5cGUsIGlzRml4ZWRUeXBlLCBwYXJzZURlY2ltYWxUeXBlLCBwYXJzZUZpeGVkVHlwZSwgdHlwZXNFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJJY2ViZXJnRXJyb3IiLCJFcnJvciIsImlzTm90Rm91bmQiLCJzdGF0dXMiLCJpc0NvbmZsaWN0IiwiaXNBdXRoZW50aWNhdGlvblRpbWVvdXQiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRzIiwibmFtZSIsImljZWJlcmdUeXBlIiwiaWNlYmVyZ0NvZGUiLCJkZXRhaWxzIiwiaXNDb21taXRTdGF0ZVVua25vd24iLCJpbmNsdWRlcyIsImJ1aWxkVXJsIiwiYmFzZVVybCIsInBhdGgiLCJxdWVyeSIsInVybCIsIlVSTCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiYnVpbGRBdXRoSGVhZGVycyIsImF1dGgiLCJ0eXBlIiwiQXV0aG9yaXphdGlvbiIsInRva2VuIiwiZ2V0SGVhZGVycyIsImNyZWF0ZUZldGNoQ2xpZW50Iiwib3B0aW9ucyIsImZldGNoRm4iLCJmZXRjaEltcGwiLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJyZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJhdXRoSGVhZGVycyIsInJlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0ZXh0IiwiaXNKc29uIiwiZ2V0IiwiZGF0YSIsInBhcnNlIiwib2siLCJlcnJCb2R5IiwiZXJyb3JEZXRhaWwiLCJlcnJvciIsImNvZGUiLCJuYW1lc3BhY2VUb1BhdGgiLCJuYW1lc3BhY2UiLCJqb2luIiwiTmFtZXNwYWNlT3BlcmF0aW9ucyIsImxpc3ROYW1lc3BhY2VzIiwicGFyZW50IiwicmVzcG9uc2UiLCJjbGllbnQiLCJwcmVmaXgiLCJuYW1lc3BhY2VzIiwibWFwIiwibnMiLCJjcmVhdGVOYW1lc3BhY2UiLCJpZCIsIm1ldGFkYXRhIiwicHJvcGVydGllcyIsImRyb3BOYW1lc3BhY2UiLCJsb2FkTmFtZXNwYWNlTWV0YWRhdGEiLCJuYW1lc3BhY2VFeGlzdHMiLCJjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyIsIm5hbWVzcGFjZVRvUGF0aDIiLCJUYWJsZU9wZXJhdGlvbnMiLCJsaXN0VGFibGVzIiwiaWRlbnRpZmllcnMiLCJjcmVhdGVUYWJsZSIsImFjY2Vzc0RlbGVnYXRpb24iLCJ1cGRhdGVUYWJsZSIsImRyb3BUYWJsZSIsInB1cmdlUmVxdWVzdGVkIiwiU3RyaW5nIiwicHVyZ2UiLCJsb2FkVGFibGUiLCJ0YWJsZUV4aXN0cyIsImNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMiLCJJY2ViZXJnUmVzdENhdGFsb2ciLCJuYW1lc3BhY2VPcHMiLCJ0YWJsZU9wcyIsImNhdGFsb2dOYW1lIiwiZW5kc1dpdGgiLCJERUNJTUFMX1JFR0VYIiwiRklYRURfUkVHRVgiLCJwYXJzZURlY2ltYWxUeXBlIiwibWF0Y2giLCJwcmVjaXNpb24iLCJwYXJzZUludCIsInNjYWxlIiwicGFyc2VGaXhlZFR5cGUiLCJsZW5ndGgiLCJpc0RlY2ltYWxUeXBlIiwidGVzdCIsImlzRml4ZWRUeXBlIiwidHlwZXNFcXVhbCIsImEiLCJiIiwiZGVjaW1hbEEiLCJkZWNpbWFsQiIsImZpeGVkQSIsImZpeGVkQiIsImdldEN1cnJlbnRTY2hlbWEiLCJzY2hlbWFzIiwiZmluZCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/iceberg-js/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jose/dist/browser/lib/buffer_utils.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/buffer_utils.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   concatKdf: function() { return /* binding */ concatKdf; },\n/* harmony export */   decoder: function() { return /* binding */ decoder; },\n/* harmony export */   encoder: function() { return /* binding */ encoder; },\n/* harmony export */   lengthAndInput: function() { return /* binding */ lengthAndInput; },\n/* harmony export */   p2s: function() { return /* binding */ p2s; },\n/* harmony export */   uint32be: function() { return /* binding */ uint32be; },\n/* harmony export */   uint64be: function() { return /* binding */ uint64be; }\n/* harmony export */ });\n/* harmony import */ var _runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/digest.js */ \"(app-pages-browser)/./node_modules/jose/dist/browser/runtime/digest.js\");\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nfunction concat() {\n    for(var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++){\n        buffers[_key] = arguments[_key];\n    }\n    const size = buffers.reduce((acc, param)=>{\n        let { length } = param;\n        return acc + length;\n    }, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer)=>{\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nfunction p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([\n        0\n    ]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(\"value must be >= 0 and <= \".concat(MAX_INT32 - 1, \". Received \").concat(value));\n    }\n    buf.set([\n        value >>> 24,\n        value >>> 16,\n        value >>> 8,\n        value & 0xff\n    ], offset);\n}\nfunction uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nfunction uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nfunction lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nasync function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for(let iter = 0; iter < iterations; iter++){\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await (0,_runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"sha256\", buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3NlL2Rpc3QvYnJvd3Nlci9saWIvYnVmZmVyX3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwQztBQUNuQyxNQUFNQyxVQUFVLElBQUlDLGNBQWM7QUFDbEMsTUFBTUMsVUFBVSxJQUFJQyxjQUFjO0FBQ3pDLE1BQU1DLFlBQVksS0FBSztBQUNoQixTQUFTQztJQUFPO1FBQUdDLFFBQUgsdUJBQVU7O0lBQzdCLE1BQU1DLE9BQU9ELFFBQVFFLE1BQU0sQ0FBQyxDQUFDQztZQUFLLEVBQUVDLE1BQU0sRUFBRTtlQUFLRCxNQUFNQztPQUFRO0lBQy9ELE1BQU1DLE1BQU0sSUFBSUMsV0FBV0w7SUFDM0IsSUFBSU0sSUFBSTtJQUNSUCxRQUFRUSxPQUFPLENBQUMsQ0FBQ0M7UUFDYkosSUFBSUssR0FBRyxDQUFDRCxRQUFRRjtRQUNoQkEsS0FBS0UsT0FBT0wsTUFBTTtJQUN0QjtJQUNBLE9BQU9DO0FBQ1g7QUFDTyxTQUFTTSxJQUFJQyxHQUFHLEVBQUVDLFFBQVE7SUFDN0IsT0FBT2QsT0FBT0wsUUFBUW9CLE1BQU0sQ0FBQ0YsTUFBTSxJQUFJTixXQUFXO1FBQUM7S0FBRSxHQUFHTztBQUM1RDtBQUNBLFNBQVNFLGNBQWNWLEdBQUcsRUFBRVcsS0FBSyxFQUFFQyxNQUFNO0lBQ3JDLElBQUlELFFBQVEsS0FBS0EsU0FBU2xCLFdBQVc7UUFDakMsTUFBTSxJQUFJb0IsV0FBVyw2QkFBd0RGLE9BQTNCbEIsWUFBWSxHQUFFLGVBQW1CLE9BQU5rQjtJQUNqRjtJQUNBWCxJQUFJSyxHQUFHLENBQUM7UUFBQ00sVUFBVTtRQUFJQSxVQUFVO1FBQUlBLFVBQVU7UUFBR0EsUUFBUTtLQUFLLEVBQUVDO0FBQ3JFO0FBQ08sU0FBU0UsU0FBU0gsS0FBSztJQUMxQixNQUFNSSxPQUFPQyxLQUFLQyxLQUFLLENBQUNOLFFBQVFsQjtJQUNoQyxNQUFNeUIsTUFBTVAsUUFBUWxCO0lBQ3BCLE1BQU1PLE1BQU0sSUFBSUMsV0FBVztJQUMzQlMsY0FBY1YsS0FBS2UsTUFBTTtJQUN6QkwsY0FBY1YsS0FBS2tCLEtBQUs7SUFDeEIsT0FBT2xCO0FBQ1g7QUFDTyxTQUFTbUIsU0FBU1IsS0FBSztJQUMxQixNQUFNWCxNQUFNLElBQUlDLFdBQVc7SUFDM0JTLGNBQWNWLEtBQUtXO0lBQ25CLE9BQU9YO0FBQ1g7QUFDTyxTQUFTb0IsZUFBZUMsS0FBSztJQUNoQyxPQUFPM0IsT0FBT3lCLFNBQVNFLE1BQU10QixNQUFNLEdBQUdzQjtBQUMxQztBQUNPLGVBQWVDLFVBQVVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFYixLQUFLO0lBQy9DLE1BQU1jLGFBQWFULEtBQUtVLElBQUksQ0FBQyxDQUFDRixRQUFRLEtBQUs7SUFDM0MsTUFBTUcsTUFBTSxJQUFJMUIsV0FBV3dCLGFBQWE7SUFDeEMsSUFBSyxJQUFJRyxPQUFPLEdBQUdBLE9BQU9ILFlBQVlHLE9BQVE7UUFDMUMsTUFBTTVCLE1BQU0sSUFBSUMsV0FBVyxJQUFJc0IsT0FBT3hCLE1BQU0sR0FBR1ksTUFBTVosTUFBTTtRQUMzREMsSUFBSUssR0FBRyxDQUFDYyxTQUFTUyxPQUFPO1FBQ3hCNUIsSUFBSUssR0FBRyxDQUFDa0IsUUFBUTtRQUNoQnZCLElBQUlLLEdBQUcsQ0FBQ00sT0FBTyxJQUFJWSxPQUFPeEIsTUFBTTtRQUNoQzRCLElBQUl0QixHQUFHLENBQUMsTUFBTWpCLDhEQUFNQSxDQUFDLFVBQVVZLE1BQU00QixPQUFPO0lBQ2hEO0lBQ0EsT0FBT0QsSUFBSUUsS0FBSyxDQUFDLEdBQUdMLFFBQVE7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pvc2UvZGlzdC9icm93c2VyL2xpYi9idWZmZXJfdXRpbHMuanM/ZjNkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGlnZXN0IGZyb20gJy4uL3J1bnRpbWUvZGlnZXN0LmpzJztcbmV4cG9ydCBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5leHBvcnQgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoLi4uYnVmZmVycykge1xuICAgIGNvbnN0IHNpemUgPSBidWZmZXJzLnJlZHVjZSgoYWNjLCB7IGxlbmd0aCB9KSA9PiBhY2MgKyBsZW5ndGgsIDApO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGxldCBpID0gMDtcbiAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWYuc2V0KGJ1ZmZlciwgaSk7XG4gICAgICAgIGkgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHAycyhhbGcsIHAyc0lucHV0KSB7XG4gICAgcmV0dXJuIGNvbmNhdChlbmNvZGVyLmVuY29kZShhbGcpLCBuZXcgVWludDhBcnJheShbMF0pLCBwMnNJbnB1dCk7XG59XG5mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGJ1ZiwgdmFsdWUsIG9mZnNldCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gTUFYX0lOVDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB2YWx1ZSBtdXN0IGJlID49IDAgYW5kIDw9ICR7TUFYX0lOVDMyIC0gMX0uIFJlY2VpdmVkICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGJ1Zi5zZXQoW3ZhbHVlID4+PiAyNCwgdmFsdWUgPj4+IDE2LCB2YWx1ZSA+Pj4gOCwgdmFsdWUgJiAweGZmXSwgb2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50NjRiZSh2YWx1ZSkge1xuICAgIGNvbnN0IGhpZ2ggPSBNYXRoLmZsb29yKHZhbHVlIC8gTUFYX0lOVDMyKTtcbiAgICBjb25zdCBsb3cgPSB2YWx1ZSAlIE1BWF9JTlQzMjtcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICB3cml0ZVVJbnQzMkJFKGJ1ZiwgaGlnaCwgMCk7XG4gICAgd3JpdGVVSW50MzJCRShidWYsIGxvdywgNCk7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50MzJiZSh2YWx1ZSkge1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIHdyaXRlVUludDMyQkUoYnVmLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhBbmRJbnB1dChpbnB1dCkge1xuICAgIHJldHVybiBjb25jYXQodWludDMyYmUoaW5wdXQubGVuZ3RoKSwgaW5wdXQpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmNhdEtkZihzZWNyZXQsIGJpdHMsIHZhbHVlKSB7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IE1hdGguY2VpbCgoYml0cyA+PiAzKSAvIDMyKTtcbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShpdGVyYXRpb25zICogMzIpO1xuICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQgKyBzZWNyZXQubGVuZ3RoICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgYnVmLnNldCh1aW50MzJiZShpdGVyICsgMSkpO1xuICAgICAgICBidWYuc2V0KHNlY3JldCwgNCk7XG4gICAgICAgIGJ1Zi5zZXQodmFsdWUsIDQgKyBzZWNyZXQubGVuZ3RoKTtcbiAgICAgICAgcmVzLnNldChhd2FpdCBkaWdlc3QoJ3NoYTI1NicsIGJ1ZiksIGl0ZXIgKiAzMik7XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgYml0cyA+PiAzKTtcbn1cbiJdLCJuYW1lcyI6WyJkaWdlc3QiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJNQVhfSU5UMzIiLCJjb25jYXQiLCJidWZmZXJzIiwic2l6ZSIsInJlZHVjZSIsImFjYyIsImxlbmd0aCIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJpIiwiZm9yRWFjaCIsImJ1ZmZlciIsInNldCIsInAycyIsImFsZyIsInAyc0lucHV0IiwiZW5jb2RlIiwid3JpdGVVSW50MzJCRSIsInZhbHVlIiwib2Zmc2V0IiwiUmFuZ2VFcnJvciIsInVpbnQ2NGJlIiwiaGlnaCIsIk1hdGgiLCJmbG9vciIsImxvdyIsInVpbnQzMmJlIiwibGVuZ3RoQW5kSW5wdXQiLCJpbnB1dCIsImNvbmNhdEtkZiIsInNlY3JldCIsImJpdHMiLCJpdGVyYXRpb25zIiwiY2VpbCIsInJlcyIsIml0ZXIiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jose/dist/browser/lib/buffer_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jose/dist/browser/runtime/base64url.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/base64url.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   decodeBase64: function() { return /* binding */ decodeBase64; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   encodeBase64: function() { return /* binding */ encodeBase64; }\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"(app-pages-browser)/./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\nconst encodeBase64 = (input)=>{\n    let unencoded = input;\n    if (typeof unencoded === \"string\") {\n        unencoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for(let i = 0; i < unencoded.length; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\"));\n};\nconst encode = (input)=>{\n    return encodeBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n};\nconst decodeBase64 = (encoded)=>{\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nconst decode = (input)=>{\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\");\n    try {\n        return decodeBase64(encoded);\n    } catch (_a) {\n        throw new TypeError(\"The input to be decoded is not correctly encoded.\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3NlL2Rpc3QvYnJvd3Nlci9ydW50aW1lL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRDtBQUNuRCxNQUFNRSxlQUFlLENBQUNDO0lBQ3pCLElBQUlDLFlBQVlEO0lBQ2hCLElBQUksT0FBT0MsY0FBYyxVQUFVO1FBQy9CQSxZQUFZSix5REFBT0EsQ0FBQ0ssTUFBTSxDQUFDRDtJQUMvQjtJQUNBLE1BQU1FLGFBQWE7SUFDbkIsTUFBTUMsTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFVBQVVLLE1BQU0sRUFBRUQsS0FBS0YsV0FBWTtRQUNuREMsSUFBSUcsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNVCxVQUFVVSxRQUFRLENBQUNOLEdBQUdBLElBQUlGO0lBQ3ZFO0lBQ0EsT0FBT1MsS0FBS1IsSUFBSVMsSUFBSSxDQUFDO0FBQ3pCLEVBQUU7QUFDSyxNQUFNWCxTQUFTLENBQUNGO0lBQ25CLE9BQU9ELGFBQWFDLE9BQU9jLE9BQU8sQ0FBQyxNQUFNLElBQUlBLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPO0FBQ3BGLEVBQUU7QUFDSyxNQUFNQyxlQUFlLENBQUNDO0lBQ3pCLE1BQU1DLFNBQVNDLEtBQUtGO0lBQ3BCLE1BQU1HLFFBQVEsSUFBSUMsV0FBV0gsT0FBT1gsTUFBTTtJQUMxQyxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSVksT0FBT1gsTUFBTSxFQUFFRCxJQUFLO1FBQ3BDYyxLQUFLLENBQUNkLEVBQUUsR0FBR1ksT0FBT0ksVUFBVSxDQUFDaEI7SUFDakM7SUFDQSxPQUFPYztBQUNYLEVBQUU7QUFDSyxNQUFNRyxTQUFTLENBQUN0QjtJQUNuQixJQUFJZ0IsVUFBVWhCO0lBQ2QsSUFBSWdCLG1CQUFtQkksWUFBWTtRQUMvQkosVUFBVWxCLHlEQUFPQSxDQUFDd0IsTUFBTSxDQUFDTjtJQUM3QjtJQUNBQSxVQUFVQSxRQUFRRixPQUFPLENBQUMsTUFBTSxLQUFLQSxPQUFPLENBQUMsTUFBTSxLQUFLQSxPQUFPLENBQUMsT0FBTztJQUN2RSxJQUFJO1FBQ0EsT0FBT0MsYUFBYUM7SUFDeEIsRUFDQSxPQUFPTyxJQUFJO1FBQ1AsTUFBTSxJQUFJQyxVQUFVO0lBQ3hCO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvam9zZS9kaXN0L2Jyb3dzZXIvcnVudGltZS9iYXNlNjR1cmwuanM/MmQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbmNvZGVyLCBkZWNvZGVyIH0gZnJvbSAnLi4vbGliL2J1ZmZlcl91dGlscy5qcyc7XG5leHBvcnQgY29uc3QgZW5jb2RlQmFzZTY0ID0gKGlucHV0KSA9PiB7XG4gICAgbGV0IHVuZW5jb2RlZCA9IGlucHV0O1xuICAgIGlmICh0eXBlb2YgdW5lbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB1bmVuY29kZWQgPSBlbmNvZGVyLmVuY29kZSh1bmVuY29kZWQpO1xuICAgIH1cbiAgICBjb25zdCBDSFVOS19TSVpFID0gMHg4MDAwO1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5lbmNvZGVkLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgIGFyci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdW5lbmNvZGVkLnN1YmFycmF5KGksIGkgKyBDSFVOS19TSVpFKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShhcnIuam9pbignJykpO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAoaW5wdXQpID0+IHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0KGlucHV0KS5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlQmFzZTY0ID0gKGVuY29kZWQpID0+IHtcbiAgICBjb25zdCBiaW5hcnkgPSBhdG9iKGVuY29kZWQpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoaW5wdXQpID0+IHtcbiAgICBsZXQgZW5jb2RlZCA9IGlucHV0O1xuICAgIGlmIChlbmNvZGVkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBlbmNvZGVkID0gZGVjb2Rlci5kZWNvZGUoZW5jb2RlZCk7XG4gICAgfVxuICAgIGVuY29kZWQgPSBlbmNvZGVkLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJykucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlQmFzZTY0KGVuY29kZWQpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGlucHV0IHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLicpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiZW5jb2RlciIsImRlY29kZXIiLCJlbmNvZGVCYXNlNjQiLCJpbnB1dCIsInVuZW5jb2RlZCIsImVuY29kZSIsIkNIVU5LX1NJWkUiLCJhcnIiLCJpIiwibGVuZ3RoIiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5Iiwic3ViYXJyYXkiLCJidG9hIiwiam9pbiIsInJlcGxhY2UiLCJkZWNvZGVCYXNlNjQiLCJlbmNvZGVkIiwiYmluYXJ5IiwiYXRvYiIsImJ5dGVzIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJkZWNvZGUiLCJfYSIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jose/dist/browser/runtime/base64url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jose/dist/browser/runtime/digest.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/digest.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"(app-pages-browser)/./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\nconst digest = async (algorithm, data)=>{\n    const subtleDigest = \"SHA-\".concat(algorithm.slice(-3));\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.digest(subtleDigest, data));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (digest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3NlL2Rpc3QvYnJvd3Nlci9ydW50aW1lL2RpZ2VzdC5qcyIsIm1hcHBpbmdzIjoiOztBQUFvQztBQUNwQyxNQUFNQyxTQUFTLE9BQU9DLFdBQVdDO0lBQzdCLE1BQU1DLGVBQWUsT0FBMkIsT0FBcEJGLFVBQVVHLEtBQUssQ0FBQyxDQUFDO0lBQzdDLE9BQU8sSUFBSUMsV0FBVyxNQUFNTixxREFBTUEsQ0FBQ08sTUFBTSxDQUFDTixNQUFNLENBQUNHLGNBQWNEO0FBQ25FO0FBQ0EsK0RBQWVGLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pvc2UvZGlzdC9icm93c2VyL3J1bnRpbWUvZGlnZXN0LmpzPzhmZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICcuL3dlYmNyeXB0by5qcyc7XG5jb25zdCBkaWdlc3QgPSBhc3luYyAoYWxnb3JpdGhtLCBkYXRhKSA9PiB7XG4gICAgY29uc3Qgc3VidGxlRGlnZXN0ID0gYFNIQS0ke2FsZ29yaXRobS5zbGljZSgtMyl9YDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3Qoc3VidGxlRGlnZXN0LCBkYXRhKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgZGlnZXN0O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsImRpZ2VzdCIsImFsZ29yaXRobSIsImRhdGEiLCJzdWJ0bGVEaWdlc3QiLCJzbGljZSIsIlVpbnQ4QXJyYXkiLCJzdWJ0bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jose/dist/browser/runtime/digest.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jose/dist/browser/runtime/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/webcrypto.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCryptoKey: function() { return /* binding */ isCryptoKey; }\n/* harmony export */ });\n/* harmony default export */ __webpack_exports__[\"default\"] = (crypto);\nconst isCryptoKey = (key)=>key instanceof CryptoKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3NlL2Rpc3QvYnJvd3Nlci9ydW50aW1lL3dlYmNyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsK0RBQWVBLE1BQU1BLEVBQUM7QUFDZixNQUFNQyxjQUFjLENBQUNDLE1BQVFBLGVBQWVDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pvc2UvZGlzdC9icm93c2VyL3J1bnRpbWUvd2ViY3J5cHRvLmpzPzQ0ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY3J5cHRvO1xuZXhwb3J0IGNvbnN0IGlzQ3J5cHRvS2V5ID0gKGtleSkgPT4ga2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsImlzQ3J5cHRvS2V5Iiwia2V5IiwiQ3J5cHRvS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jose/dist/browser/runtime/webcrypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jose/dist/browser/util/base64url.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/base64url.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"(app-pages-browser)/./node_modules/jose/dist/browser/runtime/base64url.js\");\n\nconst encode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode;\nconst decode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3NlL2Rpc3QvYnJvd3Nlci91dGlsL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDOUMsTUFBTUMsU0FBU0QseURBQWdCLENBQUM7QUFDaEMsTUFBTUUsU0FBU0YseURBQWdCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pvc2UvZGlzdC9icm93c2VyL3V0aWwvYmFzZTY0dXJsLmpzPzYxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFzZTY0dXJsIGZyb20gJy4uL3J1bnRpbWUvYmFzZTY0dXJsLmpzJztcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBiYXNlNjR1cmwuZW5jb2RlO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGJhc2U2NHVybC5kZWNvZGU7XG4iXSwibmFtZXMiOlsiYmFzZTY0dXJsIiwiZW5jb2RlIiwiZGVjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jose/dist/browser/util/base64url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: function() { return /* binding */ __addDisposableResource; },\n/* harmony export */   __assign: function() { return /* binding */ __assign; },\n/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },\n/* harmony export */   __await: function() { return /* binding */ __await; },\n/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },\n/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },\n/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },\n/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },\n/* harmony export */   __decorate: function() { return /* binding */ __decorate; },\n/* harmony export */   __disposeResources: function() { return /* binding */ __disposeResources; },\n/* harmony export */   __esDecorate: function() { return /* binding */ __esDecorate; },\n/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },\n/* harmony export */   __extends: function() { return /* binding */ __extends; },\n/* harmony export */   __generator: function() { return /* binding */ __generator; },\n/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },\n/* harmony export */   __importStar: function() { return /* binding */ __importStar; },\n/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   __metadata: function() { return /* binding */ __metadata; },\n/* harmony export */   __param: function() { return /* binding */ __param; },\n/* harmony export */   __propKey: function() { return /* binding */ __propKey; },\n/* harmony export */   __read: function() { return /* binding */ __read; },\n/* harmony export */   __rest: function() { return /* binding */ __rest; },\n/* harmony export */   __rewriteRelativeImportExtension: function() { return /* binding */ __rewriteRelativeImportExtension; },\n/* harmony export */   __runInitializers: function() { return /* binding */ __runInitializers; },\n/* harmony export */   __setFunctionName: function() { return /* binding */ __setFunctionName; },\n/* harmony export */   __spread: function() { return /* binding */ __spread; },\n/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },\n/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },\n/* harmony export */   __values: function() { return /* binding */ __values; }\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n}\n;\nfunction __runInitializers(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++){\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n}\n;\nfunction __propKey(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n}\n;\nfunction __setFunctionName(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", {\n        configurable: true,\n        value: prefix ? \"\".concat(prefix, \" \", name) : name\n    });\n}\n;\nfunction __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __createBinding = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction __exportStar(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\n/** @deprecated */ function __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\n;\nvar __setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nvar ownKeys = function(o) {\n    ownKeys = Object.getOwnPropertyNames || function(o) {\n        var ar = [];\n        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n        return ar;\n    };\n    return ownKeys(o);\n};\nfunction __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n}\nfunction __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\nfunction __addDisposableResource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction __disposeResources(env) {\n    function fail(e) {\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n        env.hasError = true;\n    }\n    var r, s = 0;\n    function next() {\n        while(r = env.stack.pop()){\n            try {\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                if (r.dispose) {\n                    var result = r.dispose.call(r.value);\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                        fail(e);\n                        return next();\n                    });\n                } else s |= 1;\n            } catch (e) {\n                fail(e);\n            }\n        }\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n        if (env.hasError) throw env.error;\n    }\n    return next();\n}\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : d + ext + \".\" + cm.toLowerCase() + \"js\";\n        });\n    }\n    return path;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    __extends,\n    __assign,\n    __rest,\n    __decorate,\n    __param,\n    __esDecorate,\n    __runInitializers,\n    __propKey,\n    __setFunctionName,\n    __metadata,\n    __awaiter,\n    __generator,\n    __createBinding,\n    __exportStar,\n    __values,\n    __read,\n    __spread,\n    __spreadArrays,\n    __spreadArray,\n    __await,\n    __asyncGenerator,\n    __asyncDelegator,\n    __asyncValues,\n    __makeTemplateObject,\n    __importStar,\n    __importDefault,\n    __classPrivateFieldGet,\n    __classPrivateFieldSet,\n    __classPrivateFieldIn,\n    __addDisposableResource,\n    __disposeResources,\n    __rewriteRelativeImportExtension\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUU5RCxJQUFJQSxnQkFBZ0IsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQy9CRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7UUFBRUMsV0FBVyxFQUFFO0lBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUksU0FBUyxHQUFHSDtJQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQUU7SUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7QUFDMUI7QUFFTyxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDNUIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJVSxVQUFVLHlCQUF5QkMsT0FBT1gsS0FBSztJQUM3REYsY0FBY0MsR0FBR0M7SUFDakIsU0FBU1k7UUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2Q7SUFBRztJQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9hLE1BQU0sQ0FBQ2QsS0FBTVksQ0FBQUEsR0FBR04sU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSU0sSUFBRztBQUNwRjtBQUVPLElBQUlHLFdBQVc7SUFDcEJBLFdBQVdkLE9BQU9lLE1BQU0sSUFBSSxTQUFTRCxTQUFTRSxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVB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T0YsTUFBTUgsY0FBYyxTQUFTLFFBQVFwTCxLQUFNLEVBQUN3TCxPQUFPLENBQUNDLEVBQUMsSUFBSzFFLElBQUsvRyxJQUFJd0wsTUFBTSxNQUFNQyxHQUFHQyxXQUFXLEtBQUs7UUFDN0c7SUFDSjtJQUNBLE9BQU9QO0FBQ1Q7QUFFQSwrREFBZTtJQUNieks7SUFDQU07SUFDQVM7SUFDQUs7SUFDQVc7SUFDQUc7SUFDQXNCO0lBQ0FJO0lBQ0FHO0lBQ0FJO0lBQ0FJO0lBQ0FhO0lBQ0FlO0lBQ0FTO0lBQ0FDO0lBQ0FDO0lBQ0FHO0lBQ0FDO0lBQ0FLO0lBQ0FNO0lBQ0FDO0lBQ0FTO0lBQ0FDO0lBQ0FDO0lBQ0FNO0lBQ0FFO0lBQ0FFO0lBQ0FJO0lBQ0FDO0lBQ0FDO0lBQ0FZO0lBQ0FHO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzPzY3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIl0sIm5hbWVzIjpbImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19yZXN0IiwiZSIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fZXNEZWNvcmF0ZSIsImN0b3IiLCJkZXNjcmlwdG9ySW4iLCJjb250ZXh0SW4iLCJpbml0aWFsaXplcnMiLCJleHRyYUluaXRpYWxpemVycyIsImFjY2VwdCIsImYiLCJraW5kIiwiZGVzY3JpcHRvciIsIm5hbWUiLCJfIiwiZG9uZSIsImNvbnRleHQiLCJhY2Nlc3MiLCJhZGRJbml0aWFsaXplciIsInB1c2giLCJyZXN1bHQiLCJnZXQiLCJzZXQiLCJpbml0IiwidW5zaGlmdCIsIl9fcnVuSW5pdGlhbGl6ZXJzIiwidGhpc0FyZyIsInZhbHVlIiwidXNlVmFsdWUiLCJfX3Byb3BLZXkiLCJ4IiwiY29uY2F0IiwiX19zZXRGdW5jdGlvbk5hbWUiLCJwcmVmaXgiLCJkZXNjcmlwdGlvbiIsImNvbmZpZ3VyYWJsZSIsIl9fbWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJtZXRhZGF0YSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsInkiLCJnIiwiSXRlcmF0b3IiLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2Iiwib3AiLCJwb3AiLCJfX2NyZWF0ZUJpbmRpbmciLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJfX2V4cG9ydFN0YXIiLCJfX3ZhbHVlcyIsIl9fcmVhZCIsImFyIiwiZXJyb3IiLCJfX3NwcmVhZCIsIl9fc3ByZWFkQXJyYXlzIiwiaWwiLCJhIiwiaiIsImpsIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwic2xpY2UiLCJfX2F3YWl0IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJxIiwiQXN5bmNJdGVyYXRvciIsImF3YWl0UmV0dXJuIiwicmVzdW1lIiwic2V0dGxlIiwiZnVsZmlsbCIsInNoaWZ0IiwiX19hc3luY0RlbGVnYXRvciIsIl9fYXN5bmNWYWx1ZXMiLCJfX21ha2VUZW1wbGF0ZU9iamVjdCIsImNvb2tlZCIsInJhdyIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19pbXBvcnRTdGFyIiwibW9kIiwiX19pbXBvcnREZWZhdWx0IiwiZGVmYXVsdCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwiaGFzIiwiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRJbiIsIl9fYWRkRGlzcG9zYWJsZVJlc291cmNlIiwiZW52IiwiYXN5bmMiLCJkaXNwb3NlIiwiaW5uZXIiLCJhc3luY0Rpc3Bvc2UiLCJzdGFjayIsIl9TdXBwcmVzc2VkRXJyb3IiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwiX19kaXNwb3NlUmVzb3VyY2VzIiwiZmFpbCIsImhhc0Vycm9yIiwiX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24iLCJwYXRoIiwicHJlc2VydmVKc3giLCJ0ZXN0IiwicmVwbGFjZSIsInRzeCIsImV4dCIsImNtIiwidG9Mb3dlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\n"));

/***/ })

});